   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"queue.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.comm	xQueueRegistry,64,4
  20              		.section	.text.xQueueGenericReset,"ax",%progbits
  21              		.align	2
  22              		.global	xQueueGenericReset
  23              		.thumb
  24              		.thumb_func
  26              	xQueueGenericReset:
  27              	.LFB1:
  28              		.file 1 "lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c"
   1:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*
   2:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****     FreeRTOS V8.1.2 - Copyright (C) 2014 Real Time Engineers Ltd.
   3:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****     All rights reserved
   4:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
   5:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
   7:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****     ***************************************************************************
   8:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****      *                                                                       *
   9:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  10:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****      *    robust, strictly quality controlled, supported, and cross          *
  11:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****      *    platform software that has become a de facto standard.             *
  12:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****      *                                                                       *
  13:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  14:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  15:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  16:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****      *                                                                       *
  17:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****      *    Thank you!                                                         *
  18:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****      *                                                                       *
  19:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****     ***************************************************************************
  20:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
  21:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****     This file is part of the FreeRTOS distribution.
  22:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
  23:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  24:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****     the terms of the GNU General Public License (version 2) as published by the
  25:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  26:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
  27:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****     >>!   NOTE: The modification to the GPL is included to allow you to     !<<
  28:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****     >>!   distribute a combined work that includes FreeRTOS without being   !<<
  29:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****     >>!   obliged to provide the source code for proprietary components     !<<
  30:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****     >>!   outside of the FreeRTOS kernel.                                   !<<
  31:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
  32:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  33:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  34:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  35:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****     link: http://www.freertos.org/a00114.html
  36:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
  37:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****     1 tab == 4 spaces!
  38:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
  39:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****     ***************************************************************************
  40:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****      *                                                                       *
  41:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  42:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****      *    not run, what could be wrong?"                                     *
  43:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****      *                                                                       *
  44:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  45:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****      *                                                                       *
  46:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****     ***************************************************************************
  47:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
  48:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  49:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****     license and Real Time Engineers Ltd. contact details.
  50:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
  51:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  52:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  53:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  54:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
  55:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  56:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  57:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****     licenses offer ticketed support, indemnification and middleware.
  58:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
  59:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  60:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****     engineered and independently SIL3 certified version for use in safety and
  61:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****     mission critical applications that require provable dependability.
  62:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
  63:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****     1 tab == 4 spaces!
  64:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** */
  65:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
  66:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #include <stdlib.h>
  67:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #include <string.h>
  68:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
  69:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  70:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  71:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** task.h is included from an application file. */
  72:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  73:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
  74:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #include "FreeRTOS.h"
  75:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #include "task.h"
  76:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #include "queue.h"
  77:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
  78:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  79:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	#include "croutine.h"
  80:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #endif
  81:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
  82:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  83:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  84:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** header files above, but not in this file, in order to generate the correct
  85:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** privileged Vs unprivileged linkage and placement. */
  86:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  87:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
  88:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
  89:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /* Constants used with the xRxLock and xTxLock structure members. */
  90:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #define queueUNLOCKED					( ( BaseType_t ) -1 )
  91:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #define queueLOCKED_UNMODIFIED			( ( BaseType_t ) 0 )
  92:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
  93:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /* When the Queue_t structure is used to represent a base queue its pcHead and
  94:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** pcTail members are used as pointers into the queue storage area.  When the
  95:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
  96:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** not necessary, and the pcHead pointer is set to NULL to indicate that the
  97:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** pcTail pointer actually points to the mutex holder (if any).  Map alternative
  98:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** names to the pcHead and pcTail structure members to ensure the readability of
  99:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** the code is maintained despite this dual use of two structure members.  An
 100:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** alternative implementation would be to use a union, but use of a union is
 101:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** against the coding standard (although an exception to the standard has been
 102:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** permitted where the dual use also significantly changes the type of the
 103:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** structure member). */
 104:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #define pxMutexHolder					pcTail
 105:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #define uxQueueType						pcHead
 106:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
 107:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 108:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /* Semaphores do not actually store or copy data, so have an item size of
 109:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** zero. */
 110:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
 111:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
 112:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 113:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #if( configUSE_PREEMPTION == 0 )
 114:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	/* If the cooperative scheduler is being used then a yield should not be
 115:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	performed just because a higher priority task has been woken. */
 116:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION()
 117:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #else
 118:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
 119:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #endif
 120:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 121:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*
 122:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****  * Definition of the queue used by the scheduler.
 123:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****  * Items are queued by copy, not reference.
 124:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****  */
 125:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** typedef struct QueueDefinition
 126:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** {
 127:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
 128:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte i
 129:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
 130:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 131:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	union							/* Use of a union is an exception to the coding standard to ensure two mutually exclus
 132:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
 133:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		int8_t *pcReadFrom;			/*< Points to the last place that a queued item was read from when the stru
 134:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex h
 135:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	} u;
 136:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 137:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  
 138:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.
 139:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 140:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
 141:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, n
 142:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
 143:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 144:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	volatile BaseType_t xRxLock;	/*< Stores the number of items received from the queue (removed from 
 145:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	volatile BaseType_t xTxLock;	/*< Stores the number of items transmitted to the queue (added to the
 146:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 147:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 148:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		UBaseType_t uxQueueNumber;
 149:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		uint8_t ucQueueType;
 150:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	#endif
 151:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 152:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	#if ( configUSE_QUEUE_SETS == 1 )
 153:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		struct QueueDefinition *pxQueueSetContainer;
 154:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	#endif
 155:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 156:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** } xQUEUE;
 157:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 158:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
 159:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** name below to enable the use of older kernel aware debuggers. */
 160:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** typedef xQUEUE Queue_t;
 161:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 162:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 163:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 164:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*
 165:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 166:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 167:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****  */
 168:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
 169:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 170:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 171:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 172:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	more user friendly. */
 173:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 174:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
 175:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single c
 176:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		QueueHandle_t xHandle;
 177:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	} xQueueRegistryItem;
 178:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 179:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	/* The old xQueueRegistryItem name is maintained above then typedefed to the
 180:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	new xQueueRegistryItem name below to enable the use of older kernel aware
 181:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	debuggers. */
 182:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	typedef xQueueRegistryItem QueueRegistryItem_t;
 183:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 184:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	/* The queue registry is simply an array of QueueRegistryItem_t structures.
 185:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 186:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	array position being vacant. */
 187:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 188:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 189:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
 190:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 191:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*
 192:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 193:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 194:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 195:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 196:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 197:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 198:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****  */
 199:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
 200:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 201:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*
 202:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 203:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****  *
 204:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 205:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****  */
 206:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 207:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 208:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*
 209:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 210:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****  *
 211:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 212:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****  */
 213:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 214:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 215:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*
 216:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 217:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****  * back of the queue.
 218:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****  */
 219:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
 220:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 221:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*
 222:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****  * Copies an item out of a queue.
 223:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****  */
 224:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCT
 225:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 226:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
 227:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	/*
 228:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	 * Checks to see if a queue is a member of a queue set, and if so, notifies
 229:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	 * the queue set that the queue contains data.
 230:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	 */
 231:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCop
 232:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #endif
 233:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 234:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 235:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 236:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*
 237:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 238:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****  * accessing the queue event lists.
 239:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c ****  */
 240:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #define prvLockQueue( pxQueue )								\
 241:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();									\
 242:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{														\
 243:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		if( ( pxQueue )->xRxLock == queueUNLOCKED )			\
 244:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{													\
 245:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			( pxQueue )->xRxLock = queueLOCKED_UNMODIFIED;	\
 246:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}													\
 247:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		if( ( pxQueue )->xTxLock == queueUNLOCKED )			\
 248:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{													\
 249:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			( pxQueue )->xTxLock = queueLOCKED_UNMODIFIED;	\
 250:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}													\
 251:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}														\
 252:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL()
 253:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 254:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 255:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
 256:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** {
  29              		.loc 1 256 0
  30              		.cfi_startproc
  31              		@ args = 0, pretend = 0, frame = 16
  32              		@ frame_needed = 1, uses_anonymous_args = 0
  33 0000 80B5     		push	{r7, lr}
  34              	.LCFI0:
  35              		.cfi_def_cfa_offset 8
  36              		.cfi_offset 7, -8
  37              		.cfi_offset 14, -4
  38 0002 84B0     		sub	sp, sp, #16
  39              	.LCFI1:
  40              		.cfi_def_cfa_offset 24
  41 0004 00AF     		add	r7, sp, #0
  42              	.LCFI2:
  43              		.cfi_def_cfa_register 7
  44 0006 7860     		str	r0, [r7, #4]
  45 0008 3960     		str	r1, [r7]
 257:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
  46              		.loc 1 257 0
  47 000a 7B68     		ldr	r3, [r7, #4]
  48 000c FB60     		str	r3, [r7, #12]
 258:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 259:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
  49              		.loc 1 259 0
  50 000e FB68     		ldr	r3, [r7, #12]
  51 0010 002B     		cmp	r3, #0
  52 0012 02D1     		bne	.L2
  53              		.loc 1 259 0 is_stmt 0 discriminator 1
  54 0014 FFF7FEFF 		bl	ulPortSetInterruptMask
  55              	.L3:
  56 0018 FEE7     		b	.L3
  57              	.L2:
 260:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 261:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
  58              		.loc 1 261 0 is_stmt 1
  59 001a FFF7FEFF 		bl	vPortEnterCritical
 262:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
 263:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
  60              		.loc 1 263 0
  61 001e FB68     		ldr	r3, [r7, #12]
  62 0020 1A68     		ldr	r2, [r3]
  63 0022 FB68     		ldr	r3, [r7, #12]
  64 0024 DB6B     		ldr	r3, [r3, #60]
  65 0026 F968     		ldr	r1, [r7, #12]
  66 0028 096C     		ldr	r1, [r1, #64]
  67 002a 01FB03F3 		mul	r3, r1, r3
  68 002e 1A44     		add	r2, r2, r3
  69 0030 FB68     		ldr	r3, [r7, #12]
  70 0032 5A60     		str	r2, [r3, #4]
 264:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
  71              		.loc 1 264 0
  72 0034 FB68     		ldr	r3, [r7, #12]
  73 0036 0022     		movs	r2, #0
  74 0038 9A63     		str	r2, [r3, #56]
 265:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
  75              		.loc 1 265 0
  76 003a FB68     		ldr	r3, [r7, #12]
  77 003c 1A68     		ldr	r2, [r3]
  78 003e FB68     		ldr	r3, [r7, #12]
  79 0040 9A60     		str	r2, [r3, #8]
 266:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue-
  80              		.loc 1 266 0
  81 0042 FB68     		ldr	r3, [r7, #12]
  82 0044 1A68     		ldr	r2, [r3]
  83 0046 FB68     		ldr	r3, [r7, #12]
  84 0048 DB6B     		ldr	r3, [r3, #60]
  85 004a 013B     		subs	r3, r3, #1
  86 004c F968     		ldr	r1, [r7, #12]
  87 004e 096C     		ldr	r1, [r1, #64]
  88 0050 01FB03F3 		mul	r3, r1, r3
  89 0054 1A44     		add	r2, r2, r3
  90 0056 FB68     		ldr	r3, [r7, #12]
  91 0058 DA60     		str	r2, [r3, #12]
 267:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
  92              		.loc 1 267 0
  93 005a FB68     		ldr	r3, [r7, #12]
  94 005c 4FF0FF32 		mov	r2, #-1
  95 0060 5A64     		str	r2, [r3, #68]
 268:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
  96              		.loc 1 268 0
  97 0062 FB68     		ldr	r3, [r7, #12]
  98 0064 4FF0FF32 		mov	r2, #-1
  99 0068 9A64     		str	r2, [r3, #72]
 269:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 270:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		if( xNewQueue == pdFALSE )
 100              		.loc 1 270 0
 101 006a 3B68     		ldr	r3, [r7]
 102 006c 002B     		cmp	r3, #0
 103 006e 0ED1     		bne	.L4
 271:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
 272:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			/* If there are tasks blocked waiting to read from the queue, then
 273:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			the tasks will remain blocked as after this function exits the queue
 274:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			will still be empty.  If there are tasks blocked waiting to write to
 275:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			the queue, then one should be unblocked as after this function exits
 276:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			it will be possible to write to it. */
 277:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 104              		.loc 1 277 0
 105 0070 FB68     		ldr	r3, [r7, #12]
 106 0072 1B69     		ldr	r3, [r3, #16]
 107 0074 002B     		cmp	r3, #0
 108 0076 14D0     		beq	.L5
 278:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
 279:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 109              		.loc 1 279 0
 110 0078 FB68     		ldr	r3, [r7, #12]
 111 007a 1033     		adds	r3, r3, #16
 112 007c 1846     		mov	r0, r3
 113 007e FFF7FEFF 		bl	xTaskRemoveFromEventList
 114 0082 0346     		mov	r3, r0
 115 0084 012B     		cmp	r3, #1
 116 0086 0CD1     		bne	.L5
 280:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
 281:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					queueYIELD_IF_USING_PREEMPTION();
 117              		.loc 1 281 0
 118 0088 FFF7FEFF 		bl	vPortYield
 119 008c 09E0     		b	.L5
 120              	.L4:
 282:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
 283:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				else
 284:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
 285:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 286:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
 287:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
 288:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			else
 289:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
 290:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 291:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
 292:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
 293:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		else
 294:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
 295:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			/* Ensure the event queues start in the correct state. */
 296:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 121              		.loc 1 296 0
 122 008e FB68     		ldr	r3, [r7, #12]
 123 0090 1033     		adds	r3, r3, #16
 124 0092 1846     		mov	r0, r3
 125 0094 FFF7FEFF 		bl	vListInitialise
 297:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 126              		.loc 1 297 0
 127 0098 FB68     		ldr	r3, [r7, #12]
 128 009a 2433     		adds	r3, r3, #36
 129 009c 1846     		mov	r0, r3
 130 009e FFF7FEFF 		bl	vListInitialise
 131              	.L5:
 298:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
 299:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
 300:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 132              		.loc 1 300 0
 133 00a2 FFF7FEFF 		bl	vPortExitCritical
 301:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 302:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	/* A value is returned for calling semantic consistency with previous
 303:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	versions. */
 304:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	return pdPASS;
 134              		.loc 1 304 0
 135 00a6 0123     		movs	r3, #1
 305:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** }
 136              		.loc 1 305 0
 137 00a8 1846     		mov	r0, r3
 138 00aa 1037     		adds	r7, r7, #16
 139 00ac BD46     		mov	sp, r7
 140              		@ sp needed
 141 00ae 80BD     		pop	{r7, pc}
 142              		.cfi_endproc
 143              	.LFE1:
 145              		.section	.text.xQueueGenericCreate,"ax",%progbits
 146              		.align	2
 147              		.global	xQueueGenericCreate
 148              		.thumb
 149              		.thumb_func
 151              	xQueueGenericCreate:
 152              	.LFB2:
 306:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 307:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 308:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, c
 309:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** {
 153              		.loc 1 309 0
 154              		.cfi_startproc
 155              		@ args = 0, pretend = 0, frame = 32
 156              		@ frame_needed = 1, uses_anonymous_args = 0
 157 0000 80B5     		push	{r7, lr}
 158              	.LCFI3:
 159              		.cfi_def_cfa_offset 8
 160              		.cfi_offset 7, -8
 161              		.cfi_offset 14, -4
 162 0002 88B0     		sub	sp, sp, #32
 163              	.LCFI4:
 164              		.cfi_def_cfa_offset 40
 165 0004 00AF     		add	r7, sp, #0
 166              	.LCFI5:
 167              		.cfi_def_cfa_register 7
 168 0006 F860     		str	r0, [r7, #12]
 169 0008 B960     		str	r1, [r7, #8]
 170 000a 1346     		mov	r3, r2
 171 000c FB71     		strb	r3, [r7, #7]
 310:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** Queue_t *pxNewQueue;
 311:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** size_t xQueueSizeInBytes;
 312:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** QueueHandle_t xReturn = NULL;
 172              		.loc 1 312 0
 173 000e 0023     		movs	r3, #0
 174 0010 FB61     		str	r3, [r7, #28]
 313:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 314:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	/* Remove compiler warnings about unused parameters should
 315:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	configUSE_TRACE_FACILITY not be set to 1. */
 316:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	( void ) ucQueueType;
 317:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 318:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	/* Allocate the new queue structure. */
 319:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	if( uxQueueLength > ( UBaseType_t ) 0 )
 175              		.loc 1 319 0
 176 0012 FB68     		ldr	r3, [r7, #12]
 177 0014 002B     		cmp	r3, #0
 178 0016 2AD0     		beq	.L8
 320:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
 321:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
 179              		.loc 1 321 0
 180 0018 5420     		movs	r0, #84
 181 001a FFF7FEFF 		bl	pvPortMalloc
 182 001e B861     		str	r0, [r7, #24]
 322:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		if( pxNewQueue != NULL )
 183              		.loc 1 322 0
 184 0020 BB69     		ldr	r3, [r7, #24]
 185 0022 002B     		cmp	r3, #0
 186 0024 23D0     		beq	.L8
 323:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
 324:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			/* Create the list of pointers to queue items.  The queue is one byte
 325:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			longer than asked for to make wrap checking easier/faster. */
 326:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA
 187              		.loc 1 326 0
 188 0026 FB68     		ldr	r3, [r7, #12]
 189 0028 BA68     		ldr	r2, [r7, #8]
 190 002a 02FB03F3 		mul	r3, r2, r3
 191 002e 0133     		adds	r3, r3, #1
 192 0030 7B61     		str	r3, [r7, #20]
 327:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 328:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
 193              		.loc 1 328 0
 194 0032 7869     		ldr	r0, [r7, #20]
 195 0034 FFF7FEFF 		bl	pvPortMalloc
 196 0038 0246     		mov	r2, r0
 197 003a BB69     		ldr	r3, [r7, #24]
 198 003c 1A60     		str	r2, [r3]
 329:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			if( pxNewQueue->pcHead != NULL )
 199              		.loc 1 329 0
 200 003e BB69     		ldr	r3, [r7, #24]
 201 0040 1B68     		ldr	r3, [r3]
 202 0042 002B     		cmp	r3, #0
 203 0044 10D0     		beq	.L9
 330:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
 331:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				/* Initialise the queue members as described above where the
 332:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				queue type is defined. */
 333:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				pxNewQueue->uxLength = uxQueueLength;
 204              		.loc 1 333 0
 205 0046 BB69     		ldr	r3, [r7, #24]
 206 0048 FA68     		ldr	r2, [r7, #12]
 207 004a DA63     		str	r2, [r3, #60]
 334:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				pxNewQueue->uxItemSize = uxItemSize;
 208              		.loc 1 334 0
 209 004c BB69     		ldr	r3, [r7, #24]
 210 004e BA68     		ldr	r2, [r7, #8]
 211 0050 1A64     		str	r2, [r3, #64]
 335:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 212              		.loc 1 335 0
 213 0052 B869     		ldr	r0, [r7, #24]
 214 0054 0121     		movs	r1, #1
 215 0056 FFF7FEFF 		bl	xQueueGenericReset
 336:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 337:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				#if ( configUSE_TRACE_FACILITY == 1 )
 338:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
 339:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					pxNewQueue->ucQueueType = ucQueueType;
 216              		.loc 1 339 0
 217 005a BB69     		ldr	r3, [r7, #24]
 218 005c FA79     		ldrb	r2, [r7, #7]
 219 005e 83F85020 		strb	r2, [r3, #80]
 340:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
 341:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				#endif /* configUSE_TRACE_FACILITY */
 342:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 343:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				#if( configUSE_QUEUE_SETS == 1 )
 344:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
 345:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					pxNewQueue->pxQueueSetContainer = NULL;
 346:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
 347:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
 348:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 349:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				traceQUEUE_CREATE( pxNewQueue );
 350:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				xReturn = pxNewQueue;
 220              		.loc 1 350 0
 221 0062 BB69     		ldr	r3, [r7, #24]
 222 0064 FB61     		str	r3, [r7, #28]
 223 0066 02E0     		b	.L8
 224              	.L9:
 351:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
 352:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			else
 353:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
 354:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				traceQUEUE_CREATE_FAILED( ucQueueType );
 355:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				vPortFree( pxNewQueue );
 225              		.loc 1 355 0
 226 0068 B869     		ldr	r0, [r7, #24]
 227 006a FFF7FEFF 		bl	vPortFree
 228              	.L8:
 356:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
 357:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
 358:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		else
 359:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
 360:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
 361:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
 362:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
 363:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	else
 364:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
 365:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		mtCOVERAGE_TEST_MARKER();
 366:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
 367:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 368:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	configASSERT( xReturn );
 229              		.loc 1 368 0
 230 006e FB69     		ldr	r3, [r7, #28]
 231 0070 002B     		cmp	r3, #0
 232 0072 02D1     		bne	.L11
 233              		.loc 1 368 0 is_stmt 0 discriminator 1
 234 0074 FFF7FEFF 		bl	ulPortSetInterruptMask
 235              	.L12:
 236 0078 FEE7     		b	.L12
 237              	.L11:
 369:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 370:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	return xReturn;
 238              		.loc 1 370 0 is_stmt 1
 239 007a FB69     		ldr	r3, [r7, #28]
 371:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** }
 240              		.loc 1 371 0
 241 007c 1846     		mov	r0, r3
 242 007e 2037     		adds	r7, r7, #32
 243 0080 BD46     		mov	sp, r7
 244              		@ sp needed
 245 0082 80BD     		pop	{r7, pc}
 246              		.cfi_endproc
 247              	.LFE2:
 249              		.section	.text.xQueueCreateMutex,"ax",%progbits
 250              		.align	2
 251              		.global	xQueueCreateMutex
 252              		.thumb
 253              		.thumb_func
 255              	xQueueCreateMutex:
 256              	.LFB3:
 372:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 373:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 374:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #if ( configUSE_MUTEXES == 1 )
 375:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 376:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
 377:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
 257              		.loc 1 377 0
 258              		.cfi_startproc
 259              		@ args = 0, pretend = 0, frame = 16
 260              		@ frame_needed = 1, uses_anonymous_args = 0
 261 0000 80B5     		push	{r7, lr}
 262              	.LCFI6:
 263              		.cfi_def_cfa_offset 8
 264              		.cfi_offset 7, -8
 265              		.cfi_offset 14, -4
 266 0002 84B0     		sub	sp, sp, #16
 267              	.LCFI7:
 268              		.cfi_def_cfa_offset 24
 269 0004 00AF     		add	r7, sp, #0
 270              	.LCFI8:
 271              		.cfi_def_cfa_register 7
 272 0006 0346     		mov	r3, r0
 273 0008 FB71     		strb	r3, [r7, #7]
 378:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	Queue_t *pxNewQueue;
 379:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 380:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		/* Prevent compiler warnings about unused parameters if
 381:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		configUSE_TRACE_FACILITY does not equal 1. */
 382:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		( void ) ucQueueType;
 383:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 384:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		/* Allocate the new queue structure. */
 385:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
 274              		.loc 1 385 0
 275 000a 5420     		movs	r0, #84
 276 000c FFF7FEFF 		bl	pvPortMalloc
 277 0010 F860     		str	r0, [r7, #12]
 386:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		if( pxNewQueue != NULL )
 278              		.loc 1 386 0
 279 0012 FB68     		ldr	r3, [r7, #12]
 280 0014 002B     		cmp	r3, #0
 281 0016 30D0     		beq	.L15
 387:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
 388:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			/* Information required for priority inheritance. */
 389:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			pxNewQueue->pxMutexHolder = NULL;
 282              		.loc 1 389 0
 283 0018 FB68     		ldr	r3, [r7, #12]
 284 001a 0022     		movs	r2, #0
 285 001c 5A60     		str	r2, [r3, #4]
 390:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 286              		.loc 1 390 0
 287 001e FB68     		ldr	r3, [r7, #12]
 288 0020 0022     		movs	r2, #0
 289 0022 1A60     		str	r2, [r3]
 391:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 392:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			/* Queues used as a mutex no data is actually copied into or out
 393:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			of the queue. */
 394:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			pxNewQueue->pcWriteTo = NULL;
 290              		.loc 1 394 0
 291 0024 FB68     		ldr	r3, [r7, #12]
 292 0026 0022     		movs	r2, #0
 293 0028 9A60     		str	r2, [r3, #8]
 395:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			pxNewQueue->u.pcReadFrom = NULL;
 294              		.loc 1 395 0
 295 002a FB68     		ldr	r3, [r7, #12]
 296 002c 0022     		movs	r2, #0
 297 002e DA60     		str	r2, [r3, #12]
 396:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 397:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			/* Each mutex has a length of 1 (like a binary semaphore) and
 398:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			an item size of 0 as nothing is actually copied into or out
 399:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			of the mutex. */
 400:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 298              		.loc 1 400 0
 299 0030 FB68     		ldr	r3, [r7, #12]
 300 0032 0022     		movs	r2, #0
 301 0034 9A63     		str	r2, [r3, #56]
 401:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
 302              		.loc 1 401 0
 303 0036 FB68     		ldr	r3, [r7, #12]
 304 0038 0122     		movs	r2, #1
 305 003a DA63     		str	r2, [r3, #60]
 402:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
 306              		.loc 1 402 0
 307 003c FB68     		ldr	r3, [r7, #12]
 308 003e 0022     		movs	r2, #0
 309 0040 1A64     		str	r2, [r3, #64]
 403:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			pxNewQueue->xRxLock = queueUNLOCKED;
 310              		.loc 1 403 0
 311 0042 FB68     		ldr	r3, [r7, #12]
 312 0044 4FF0FF32 		mov	r2, #-1
 313 0048 5A64     		str	r2, [r3, #68]
 404:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			pxNewQueue->xTxLock = queueUNLOCKED;
 314              		.loc 1 404 0
 315 004a FB68     		ldr	r3, [r7, #12]
 316 004c 4FF0FF32 		mov	r2, #-1
 317 0050 9A64     		str	r2, [r3, #72]
 405:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 406:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 407:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
 408:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				pxNewQueue->ucQueueType = ucQueueType;
 318              		.loc 1 408 0
 319 0052 FB68     		ldr	r3, [r7, #12]
 320 0054 FA79     		ldrb	r2, [r7, #7]
 321 0056 83F85020 		strb	r2, [r3, #80]
 409:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
 410:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			#endif
 411:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 412:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
 413:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
 414:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				pxNewQueue->pxQueueSetContainer = NULL;
 415:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
 416:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			#endif
 417:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 418:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			/* Ensure the event queues start with the correct state. */
 419:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 322              		.loc 1 419 0
 323 005a FB68     		ldr	r3, [r7, #12]
 324 005c 1033     		adds	r3, r3, #16
 325 005e 1846     		mov	r0, r3
 326 0060 FFF7FEFF 		bl	vListInitialise
 420:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 327              		.loc 1 420 0
 328 0064 FB68     		ldr	r3, [r7, #12]
 329 0066 2433     		adds	r3, r3, #36
 330 0068 1846     		mov	r0, r3
 331 006a FFF7FEFF 		bl	vListInitialise
 421:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 422:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 423:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 424:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			/* Start with the semaphore in the expected state. */
 425:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 332              		.loc 1 425 0
 333 006e F868     		ldr	r0, [r7, #12]
 334 0070 0021     		movs	r1, #0
 335 0072 0022     		movs	r2, #0
 336 0074 0023     		movs	r3, #0
 337 0076 FFF7FEFF 		bl	xQueueGenericSend
 338              	.L15:
 426:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
 427:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		else
 428:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
 429:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			traceCREATE_MUTEX_FAILED();
 430:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
 431:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 432:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		configASSERT( pxNewQueue );
 339              		.loc 1 432 0
 340 007a FB68     		ldr	r3, [r7, #12]
 341 007c 002B     		cmp	r3, #0
 342 007e 02D1     		bne	.L16
 343              		.loc 1 432 0 is_stmt 0 discriminator 1
 344 0080 FFF7FEFF 		bl	ulPortSetInterruptMask
 345              	.L17:
 346 0084 FEE7     		b	.L17
 347              	.L16:
 433:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		return pxNewQueue;
 348              		.loc 1 433 0 is_stmt 1
 349 0086 FB68     		ldr	r3, [r7, #12]
 434:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
 350              		.loc 1 434 0
 351 0088 1846     		mov	r0, r3
 352 008a 1037     		adds	r7, r7, #16
 353 008c BD46     		mov	sp, r7
 354              		@ sp needed
 355 008e 80BD     		pop	{r7, pc}
 356              		.cfi_endproc
 357              	.LFE3:
 359              		.section	.text.xQueueGiveMutexRecursive,"ax",%progbits
 360              		.align	2
 361              		.global	xQueueGiveMutexRecursive
 362              		.thumb
 363              		.thumb_func
 365              	xQueueGiveMutexRecursive:
 366              	.LFB4:
 435:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 436:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
 437:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 438:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 439:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 440:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 441:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	void* xQueueGetMutexHolder( QueueHandle_t xSemaphore )
 442:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
 443:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	void *pxReturn;
 444:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 445:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		/* This function is called by xSemaphoreGetMutexHolder(), and should not
 446:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		be called directly.  Note:  This is a good way of determining if the
 447:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		calling task is the mutex holder, but not a good way of determining the
 448:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		identity of the mutex holder, as the holder may change between the
 449:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		following critical section exiting and the function returning. */
 450:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 451:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
 452:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 453:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
 454:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pxMutexHolder;
 455:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
 456:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			else
 457:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
 458:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				pxReturn = NULL;
 459:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
 460:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
 461:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 462:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 463:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		return pxReturn;
 464:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 465:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 466:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #endif
 467:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 468:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 469:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 470:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 471:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
 472:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
 367              		.loc 1 472 0
 368              		.cfi_startproc
 369              		@ args = 0, pretend = 0, frame = 16
 370              		@ frame_needed = 1, uses_anonymous_args = 0
 371 0000 90B5     		push	{r4, r7, lr}
 372              	.LCFI9:
 373              		.cfi_def_cfa_offset 12
 374              		.cfi_offset 4, -12
 375              		.cfi_offset 7, -8
 376              		.cfi_offset 14, -4
 377 0002 85B0     		sub	sp, sp, #20
 378              	.LCFI10:
 379              		.cfi_def_cfa_offset 32
 380 0004 00AF     		add	r7, sp, #0
 381              	.LCFI11:
 382              		.cfi_def_cfa_register 7
 383 0006 7860     		str	r0, [r7, #4]
 473:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
 474:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 384              		.loc 1 474 0
 385 0008 7B68     		ldr	r3, [r7, #4]
 386 000a BB60     		str	r3, [r7, #8]
 475:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 476:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		configASSERT( pxMutex );
 387              		.loc 1 476 0
 388 000c BB68     		ldr	r3, [r7, #8]
 389 000e 002B     		cmp	r3, #0
 390 0010 02D1     		bne	.L20
 391              		.loc 1 476 0 is_stmt 0 discriminator 1
 392 0012 FFF7FEFF 		bl	ulPortSetInterruptMask
 393              	.L21:
 394 0016 FEE7     		b	.L21
 395              	.L20:
 477:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 478:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		/* If this is the task that holds the mutex then pxMutexHolder will not
 479:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 480:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 481:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		this is the only condition we are interested in it does not matter if
 482:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 483:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 484:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redunda
 396              		.loc 1 484 0 is_stmt 1
 397 0018 BB68     		ldr	r3, [r7, #8]
 398 001a 5C68     		ldr	r4, [r3, #4]
 399 001c FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 400 0020 0346     		mov	r3, r0
 401 0022 9C42     		cmp	r4, r3
 402 0024 11D1     		bne	.L22
 485:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
 486:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 487:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 488:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
 489:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 490:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 491:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 492:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			uxRecursiveCallCount member. */
 493:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			( pxMutex->u.uxRecursiveCallCount )--;
 403              		.loc 1 493 0
 404 0026 BB68     		ldr	r3, [r7, #8]
 405 0028 DB68     		ldr	r3, [r3, #12]
 406 002a 5A1E     		subs	r2, r3, #1
 407 002c BB68     		ldr	r3, [r7, #8]
 408 002e DA60     		str	r2, [r3, #12]
 494:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 495:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			/* Have we unwound the call count? */
 496:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 409              		.loc 1 496 0
 410 0030 BB68     		ldr	r3, [r7, #8]
 411 0032 DB68     		ldr	r3, [r3, #12]
 412 0034 002B     		cmp	r3, #0
 413 0036 05D1     		bne	.L23
 497:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
 498:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 499:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				task that might be waiting to access the mutex. */
 500:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 414              		.loc 1 500 0
 415 0038 B868     		ldr	r0, [r7, #8]
 416 003a 0021     		movs	r1, #0
 417 003c 0022     		movs	r2, #0
 418 003e 0023     		movs	r3, #0
 419 0040 FFF7FEFF 		bl	xQueueGenericSend
 420              	.L23:
 501:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
 502:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			else
 503:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
 504:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 505:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
 506:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 507:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 421              		.loc 1 507 0 discriminator 1
 422 0044 0123     		movs	r3, #1
 423 0046 FB60     		str	r3, [r7, #12]
 424 0048 01E0     		b	.L24
 425              	.L22:
 508:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
 509:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		else
 510:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
 511:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			/* The mutex cannot be given because the calling task is not the
 512:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			holder. */
 513:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
 426              		.loc 1 513 0
 427 004a 0023     		movs	r3, #0
 428 004c FB60     		str	r3, [r7, #12]
 429              	.L24:
 514:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 515:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 516:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
 517:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 518:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		return xReturn;
 430              		.loc 1 518 0
 431 004e FB68     		ldr	r3, [r7, #12]
 519:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
 432              		.loc 1 519 0
 433 0050 1846     		mov	r0, r3
 434 0052 1437     		adds	r7, r7, #20
 435 0054 BD46     		mov	sp, r7
 436              		@ sp needed
 437 0056 90BD     		pop	{r4, r7, pc}
 438              		.cfi_endproc
 439              	.LFE4:
 441              		.section	.text.xQueueTakeMutexRecursive,"ax",%progbits
 442              		.align	2
 443              		.global	xQueueTakeMutexRecursive
 444              		.thumb
 445              		.thumb_func
 447              	xQueueTakeMutexRecursive:
 448              	.LFB5:
 520:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 521:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 522:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 523:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 524:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 525:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 526:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
 527:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
 449              		.loc 1 527 0
 450              		.cfi_startproc
 451              		@ args = 0, pretend = 0, frame = 16
 452              		@ frame_needed = 1, uses_anonymous_args = 0
 453 0000 90B5     		push	{r4, r7, lr}
 454              	.LCFI12:
 455              		.cfi_def_cfa_offset 12
 456              		.cfi_offset 4, -12
 457              		.cfi_offset 7, -8
 458              		.cfi_offset 14, -4
 459 0002 85B0     		sub	sp, sp, #20
 460              	.LCFI13:
 461              		.cfi_def_cfa_offset 32
 462 0004 00AF     		add	r7, sp, #0
 463              	.LCFI14:
 464              		.cfi_def_cfa_register 7
 465 0006 7860     		str	r0, [r7, #4]
 466 0008 3960     		str	r1, [r7]
 528:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
 529:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 467              		.loc 1 529 0
 468 000a 7B68     		ldr	r3, [r7, #4]
 469 000c BB60     		str	r3, [r7, #8]
 530:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 531:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		configASSERT( pxMutex );
 470              		.loc 1 531 0
 471 000e BB68     		ldr	r3, [r7, #8]
 472 0010 002B     		cmp	r3, #0
 473 0012 02D1     		bne	.L27
 474              		.loc 1 531 0 is_stmt 0 discriminator 1
 475 0014 FFF7FEFF 		bl	ulPortSetInterruptMask
 476              	.L28:
 477 0018 FEE7     		b	.L28
 478              	.L27:
 532:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 533:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 534:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		xQueueGiveMutexRecursive(). */
 535:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 536:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 537:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 538:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not r
 479              		.loc 1 538 0 is_stmt 1
 480 001a BB68     		ldr	r3, [r7, #8]
 481 001c 5C68     		ldr	r4, [r3, #4]
 482 001e FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 483 0022 0346     		mov	r3, r0
 484 0024 9C42     		cmp	r4, r3
 485 0026 07D1     		bne	.L29
 539:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
 540:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			( pxMutex->u.uxRecursiveCallCount )++;
 486              		.loc 1 540 0
 487 0028 BB68     		ldr	r3, [r7, #8]
 488 002a DB68     		ldr	r3, [r3, #12]
 489 002c 5A1C     		adds	r2, r3, #1
 490 002e BB68     		ldr	r3, [r7, #8]
 491 0030 DA60     		str	r2, [r3, #12]
 541:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 492              		.loc 1 541 0
 493 0032 0123     		movs	r3, #1
 494 0034 FB60     		str	r3, [r7, #12]
 495 0036 0EE0     		b	.L30
 496              	.L29:
 542:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
 543:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		else
 544:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
 545:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			xReturn = xQueueGenericReceive( pxMutex, NULL, xTicksToWait, pdFALSE );
 497              		.loc 1 545 0
 498 0038 B868     		ldr	r0, [r7, #8]
 499 003a 0021     		movs	r1, #0
 500 003c 3A68     		ldr	r2, [r7]
 501 003e 0023     		movs	r3, #0
 502 0040 FFF7FEFF 		bl	xQueueGenericReceive
 503 0044 F860     		str	r0, [r7, #12]
 546:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 547:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			/* pdPASS will only be returned if the mutex was successfully
 548:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			obtained.  The calling task may have entered the Blocked state
 549:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			before reaching here. */
 550:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			if( xReturn == pdPASS )
 504              		.loc 1 550 0
 505 0046 FB68     		ldr	r3, [r7, #12]
 506 0048 012B     		cmp	r3, #1
 507 004a 04D1     		bne	.L30
 551:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
 552:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				( pxMutex->u.uxRecursiveCallCount )++;
 508              		.loc 1 552 0
 509 004c BB68     		ldr	r3, [r7, #8]
 510 004e DB68     		ldr	r3, [r3, #12]
 511 0050 5A1C     		adds	r2, r3, #1
 512 0052 BB68     		ldr	r3, [r7, #8]
 513 0054 DA60     		str	r2, [r3, #12]
 514              	.L30:
 553:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
 554:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			else
 555:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
 556:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 557:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
 558:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
 559:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 560:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		return xReturn;
 515              		.loc 1 560 0
 516 0056 FB68     		ldr	r3, [r7, #12]
 561:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
 517              		.loc 1 561 0
 518 0058 1846     		mov	r0, r3
 519 005a 1437     		adds	r7, r7, #20
 520 005c BD46     		mov	sp, r7
 521              		@ sp needed
 522 005e 90BD     		pop	{r4, r7, pc}
 523              		.cfi_endproc
 524              	.LFE5:
 526              		.section	.text.xQueueCreateCountingSemaphore,"ax",%progbits
 527              		.align	2
 528              		.global	xQueueCreateCountingSemaphore
 529              		.thumb
 530              		.thumb_func
 532              	xQueueCreateCountingSemaphore:
 533              	.LFB6:
 562:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 563:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 564:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 565:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 566:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #if ( configUSE_COUNTING_SEMAPHORES == 1 )
 567:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 568:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxIni
 569:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
 534              		.loc 1 569 0
 535              		.cfi_startproc
 536              		@ args = 0, pretend = 0, frame = 16
 537              		@ frame_needed = 1, uses_anonymous_args = 0
 538 0000 80B5     		push	{r7, lr}
 539              	.LCFI15:
 540              		.cfi_def_cfa_offset 8
 541              		.cfi_offset 7, -8
 542              		.cfi_offset 14, -4
 543 0002 84B0     		sub	sp, sp, #16
 544              	.LCFI16:
 545              		.cfi_def_cfa_offset 24
 546 0004 00AF     		add	r7, sp, #0
 547              	.LCFI17:
 548              		.cfi_def_cfa_register 7
 549 0006 7860     		str	r0, [r7, #4]
 550 0008 3960     		str	r1, [r7]
 570:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	QueueHandle_t xHandle;
 571:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 572:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		configASSERT( uxMaxCount != 0 );
 551              		.loc 1 572 0
 552 000a 7B68     		ldr	r3, [r7, #4]
 553 000c 002B     		cmp	r3, #0
 554 000e 02D1     		bne	.L33
 555              		.loc 1 572 0 is_stmt 0 discriminator 1
 556 0010 FFF7FEFF 		bl	ulPortSetInterruptMask
 557              	.L34:
 558 0014 FEE7     		b	.L34
 559              	.L33:
 573:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 560              		.loc 1 573 0 is_stmt 1
 561 0016 3A68     		ldr	r2, [r7]
 562 0018 7B68     		ldr	r3, [r7, #4]
 563 001a 9A42     		cmp	r2, r3
 564 001c 02D9     		bls	.L35
 565              		.loc 1 573 0 is_stmt 0 discriminator 1
 566 001e FFF7FEFF 		bl	ulPortSetInterruptMask
 567              	.L36:
 568 0022 FEE7     		b	.L36
 569              	.L35:
 574:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 575:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUN
 570              		.loc 1 575 0 is_stmt 1
 571 0024 7868     		ldr	r0, [r7, #4]
 572 0026 0021     		movs	r1, #0
 573 0028 0222     		movs	r2, #2
 574 002a FFF7FEFF 		bl	xQueueGenericCreate
 575 002e F860     		str	r0, [r7, #12]
 576:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 577:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		if( xHandle != NULL )
 576              		.loc 1 577 0
 577 0030 FB68     		ldr	r3, [r7, #12]
 578 0032 002B     		cmp	r3, #0
 579 0034 02D0     		beq	.L37
 578:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
 579:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 580              		.loc 1 579 0
 581 0036 FB68     		ldr	r3, [r7, #12]
 582 0038 3A68     		ldr	r2, [r7]
 583 003a 9A63     		str	r2, [r3, #56]
 584              	.L37:
 580:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 581:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 582:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
 583:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		else
 584:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
 585:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 586:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
 587:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 588:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		configASSERT( xHandle );
 585              		.loc 1 588 0
 586 003c FB68     		ldr	r3, [r7, #12]
 587 003e 002B     		cmp	r3, #0
 588 0040 02D1     		bne	.L38
 589              		.loc 1 588 0 is_stmt 0 discriminator 1
 590 0042 FFF7FEFF 		bl	ulPortSetInterruptMask
 591              	.L39:
 592 0046 FEE7     		b	.L39
 593              	.L38:
 589:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		return xHandle;
 594              		.loc 1 589 0 is_stmt 1
 595 0048 FB68     		ldr	r3, [r7, #12]
 590:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
 596              		.loc 1 590 0
 597 004a 1846     		mov	r0, r3
 598 004c 1037     		adds	r7, r7, #16
 599 004e BD46     		mov	sp, r7
 600              		@ sp needed
 601 0050 80BD     		pop	{r7, pc}
 602              		.cfi_endproc
 603              	.LFE6:
 605 0052 00BF     		.section	.text.xQueueGenericSend,"ax",%progbits
 606              		.align	2
 607              		.global	xQueueGenericSend
 608              		.thumb
 609              		.thumb_func
 611              	xQueueGenericSend:
 612              	.LFB7:
 591:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 592:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #endif /* configUSE_COUNTING_SEMAPHORES */
 593:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 594:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 595:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xT
 596:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** {
 613              		.loc 1 596 0
 614              		.cfi_startproc
 615              		@ args = 0, pretend = 0, frame = 40
 616              		@ frame_needed = 1, uses_anonymous_args = 0
 617 0000 80B5     		push	{r7, lr}
 618              	.LCFI18:
 619              		.cfi_def_cfa_offset 8
 620              		.cfi_offset 7, -8
 621              		.cfi_offset 14, -4
 622 0002 8AB0     		sub	sp, sp, #40
 623              	.LCFI19:
 624              		.cfi_def_cfa_offset 48
 625 0004 00AF     		add	r7, sp, #0
 626              	.LCFI20:
 627              		.cfi_def_cfa_register 7
 628 0006 F860     		str	r0, [r7, #12]
 629 0008 B960     		str	r1, [r7, #8]
 630 000a 7A60     		str	r2, [r7, #4]
 631 000c 3B60     		str	r3, [r7]
 597:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 632              		.loc 1 597 0
 633 000e 0023     		movs	r3, #0
 634 0010 7B62     		str	r3, [r7, #36]
 598:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
 599:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 635              		.loc 1 599 0
 636 0012 FB68     		ldr	r3, [r7, #12]
 637 0014 3B62     		str	r3, [r7, #32]
 600:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 601:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 638              		.loc 1 601 0
 639 0016 3B6A     		ldr	r3, [r7, #32]
 640 0018 002B     		cmp	r3, #0
 641 001a 02D1     		bne	.L42
 642              		.loc 1 601 0 is_stmt 0 discriminator 1
 643 001c FFF7FEFF 		bl	ulPortSetInterruptMask
 644              	.L43:
 645 0020 FEE7     		b	.L43
 646              	.L42:
 602:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 647              		.loc 1 602 0 is_stmt 1
 648 0022 BB68     		ldr	r3, [r7, #8]
 649 0024 002B     		cmp	r3, #0
 650 0026 03D1     		bne	.L44
 651              		.loc 1 602 0 is_stmt 0 discriminator 2
 652 0028 3B6A     		ldr	r3, [r7, #32]
 653 002a 1B6C     		ldr	r3, [r3, #64]
 654 002c 002B     		cmp	r3, #0
 655 002e 01D1     		bne	.L45
 656              	.L44:
 657              		.loc 1 602 0 discriminator 1
 658 0030 0123     		movs	r3, #1
 659 0032 00E0     		b	.L46
 660              	.L45:
 661              		.loc 1 602 0 discriminator 3
 662 0034 0023     		movs	r3, #0
 663              	.L46:
 664              		.loc 1 602 0 discriminator 4
 665 0036 002B     		cmp	r3, #0
 666 0038 02D1     		bne	.L47
 667              		.loc 1 602 0 discriminator 1
 668 003a FFF7FEFF 		bl	ulPortSetInterruptMask
 669              	.L48:
 670 003e FEE7     		b	.L48
 671              	.L47:
 603:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 672              		.loc 1 603 0 is_stmt 1
 673 0040 3B68     		ldr	r3, [r7]
 674 0042 022B     		cmp	r3, #2
 675 0044 03D1     		bne	.L49
 676              		.loc 1 603 0 is_stmt 0 discriminator 2
 677 0046 3B6A     		ldr	r3, [r7, #32]
 678 0048 DB6B     		ldr	r3, [r3, #60]
 679 004a 012B     		cmp	r3, #1
 680 004c 01D1     		bne	.L50
 681              	.L49:
 682              		.loc 1 603 0 discriminator 1
 683 004e 0123     		movs	r3, #1
 684 0050 00E0     		b	.L51
 685              	.L50:
 686              		.loc 1 603 0 discriminator 3
 687 0052 0023     		movs	r3, #0
 688              	.L51:
 689              		.loc 1 603 0 discriminator 4
 690 0054 002B     		cmp	r3, #0
 691 0056 02D1     		bne	.L52
 692              		.loc 1 603 0 discriminator 1
 693 0058 FFF7FEFF 		bl	ulPortSetInterruptMask
 694              	.L53:
 695 005c FEE7     		b	.L53
 696              	.L52:
 604:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 605:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
 606:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
 697              		.loc 1 606 0 is_stmt 1
 698 005e FFF7FEFF 		bl	xTaskGetSchedulerState
 699 0062 0346     		mov	r3, r0
 700 0064 002B     		cmp	r3, #0
 701 0066 02D1     		bne	.L54
 702              		.loc 1 606 0 is_stmt 0 discriminator 2
 703 0068 7B68     		ldr	r3, [r7, #4]
 704 006a 002B     		cmp	r3, #0
 705 006c 01D1     		bne	.L55
 706              	.L54:
 707              		.loc 1 606 0 discriminator 1
 708 006e 0123     		movs	r3, #1
 709 0070 00E0     		b	.L56
 710              	.L55:
 711              		.loc 1 606 0 discriminator 3
 712 0072 0023     		movs	r3, #0
 713              	.L56:
 714              		.loc 1 606 0 discriminator 4
 715 0074 002B     		cmp	r3, #0
 716 0076 02D1     		bne	.L57
 717              		.loc 1 606 0 discriminator 1
 718 0078 FFF7FEFF 		bl	ulPortSetInterruptMask
 719              	.L58:
 720 007c FEE7     		b	.L58
 721              	.L57:
 607:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
 608:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	#endif
 609:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 610:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 611:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 612:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	statements within the function itself.  This is done in the interest
 613:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	of execution time efficiency. */
 614:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	for( ;; )
 615:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
 616:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 722              		.loc 1 616 0 is_stmt 1
 723 007e FFF7FEFF 		bl	vPortEnterCritical
 617:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
 618:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			/* Is there room on the queue now?  The running task must be
 619:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			the highest priority task wanting to access the queue.  If
 620:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			the head item in the queue is to be overwritten then it does
 621:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			not matter if the queue is full. */
 622:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 724              		.loc 1 622 0
 725 0082 3B6A     		ldr	r3, [r7, #32]
 726 0084 9A6B     		ldr	r2, [r3, #56]
 727 0086 3B6A     		ldr	r3, [r7, #32]
 728 0088 DB6B     		ldr	r3, [r3, #60]
 729 008a 9A42     		cmp	r2, r3
 730 008c 02D3     		bcc	.L59
 731              		.loc 1 622 0 is_stmt 0 discriminator 1
 732 008e 3B68     		ldr	r3, [r7]
 733 0090 022B     		cmp	r3, #2
 734 0092 1DD1     		bne	.L60
 735              	.L59:
 623:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
 624:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				traceQUEUE_SEND( pxQueue );
 625:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 736              		.loc 1 625 0 is_stmt 1
 737 0094 386A     		ldr	r0, [r7, #32]
 738 0096 B968     		ldr	r1, [r7, #8]
 739 0098 3A68     		ldr	r2, [r7]
 740 009a FFF7FEFF 		bl	prvCopyDataToQueue
 741 009e F861     		str	r0, [r7, #28]
 626:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 627:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 628:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
 629:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 630:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
 631:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
 632:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						{
 633:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							/* The queue is a member of a queue set, and posting
 634:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							to the queue set caused a higher priority task to
 635:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							unblock. A context switch is required. */
 636:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 637:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						}
 638:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						else
 639:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						{
 640:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 641:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						}
 642:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
 643:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					else
 644:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
 645:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						/* If there was a task waiting for data to arrive on the
 646:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						queue then unblock it now. */
 647:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 648:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						{
 649:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 650:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							{
 651:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 								/* The unblocked task has a priority higher than
 652:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 								our own so yield immediately.  Yes it is ok to
 653:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 								do this from within the critical section - the
 654:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 								kernel takes care of that. */
 655:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 								queueYIELD_IF_USING_PREEMPTION();
 656:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							}
 657:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							else
 658:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							{
 659:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 660:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							}
 661:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						}
 662:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						else if( xYieldRequired != pdFALSE )
 663:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						{
 664:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							/* This path is a special case that will only get
 665:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							executed if the task was holding multiple mutexes
 666:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							and the mutexes were given back in an order that is
 667:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							different to that in which they were taken. */
 668:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 669:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						}
 670:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						else
 671:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						{
 672:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 673:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						}
 674:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
 675:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
 676:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
 677:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
 678:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					/* If there was a task waiting for data to arrive on the
 679:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					queue then unblock it now. */
 680:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 742              		.loc 1 680 0
 743 00a0 3B6A     		ldr	r3, [r7, #32]
 744 00a2 5B6A     		ldr	r3, [r3, #36]
 745 00a4 002B     		cmp	r3, #0
 746 00a6 0AD0     		beq	.L61
 681:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
 682:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 747              		.loc 1 682 0
 748 00a8 3B6A     		ldr	r3, [r7, #32]
 749 00aa 2433     		adds	r3, r3, #36
 750 00ac 1846     		mov	r0, r3
 751 00ae FFF7FEFF 		bl	xTaskRemoveFromEventList
 752 00b2 0346     		mov	r3, r0
 753 00b4 012B     		cmp	r3, #1
 754 00b6 07D1     		bne	.L62
 683:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						{
 684:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							/* The unblocked task has a priority higher than
 685:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							our own so yield immediately.  Yes it is ok to do
 686:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							this from within the critical section - the kernel
 687:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							takes care of that. */
 688:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 755              		.loc 1 688 0
 756 00b8 FFF7FEFF 		bl	vPortYield
 757 00bc 04E0     		b	.L62
 758              	.L61:
 689:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						}
 690:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						else
 691:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						{
 692:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 693:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						}
 694:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
 695:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					else if( xYieldRequired != pdFALSE )
 759              		.loc 1 695 0
 760 00be FB69     		ldr	r3, [r7, #28]
 761 00c0 002B     		cmp	r3, #0
 762 00c2 01D0     		beq	.L62
 696:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
 697:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						/* This path is a special case that will only get
 698:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						executed if the task was holding multiple mutexes and
 699:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						the mutexes were given back in an order that is
 700:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						different to that in which they were taken. */
 701:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 763              		.loc 1 701 0
 764 00c4 FFF7FEFF 		bl	vPortYield
 765              	.L62:
 702:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
 703:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					else
 704:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
 705:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
 706:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
 707:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
 708:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
 709:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 710:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
 766              		.loc 1 710 0
 767 00c8 FFF7FEFF 		bl	vPortExitCritical
 711:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				return pdPASS;
 768              		.loc 1 711 0
 769 00cc 0123     		movs	r3, #1
 770 00ce 59E0     		b	.L73
 771              	.L60:
 712:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
 713:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			else
 714:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
 715:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 772              		.loc 1 715 0
 773 00d0 7B68     		ldr	r3, [r7, #4]
 774 00d2 002B     		cmp	r3, #0
 775 00d4 03D1     		bne	.L64
 716:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
 717:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					/* The queue was full and no block time is specified (or
 718:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					the block time has expired) so leave now. */
 719:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 776              		.loc 1 719 0
 777 00d6 FFF7FEFF 		bl	vPortExitCritical
 720:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 721:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					/* Return to the original privilege level before exiting
 722:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					the function. */
 723:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 724:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 778              		.loc 1 724 0
 779 00da 0023     		movs	r3, #0
 780 00dc 52E0     		b	.L73
 781              	.L64:
 725:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
 726:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 782              		.loc 1 726 0
 783 00de 7B6A     		ldr	r3, [r7, #36]
 784 00e0 002B     		cmp	r3, #0
 785 00e2 06D1     		bne	.L65
 727:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
 728:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					/* The queue was full and a block time was specified so
 729:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					configure the timeout structure. */
 730:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 786              		.loc 1 730 0
 787 00e4 07F11403 		add	r3, r7, #20
 788 00e8 1846     		mov	r0, r3
 789 00ea FFF7FEFF 		bl	vTaskSetTimeOutState
 731:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 790              		.loc 1 731 0
 791 00ee 0123     		movs	r3, #1
 792 00f0 7B62     		str	r3, [r7, #36]
 793              	.L65:
 732:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
 733:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				else
 734:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
 735:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					/* Entry time was already set. */
 736:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 737:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
 738:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
 739:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
 740:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 794              		.loc 1 740 0
 795 00f2 FFF7FEFF 		bl	vPortExitCritical
 741:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 742:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 743:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
 744:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 745:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
 796              		.loc 1 745 0
 797 00f6 FFF7FEFF 		bl	vTaskSuspendAll
 746:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 798              		.loc 1 746 0
 799 00fa FFF7FEFF 		bl	vPortEnterCritical
 800 00fe 3B6A     		ldr	r3, [r7, #32]
 801 0100 5B6C     		ldr	r3, [r3, #68]
 802 0102 B3F1FF3F 		cmp	r3, #-1
 803 0106 02D1     		bne	.L66
 804              		.loc 1 746 0 is_stmt 0 discriminator 1
 805 0108 3B6A     		ldr	r3, [r7, #32]
 806 010a 0022     		movs	r2, #0
 807 010c 5A64     		str	r2, [r3, #68]
 808              	.L66:
 809              		.loc 1 746 0 discriminator 2
 810 010e 3B6A     		ldr	r3, [r7, #32]
 811 0110 9B6C     		ldr	r3, [r3, #72]
 812 0112 B3F1FF3F 		cmp	r3, #-1
 813 0116 02D1     		bne	.L67
 814              		.loc 1 746 0 discriminator 1
 815 0118 3B6A     		ldr	r3, [r7, #32]
 816 011a 0022     		movs	r2, #0
 817 011c 9A64     		str	r2, [r3, #72]
 818              	.L67:
 819              		.loc 1 746 0 discriminator 2
 820 011e FFF7FEFF 		bl	vPortExitCritical
 747:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 748:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 749:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 821              		.loc 1 749 0 is_stmt 1 discriminator 2
 822 0122 07F11402 		add	r2, r7, #20
 823 0126 3B1D     		adds	r3, r7, #4
 824 0128 1046     		mov	r0, r2
 825 012a 1946     		mov	r1, r3
 826 012c FFF7FEFF 		bl	xTaskCheckForTimeOut
 827 0130 0346     		mov	r3, r0
 828 0132 002B     		cmp	r3, #0
 829 0134 1ED1     		bne	.L68
 750:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
 751:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 830              		.loc 1 751 0
 831 0136 386A     		ldr	r0, [r7, #32]
 832 0138 FFF7FEFF 		bl	prvIsQueueFull
 833 013c 0346     		mov	r3, r0
 834 013e 002B     		cmp	r3, #0
 835 0140 12D0     		beq	.L69
 752:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
 753:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 754:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 836              		.loc 1 754 0
 837 0142 3B6A     		ldr	r3, [r7, #32]
 838 0144 03F11002 		add	r2, r3, #16
 839 0148 7B68     		ldr	r3, [r7, #4]
 840 014a 1046     		mov	r0, r2
 841 014c 1946     		mov	r1, r3
 842 014e FFF7FEFF 		bl	vTaskPlaceOnEventList
 755:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 756:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				/* Unlocking the queue means queue events can effect the
 757:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				event list.  It is possible	that interrupts occurring now
 758:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				remove this task from the event	list again - but as the
 759:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				scheduler is suspended the task will go onto the pending
 760:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				ready last instead of the actual ready list. */
 761:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 843              		.loc 1 761 0
 844 0152 386A     		ldr	r0, [r7, #32]
 845 0154 FFF7FEFF 		bl	prvUnlockQueue
 762:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 763:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 764:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				ready list into the ready list - so it is feasible that this
 765:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				task is already in a ready list before it yields - in which
 766:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				case the yield will not cause a context switch unless there
 767:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				is also a higher priority task in the pending ready list. */
 768:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 846              		.loc 1 768 0
 847 0158 FFF7FEFF 		bl	xTaskResumeAll
 848 015c 0346     		mov	r3, r0
 849 015e 002B     		cmp	r3, #0
 850 0160 0FD1     		bne	.L72
 769:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
 770:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
 851              		.loc 1 770 0
 852 0162 FFF7FEFF 		bl	vPortYield
 853 0166 0CE0     		b	.L72
 854              	.L69:
 771:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
 772:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
 773:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			else
 774:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
 775:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				/* Try again. */
 776:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 855              		.loc 1 776 0
 856 0168 386A     		ldr	r0, [r7, #32]
 857 016a FFF7FEFF 		bl	prvUnlockQueue
 777:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 858              		.loc 1 777 0
 859 016e FFF7FEFF 		bl	xTaskResumeAll
 778:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
 779:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
 780:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		else
 781:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
 782:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			/* The timeout has expired. */
 783:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 784:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 785:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 786:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			/* Return to the original privilege level before exiting the
 787:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			function. */
 788:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 789:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			return errQUEUE_FULL;
 790:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
 791:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
 860              		.loc 1 791 0
 861 0172 84E7     		b	.L57
 862              	.L68:
 783:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 863              		.loc 1 783 0
 864 0174 386A     		ldr	r0, [r7, #32]
 865 0176 FFF7FEFF 		bl	prvUnlockQueue
 784:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 866              		.loc 1 784 0
 867 017a FFF7FEFF 		bl	xTaskResumeAll
 789:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
 868              		.loc 1 789 0
 869 017e 0023     		movs	r3, #0
 870 0180 00E0     		b	.L73
 871              	.L72:
 872              		.loc 1 791 0
 873 0182 7CE7     		b	.L57
 874              	.L73:
 792:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** }
 875              		.loc 1 792 0
 876 0184 1846     		mov	r0, r3
 877 0186 2837     		adds	r7, r7, #40
 878 0188 BD46     		mov	sp, r7
 879              		@ sp needed
 880 018a 80BD     		pop	{r7, pc}
 881              		.cfi_endproc
 882              	.LFE7:
 884              		.section	.text.xQueueGenericSendFromISR,"ax",%progbits
 885              		.align	2
 886              		.global	xQueueGenericSendFromISR
 887              		.thumb
 888              		.thumb_func
 890              	xQueueGenericSendFromISR:
 891              	.LFB8:
 793:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 794:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 795:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #if ( configUSE_ALTERNATIVE_API == 1 )
 796:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 797:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	BaseType_t xQueueAltGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_
 798:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
 799:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	BaseType_t xEntryTimeSet = pdFALSE;
 800:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	TimeOut_t xTimeOut;
 801:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 802:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 803:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		configASSERT( pxQueue );
 804:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 805:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 806:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		for( ;; )
 807:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
 808:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			taskENTER_CRITICAL();
 809:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
 810:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				/* Is there room on the queue now?  To be running we must be
 811:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				the highest priority task wanting to access the queue. */
 812:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 813:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
 814:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					traceQUEUE_SEND( pxQueue );
 815:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 816:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 817:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					/* If there was a task waiting for data to arrive on the
 818:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					queue then unblock it now. */
 819:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 820:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
 821:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 822:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						{
 823:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							/* The unblocked task has a priority higher than
 824:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							our own so yield immediately. */
 825:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							portYIELD_WITHIN_API();
 826:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						}
 827:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						else
 828:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						{
 829:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 830:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						}
 831:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
 832:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					else
 833:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
 834:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
 835:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
 836:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 837:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 838:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					return pdPASS;
 839:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
 840:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				else
 841:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
 842:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					if( xTicksToWait == ( TickType_t ) 0 )
 843:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
 844:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						taskEXIT_CRITICAL();
 845:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						return errQUEUE_FULL;
 846:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
 847:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 848:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
 849:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 850:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						xEntryTimeSet = pdTRUE;
 851:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
 852:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
 853:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
 854:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			taskEXIT_CRITICAL();
 855:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 856:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			taskENTER_CRITICAL();
 857:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
 858:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 859:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
 860:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					if( prvIsQueueFull( pxQueue ) != pdFALSE )
 861:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
 862:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 863:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 864:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						portYIELD_WITHIN_API();
 865:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
 866:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					else
 867:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
 868:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
 869:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
 870:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
 871:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				else
 872:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
 873:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 874:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 875:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 876:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
 877:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
 878:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			taskEXIT_CRITICAL();
 879:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
 880:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
 881:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 882:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 883:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 884:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 885:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #if ( configUSE_ALTERNATIVE_API == 1 )
 886:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 887:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	BaseType_t xQueueAltGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicks
 888:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
 889:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	BaseType_t xEntryTimeSet = pdFALSE;
 890:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	TimeOut_t xTimeOut;
 891:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	int8_t *pcOriginalReadPosition;
 892:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 893:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 894:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		configASSERT( pxQueue );
 895:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 896:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 897:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		for( ;; )
 898:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
 899:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			taskENTER_CRITICAL();
 900:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
 901:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 902:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
 903:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					/* Remember our read position in case we are just peeking. */
 904:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 905:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 906:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					prvCopyDataFromQueue( pxQueue, pvBuffer );
 907:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 908:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					if( xJustPeeking == pdFALSE )
 909:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
 910:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						traceQUEUE_RECEIVE( pxQueue );
 911:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 912:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						/* Data is actually being removed (not just peeked). */
 913:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						--( pxQueue->uxMessagesWaiting );
 914:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 915:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 916:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						{
 917:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 918:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							{
 919:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 								/* Record the information required to implement
 920:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 								priority inheritance should it become necessary. */
 921:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 								pxQueue->pxMutexHolder = ( int8_t * ) xTaskGetCurrentTaskHandle();
 922:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							}
 923:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							else
 924:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							{
 925:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 926:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							}
 927:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						}
 928:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						#endif
 929:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 930:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 931:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						{
 932:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 933:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							{
 934:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 								portYIELD_WITHIN_API();
 935:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							}
 936:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							else
 937:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							{
 938:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 939:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							}
 940:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						}
 941:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
 942:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					else
 943:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
 944:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						traceQUEUE_PEEK( pxQueue );
 945:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 946:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						/* We are not removing the data, so reset our read
 947:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						pointer. */
 948:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 949:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 950:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						/* The data is being left in the queue, so see if there are
 951:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						any other tasks waiting for the data. */
 952:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 953:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						{
 954:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							/* Tasks that are removed from the event list will get added to
 955:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							the pending ready list as the scheduler is still suspended. */
 956:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 957:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							{
 958:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 								/* The task waiting has a higher priority than this task. */
 959:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 								portYIELD_WITHIN_API();
 960:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							}
 961:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							else
 962:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							{
 963:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 964:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							}
 965:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						}
 966:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						else
 967:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						{
 968:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 969:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						}
 970:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
 971:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 972:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 973:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					return pdPASS;
 974:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
 975:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				else
 976:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
 977:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					if( xTicksToWait == ( TickType_t ) 0 )
 978:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
 979:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						taskEXIT_CRITICAL();
 980:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						traceQUEUE_RECEIVE_FAILED( pxQueue );
 981:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						return errQUEUE_EMPTY;
 982:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
 983:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 984:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
 985:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 986:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						xEntryTimeSet = pdTRUE;
 987:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
 988:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
 989:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
 990:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			taskEXIT_CRITICAL();
 991:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
 992:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			taskENTER_CRITICAL();
 993:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
 994:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 995:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
 996:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 997:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
 998:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 999:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1000:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
1001:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						{
1002:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1003:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							{
1004:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 								taskENTER_CRITICAL();
1005:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 								{
1006:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 									vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
1007:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 								}
1008:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 								taskEXIT_CRITICAL();
1009:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							}
1010:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							else
1011:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							{
1012:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1013:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							}
1014:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						}
1015:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						#endif
1016:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1017:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1018:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						portYIELD_WITHIN_API();
1019:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
1020:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					else
1021:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
1022:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1023:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
1024:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
1025:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				else
1026:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
1027:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
1028:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1029:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
1030:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
1031:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
1032:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			taskEXIT_CRITICAL();
1033:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
1034:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
1035:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1036:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1037:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
1038:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1039:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1040:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseTy
1041:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** {
 892              		.loc 1 1041 0
 893              		.cfi_startproc
 894              		@ args = 0, pretend = 0, frame = 32
 895              		@ frame_needed = 1, uses_anonymous_args = 0
 896 0000 80B5     		push	{r7, lr}
 897              	.LCFI21:
 898              		.cfi_def_cfa_offset 8
 899              		.cfi_offset 7, -8
 900              		.cfi_offset 14, -4
 901 0002 88B0     		sub	sp, sp, #32
 902              	.LCFI22:
 903              		.cfi_def_cfa_offset 40
 904 0004 00AF     		add	r7, sp, #0
 905              	.LCFI23:
 906              		.cfi_def_cfa_register 7
 907 0006 F860     		str	r0, [r7, #12]
 908 0008 B960     		str	r1, [r7, #8]
 909 000a 7A60     		str	r2, [r7, #4]
 910 000c 3B60     		str	r3, [r7]
1042:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1043:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1044:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 911              		.loc 1 1044 0
 912 000e FB68     		ldr	r3, [r7, #12]
 913 0010 BB61     		str	r3, [r7, #24]
1045:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1046:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 914              		.loc 1 1046 0
 915 0012 BB69     		ldr	r3, [r7, #24]
 916 0014 002B     		cmp	r3, #0
 917 0016 02D1     		bne	.L75
 918              		.loc 1 1046 0 is_stmt 0 discriminator 1
 919 0018 FFF7FEFF 		bl	ulPortSetInterruptMask
 920              	.L76:
 921 001c FEE7     		b	.L76
 922              	.L75:
1047:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 923              		.loc 1 1047 0 is_stmt 1
 924 001e BB68     		ldr	r3, [r7, #8]
 925 0020 002B     		cmp	r3, #0
 926 0022 03D1     		bne	.L77
 927              		.loc 1 1047 0 is_stmt 0 discriminator 2
 928 0024 BB69     		ldr	r3, [r7, #24]
 929 0026 1B6C     		ldr	r3, [r3, #64]
 930 0028 002B     		cmp	r3, #0
 931 002a 01D1     		bne	.L78
 932              	.L77:
 933              		.loc 1 1047 0 discriminator 1
 934 002c 0123     		movs	r3, #1
 935 002e 00E0     		b	.L79
 936              	.L78:
 937              		.loc 1 1047 0 discriminator 3
 938 0030 0023     		movs	r3, #0
 939              	.L79:
 940              		.loc 1 1047 0 discriminator 4
 941 0032 002B     		cmp	r3, #0
 942 0034 02D1     		bne	.L80
 943              		.loc 1 1047 0 discriminator 1
 944 0036 FFF7FEFF 		bl	ulPortSetInterruptMask
 945              	.L81:
 946 003a FEE7     		b	.L81
 947              	.L80:
1048:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 948              		.loc 1 1048 0 is_stmt 1
 949 003c 3B68     		ldr	r3, [r7]
 950 003e 022B     		cmp	r3, #2
 951 0040 03D1     		bne	.L82
 952              		.loc 1 1048 0 is_stmt 0 discriminator 2
 953 0042 BB69     		ldr	r3, [r7, #24]
 954 0044 DB6B     		ldr	r3, [r3, #60]
 955 0046 012B     		cmp	r3, #1
 956 0048 01D1     		bne	.L83
 957              	.L82:
 958              		.loc 1 1048 0 discriminator 1
 959 004a 0123     		movs	r3, #1
 960 004c 00E0     		b	.L84
 961              	.L83:
 962              		.loc 1 1048 0 discriminator 3
 963 004e 0023     		movs	r3, #0
 964              	.L84:
 965              		.loc 1 1048 0 discriminator 4
 966 0050 002B     		cmp	r3, #0
 967 0052 02D1     		bne	.L85
 968              		.loc 1 1048 0 discriminator 1
 969 0054 FFF7FEFF 		bl	ulPortSetInterruptMask
 970              	.L86:
 971 0058 FEE7     		b	.L86
 972              	.L85:
1049:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1050:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1051:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1052:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1053:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1054:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1055:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1056:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1057:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1058:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1059:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1060:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1061:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1062:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1063:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1064:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 973              		.loc 1 1064 0 is_stmt 1
 974 005a FFF7FEFF 		bl	vPortValidateInterruptPriority
1065:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1066:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	/* Similar to xQueueGenericSend, except without blocking if there is no room
1067:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	in the queue.  Also don't directly wake a task that was blocked on a queue
1068:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	read, instead return a flag to say whether a context switch is required or
1069:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
1070:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	post). */
1071:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 975              		.loc 1 1071 0
 976 005e FFF7FEFF 		bl	ulPortSetInterruptMask
 977 0062 7861     		str	r0, [r7, #20]
1072:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
1073:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 978              		.loc 1 1073 0
 979 0064 BB69     		ldr	r3, [r7, #24]
 980 0066 9A6B     		ldr	r2, [r3, #56]
 981 0068 BB69     		ldr	r3, [r7, #24]
 982 006a DB6B     		ldr	r3, [r3, #60]
 983 006c 9A42     		cmp	r2, r3
 984 006e 02D3     		bcc	.L87
 985              		.loc 1 1073 0 is_stmt 0 discriminator 1
 986 0070 3B68     		ldr	r3, [r7]
 987 0072 022B     		cmp	r3, #2
 988 0074 2DD1     		bne	.L88
 989              	.L87:
1074:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
1075:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
1076:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1077:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
 990              		.loc 1 1077 0 is_stmt 1
 991 0076 B869     		ldr	r0, [r7, #24]
 992 0078 B968     		ldr	r1, [r7, #8]
 993 007a 3A68     		ldr	r2, [r7]
 994 007c FFF7FEFF 		bl	prvCopyDataToQueue
 995 0080 0346     		mov	r3, r0
 996 0082 002B     		cmp	r3, #0
 997 0084 05D0     		beq	.L89
1078:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
1079:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				/* This is a special case that can only be executed if a task
1080:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				holds multiple mutexes and then gives the mutexes back in an
1081:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				order that is different to that in which they were taken. */
1082:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				if( pxHigherPriorityTaskWoken != NULL )
 998              		.loc 1 1082 0
 999 0086 7B68     		ldr	r3, [r7, #4]
 1000 0088 002B     		cmp	r3, #0
 1001 008a 02D0     		beq	.L89
1083:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
1084:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					*pxHigherPriorityTaskWoken = pdTRUE;
 1002              		.loc 1 1084 0
 1003 008c 7B68     		ldr	r3, [r7, #4]
 1004 008e 0122     		movs	r2, #1
 1005 0090 1A60     		str	r2, [r3]
 1006              	.L89:
1085:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
1086:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				else
1087:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
1088:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1089:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
1090:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
1091:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1092:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
1093:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			be done when the queue is unlocked later. */
1094:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			if( pxQueue->xTxLock == queueUNLOCKED )
 1007              		.loc 1 1094 0
 1008 0092 BB69     		ldr	r3, [r7, #24]
 1009 0094 9B6C     		ldr	r3, [r3, #72]
 1010 0096 B3F1FF3F 		cmp	r3, #-1
 1011 009a 12D1     		bne	.L90
1095:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
1096:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
1097:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
1098:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
1099:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
1100:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
1101:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						{
1102:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							/* The queue is a member of a queue set, and posting
1103:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							to the queue set caused a higher priority task to
1104:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							unblock.  A context switch is required. */
1105:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1106:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							{
1107:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1108:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							}
1109:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							else
1110:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							{
1111:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1112:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							}
1113:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						}
1114:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						else
1115:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						{
1116:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1117:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						}
1118:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
1119:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					else
1120:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
1121:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1122:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						{
1123:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1124:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							{
1125:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 								/* The task waiting has a higher priority so
1126:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 								record that a context switch is required. */
1127:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1128:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 								{
1129:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1130:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 								}
1131:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 								else
1132:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 								{
1133:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1134:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 								}
1135:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							}
1136:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							else
1137:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							{
1138:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1139:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							}
1140:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						}
1141:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						else
1142:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						{
1143:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1144:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						}
1145:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
1146:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
1147:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1148:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
1149:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1012              		.loc 1 1149 0
 1013 009c BB69     		ldr	r3, [r7, #24]
 1014 009e 5B6A     		ldr	r3, [r3, #36]
 1015 00a0 002B     		cmp	r3, #0
 1016 00a2 13D0     		beq	.L91
1150:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
1151:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1017              		.loc 1 1151 0
 1018 00a4 BB69     		ldr	r3, [r7, #24]
 1019 00a6 2433     		adds	r3, r3, #36
 1020 00a8 1846     		mov	r0, r3
 1021 00aa FFF7FEFF 		bl	xTaskRemoveFromEventList
 1022 00ae 0346     		mov	r3, r0
 1023 00b0 002B     		cmp	r3, #0
 1024 00b2 0BD0     		beq	.L91
1152:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						{
1153:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1154:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							context	switch is required. */
1155:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 1025              		.loc 1 1155 0
 1026 00b4 7B68     		ldr	r3, [r7, #4]
 1027 00b6 002B     		cmp	r3, #0
 1028 00b8 08D0     		beq	.L91
1156:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							{
1157:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 1029              		.loc 1 1157 0
 1030 00ba 7B68     		ldr	r3, [r7, #4]
 1031 00bc 0122     		movs	r2, #1
 1032 00be 1A60     		str	r2, [r3]
 1033 00c0 04E0     		b	.L91
 1034              	.L90:
1158:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							}
1159:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							else
1160:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							{
1161:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1162:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							}
1163:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						}
1164:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						else
1165:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						{
1166:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1167:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						}
1168:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
1169:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					else
1170:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
1171:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1172:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
1173:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
1174:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1175:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
1176:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			else
1177:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
1178:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1179:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				knows that data was posted while it was locked. */
1180:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				++( pxQueue->xTxLock );
 1035              		.loc 1 1180 0
 1036 00c2 BB69     		ldr	r3, [r7, #24]
 1037 00c4 9B6C     		ldr	r3, [r3, #72]
 1038 00c6 5A1C     		adds	r2, r3, #1
 1039 00c8 BB69     		ldr	r3, [r7, #24]
 1040 00ca 9A64     		str	r2, [r3, #72]
 1041              	.L91:
1181:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
1182:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1183:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 1042              		.loc 1 1183 0
 1043 00cc 0123     		movs	r3, #1
 1044 00ce FB61     		str	r3, [r7, #28]
 1045 00d0 01E0     		b	.L92
 1046              	.L88:
1184:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
1185:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		else
1186:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
1187:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1188:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			xReturn = errQUEUE_FULL;
 1047              		.loc 1 1188 0
 1048 00d2 0023     		movs	r3, #0
 1049 00d4 FB61     		str	r3, [r7, #28]
 1050              	.L92:
1189:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
1190:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
1191:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1051              		.loc 1 1191 0
 1052 00d6 7869     		ldr	r0, [r7, #20]
 1053 00d8 FFF7FEFF 		bl	vPortClearInterruptMask
1192:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1193:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	return xReturn;
 1054              		.loc 1 1193 0
 1055 00dc FB69     		ldr	r3, [r7, #28]
1194:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** }
 1056              		.loc 1 1194 0
 1057 00de 1846     		mov	r0, r3
 1058 00e0 2037     		adds	r7, r7, #32
 1059 00e2 BD46     		mov	sp, r7
 1060              		@ sp needed
 1061 00e4 80BD     		pop	{r7, pc}
 1062              		.cfi_endproc
 1063              	.LFE8:
 1065 00e6 00BF     		.section	.text.xQueueGenericReceive,"ax",%progbits
 1066              		.align	2
 1067              		.global	xQueueGenericReceive
 1068              		.thumb
 1069              		.thumb_func
 1071              	xQueueGenericReceive:
 1072              	.LFB9:
1195:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1196:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1197:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWa
1198:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** {
 1073              		.loc 1 1198 0
 1074              		.cfi_startproc
 1075              		@ args = 0, pretend = 0, frame = 40
 1076              		@ frame_needed = 1, uses_anonymous_args = 0
 1077 0000 80B5     		push	{r7, lr}
 1078              	.LCFI24:
 1079              		.cfi_def_cfa_offset 8
 1080              		.cfi_offset 7, -8
 1081              		.cfi_offset 14, -4
 1082 0002 8AB0     		sub	sp, sp, #40
 1083              	.LCFI25:
 1084              		.cfi_def_cfa_offset 48
 1085 0004 00AF     		add	r7, sp, #0
 1086              	.LCFI26:
 1087              		.cfi_def_cfa_register 7
 1088 0006 F860     		str	r0, [r7, #12]
 1089 0008 B960     		str	r1, [r7, #8]
 1090 000a 7A60     		str	r2, [r7, #4]
 1091 000c 3B60     		str	r3, [r7]
1199:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1092              		.loc 1 1199 0
 1093 000e 0023     		movs	r3, #0
 1094 0010 7B62     		str	r3, [r7, #36]
1200:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
1201:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** int8_t *pcOriginalReadPosition;
1202:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1095              		.loc 1 1202 0
 1096 0012 FB68     		ldr	r3, [r7, #12]
 1097 0014 3B62     		str	r3, [r7, #32]
1203:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1204:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 1098              		.loc 1 1204 0
 1099 0016 3B6A     		ldr	r3, [r7, #32]
 1100 0018 002B     		cmp	r3, #0
 1101 001a 02D1     		bne	.L95
 1102              		.loc 1 1204 0 is_stmt 0 discriminator 1
 1103 001c FFF7FEFF 		bl	ulPortSetInterruptMask
 1104              	.L96:
 1105 0020 FEE7     		b	.L96
 1106              	.L95:
1205:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 1107              		.loc 1 1205 0 is_stmt 1
 1108 0022 BB68     		ldr	r3, [r7, #8]
 1109 0024 002B     		cmp	r3, #0
 1110 0026 03D1     		bne	.L97
 1111              		.loc 1 1205 0 is_stmt 0 discriminator 2
 1112 0028 3B6A     		ldr	r3, [r7, #32]
 1113 002a 1B6C     		ldr	r3, [r3, #64]
 1114 002c 002B     		cmp	r3, #0
 1115 002e 01D1     		bne	.L98
 1116              	.L97:
 1117              		.loc 1 1205 0 discriminator 1
 1118 0030 0123     		movs	r3, #1
 1119 0032 00E0     		b	.L99
 1120              	.L98:
 1121              		.loc 1 1205 0 discriminator 3
 1122 0034 0023     		movs	r3, #0
 1123              	.L99:
 1124              		.loc 1 1205 0 discriminator 4
 1125 0036 002B     		cmp	r3, #0
 1126 0038 02D1     		bne	.L100
 1127              		.loc 1 1205 0 discriminator 1
 1128 003a FFF7FEFF 		bl	ulPortSetInterruptMask
 1129              	.L101:
 1130 003e FEE7     		b	.L101
 1131              	.L100:
1206:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1207:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
1208:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
 1132              		.loc 1 1208 0 is_stmt 1
 1133 0040 FFF7FEFF 		bl	xTaskGetSchedulerState
 1134 0044 0346     		mov	r3, r0
 1135 0046 002B     		cmp	r3, #0
 1136 0048 02D1     		bne	.L102
 1137              		.loc 1 1208 0 is_stmt 0 discriminator 2
 1138 004a 7B68     		ldr	r3, [r7, #4]
 1139 004c 002B     		cmp	r3, #0
 1140 004e 01D1     		bne	.L103
 1141              	.L102:
 1142              		.loc 1 1208 0 discriminator 1
 1143 0050 0123     		movs	r3, #1
 1144 0052 00E0     		b	.L104
 1145              	.L103:
 1146              		.loc 1 1208 0 discriminator 3
 1147 0054 0023     		movs	r3, #0
 1148              	.L104:
 1149              		.loc 1 1208 0 discriminator 4
 1150 0056 002B     		cmp	r3, #0
 1151 0058 02D1     		bne	.L105
 1152              		.loc 1 1208 0 discriminator 1
 1153 005a FFF7FEFF 		bl	ulPortSetInterruptMask
 1154              	.L106:
 1155 005e FEE7     		b	.L106
 1156              	.L105:
1209:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
1210:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	#endif
1211:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1212:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
1213:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	statements within the function itself.  This is done in the interest
1214:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	of execution time efficiency. */
1215:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1216:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	for( ;; )
1217:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
1218:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 1157              		.loc 1 1218 0 is_stmt 1
 1158 0060 FFF7FEFF 		bl	vPortEnterCritical
1219:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
1220:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			/* Is there data in the queue now?  To be running we must be
1221:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			the highest priority task wanting to access the queue. */
1222:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 1159              		.loc 1 1222 0
 1160 0064 3B6A     		ldr	r3, [r7, #32]
 1161 0066 9B6B     		ldr	r3, [r3, #56]
 1162 0068 002B     		cmp	r3, #0
 1163 006a 3BD0     		beq	.L107
1223:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
1224:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				/* Remember the read position in case the queue is only being
1225:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				peeked. */
1226:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 1164              		.loc 1 1226 0
 1165 006c 3B6A     		ldr	r3, [r7, #32]
 1166 006e DB68     		ldr	r3, [r3, #12]
 1167 0070 FB61     		str	r3, [r7, #28]
1227:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1228:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 1168              		.loc 1 1228 0
 1169 0072 386A     		ldr	r0, [r7, #32]
 1170 0074 B968     		ldr	r1, [r7, #8]
 1171 0076 FFF7FEFF 		bl	prvCopyDataFromQueue
1229:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1230:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				if( xJustPeeking == pdFALSE )
 1172              		.loc 1 1230 0
 1173 007a 3B68     		ldr	r3, [r7]
 1174 007c 002B     		cmp	r3, #0
 1175 007e 1CD1     		bne	.L108
1231:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
1232:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE( pxQueue );
1233:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1234:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					/* Actually removing data, not just peeking. */
1235:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 1176              		.loc 1 1235 0
 1177 0080 3B6A     		ldr	r3, [r7, #32]
 1178 0082 9B6B     		ldr	r3, [r3, #56]
 1179 0084 5A1E     		subs	r2, r3, #1
 1180 0086 3B6A     		ldr	r3, [r7, #32]
 1181 0088 9A63     		str	r2, [r3, #56]
1236:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1237:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					#if ( configUSE_MUTEXES == 1 )
1238:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
1239:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1182              		.loc 1 1239 0
 1183 008a 3B6A     		ldr	r3, [r7, #32]
 1184 008c 1B68     		ldr	r3, [r3]
 1185 008e 002B     		cmp	r3, #0
 1186 0090 04D1     		bne	.L109
1240:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						{
1241:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							/* Record the information required to implement
1242:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							priority inheritance should it become necessary. */
1243:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is 
 1187              		.loc 1 1243 0
 1188 0092 FFF7FEFF 		bl	pvTaskIncrementMutexHeldCount
 1189 0096 0246     		mov	r2, r0
 1190 0098 3B6A     		ldr	r3, [r7, #32]
 1191 009a 5A60     		str	r2, [r3, #4]
 1192              	.L109:
1244:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						}
1245:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						else
1246:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						{
1247:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1248:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						}
1249:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
1250:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					#endif /* configUSE_MUTEXES */
1251:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1252:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1193              		.loc 1 1252 0
 1194 009c 3B6A     		ldr	r3, [r7, #32]
 1195 009e 1B69     		ldr	r3, [r3, #16]
 1196 00a0 002B     		cmp	r3, #0
 1197 00a2 1BD0     		beq	.L110
1253:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
1254:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 1198              		.loc 1 1254 0
 1199 00a4 3B6A     		ldr	r3, [r7, #32]
 1200 00a6 1033     		adds	r3, r3, #16
 1201 00a8 1846     		mov	r0, r3
 1202 00aa FFF7FEFF 		bl	xTaskRemoveFromEventList
 1203 00ae 0346     		mov	r3, r0
 1204 00b0 012B     		cmp	r3, #1
 1205 00b2 13D1     		bne	.L110
1255:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						{
1256:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 1206              		.loc 1 1256 0
 1207 00b4 FFF7FEFF 		bl	vPortYield
 1208 00b8 10E0     		b	.L110
 1209              	.L108:
1257:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						}
1258:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						else
1259:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						{
1260:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1261:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						}
1262:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
1263:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					else
1264:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
1265:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1266:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
1267:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
1268:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				else
1269:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
1270:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					traceQUEUE_PEEK( pxQueue );
1271:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1272:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					/* The data is not being removed, so reset the read
1273:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					pointer. */
1274:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 1210              		.loc 1 1274 0
 1211 00ba 3B6A     		ldr	r3, [r7, #32]
 1212 00bc FA69     		ldr	r2, [r7, #28]
 1213 00be DA60     		str	r2, [r3, #12]
1275:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1276:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					/* The data is being left in the queue, so see if there are
1277:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					any other tasks waiting for the data. */
1278:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1214              		.loc 1 1278 0
 1215 00c0 3B6A     		ldr	r3, [r7, #32]
 1216 00c2 5B6A     		ldr	r3, [r3, #36]
 1217 00c4 002B     		cmp	r3, #0
 1218 00c6 09D0     		beq	.L110
1279:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
1280:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						/* Tasks that are removed from the event list will get added to
1281:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						the pending ready list as the scheduler is still suspended. */
1282:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1219              		.loc 1 1282 0
 1220 00c8 3B6A     		ldr	r3, [r7, #32]
 1221 00ca 2433     		adds	r3, r3, #36
 1222 00cc 1846     		mov	r0, r3
 1223 00ce FFF7FEFF 		bl	xTaskRemoveFromEventList
 1224 00d2 0346     		mov	r3, r0
 1225 00d4 002B     		cmp	r3, #0
 1226 00d6 01D0     		beq	.L110
1283:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						{
1284:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							/* The task waiting has a higher priority than this task. */
1285:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 1227              		.loc 1 1285 0
 1228 00d8 FFF7FEFF 		bl	vPortYield
 1229              	.L110:
1286:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						}
1287:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						else
1288:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						{
1289:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1290:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						}
1291:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
1292:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					else
1293:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
1294:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1295:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
1296:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
1297:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1298:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
 1230              		.loc 1 1298 0
 1231 00dc FFF7FEFF 		bl	vPortExitCritical
1299:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				return pdPASS;
 1232              		.loc 1 1299 0
 1233 00e0 0123     		movs	r3, #1
 1234 00e2 66E0     		b	.L121
 1235              	.L107:
1300:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
1301:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			else
1302:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
1303:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 1236              		.loc 1 1303 0
 1237 00e4 7B68     		ldr	r3, [r7, #4]
 1238 00e6 002B     		cmp	r3, #0
 1239 00e8 03D1     		bne	.L112
1304:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
1305:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					/* The queue was empty and no block time is specified (or
1306:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					the block time has expired) so leave now. */
1307:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 1240              		.loc 1 1307 0
 1241 00ea FFF7FEFF 		bl	vPortExitCritical
1308:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1309:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
 1242              		.loc 1 1309 0
 1243 00ee 0023     		movs	r3, #0
 1244 00f0 5FE0     		b	.L121
 1245              	.L112:
1310:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
1311:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 1246              		.loc 1 1311 0
 1247 00f2 7B6A     		ldr	r3, [r7, #36]
 1248 00f4 002B     		cmp	r3, #0
 1249 00f6 06D1     		bne	.L113
1312:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
1313:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					/* The queue was empty and a block time was specified so
1314:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					configure the timeout structure. */
1315:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 1250              		.loc 1 1315 0
 1251 00f8 07F11403 		add	r3, r7, #20
 1252 00fc 1846     		mov	r0, r3
 1253 00fe FFF7FEFF 		bl	vTaskSetTimeOutState
1316:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 1254              		.loc 1 1316 0
 1255 0102 0123     		movs	r3, #1
 1256 0104 7B62     		str	r3, [r7, #36]
 1257              	.L113:
1317:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
1318:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				else
1319:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
1320:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					/* Entry time was already set. */
1321:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1322:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
1323:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
1324:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
1325:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 1258              		.loc 1 1325 0
 1259 0106 FFF7FEFF 		bl	vPortExitCritical
1326:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1327:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1328:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
1329:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1330:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
 1260              		.loc 1 1330 0
 1261 010a FFF7FEFF 		bl	vTaskSuspendAll
1331:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 1262              		.loc 1 1331 0
 1263 010e FFF7FEFF 		bl	vPortEnterCritical
 1264 0112 3B6A     		ldr	r3, [r7, #32]
 1265 0114 5B6C     		ldr	r3, [r3, #68]
 1266 0116 B3F1FF3F 		cmp	r3, #-1
 1267 011a 02D1     		bne	.L114
 1268              		.loc 1 1331 0 is_stmt 0 discriminator 1
 1269 011c 3B6A     		ldr	r3, [r7, #32]
 1270 011e 0022     		movs	r2, #0
 1271 0120 5A64     		str	r2, [r3, #68]
 1272              	.L114:
 1273              		.loc 1 1331 0 discriminator 2
 1274 0122 3B6A     		ldr	r3, [r7, #32]
 1275 0124 9B6C     		ldr	r3, [r3, #72]
 1276 0126 B3F1FF3F 		cmp	r3, #-1
 1277 012a 02D1     		bne	.L115
 1278              		.loc 1 1331 0 discriminator 1
 1279 012c 3B6A     		ldr	r3, [r7, #32]
 1280 012e 0022     		movs	r2, #0
 1281 0130 9A64     		str	r2, [r3, #72]
 1282              	.L115:
 1283              		.loc 1 1331 0 discriminator 2
 1284 0132 FFF7FEFF 		bl	vPortExitCritical
1332:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1333:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1334:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1285              		.loc 1 1334 0 is_stmt 1 discriminator 2
 1286 0136 07F11402 		add	r2, r7, #20
 1287 013a 3B1D     		adds	r3, r7, #4
 1288 013c 1046     		mov	r0, r2
 1289 013e 1946     		mov	r1, r3
 1290 0140 FFF7FEFF 		bl	xTaskCheckForTimeOut
 1291 0144 0346     		mov	r3, r0
 1292 0146 002B     		cmp	r3, #0
 1293 0148 2BD1     		bne	.L116
1335:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
1336:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1294              		.loc 1 1336 0
 1295 014a 386A     		ldr	r0, [r7, #32]
 1296 014c FFF7FEFF 		bl	prvIsQueueEmpty
 1297 0150 0346     		mov	r3, r0
 1298 0152 002B     		cmp	r3, #0
 1299 0154 1FD0     		beq	.L117
1337:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
1338:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1339:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1340:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1341:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
1342:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1300              		.loc 1 1342 0
 1301 0156 3B6A     		ldr	r3, [r7, #32]
 1302 0158 1B68     		ldr	r3, [r3]
 1303 015a 002B     		cmp	r3, #0
 1304 015c 08D1     		bne	.L118
1343:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
1344:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						taskENTER_CRITICAL();
 1305              		.loc 1 1344 0
 1306 015e FFF7FEFF 		bl	vPortEnterCritical
1345:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						{
1346:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 1307              		.loc 1 1346 0
 1308 0162 3B6A     		ldr	r3, [r7, #32]
 1309 0164 5B68     		ldr	r3, [r3, #4]
 1310 0166 1846     		mov	r0, r3
 1311 0168 FFF7FEFF 		bl	vTaskPriorityInherit
1347:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						}
1348:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						taskEXIT_CRITICAL();
 1312              		.loc 1 1348 0
 1313 016c FFF7FEFF 		bl	vPortExitCritical
 1314              	.L118:
1349:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
1350:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					else
1351:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
1352:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1353:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
1354:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
1355:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				#endif
1356:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1357:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1315              		.loc 1 1357 0
 1316 0170 3B6A     		ldr	r3, [r7, #32]
 1317 0172 03F12402 		add	r2, r3, #36
 1318 0176 7B68     		ldr	r3, [r7, #4]
 1319 0178 1046     		mov	r0, r2
 1320 017a 1946     		mov	r1, r3
 1321 017c FFF7FEFF 		bl	vTaskPlaceOnEventList
1358:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1322              		.loc 1 1358 0
 1323 0180 386A     		ldr	r0, [r7, #32]
 1324 0182 FFF7FEFF 		bl	prvUnlockQueue
1359:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1325              		.loc 1 1359 0
 1326 0186 FFF7FEFF 		bl	xTaskResumeAll
 1327 018a 0346     		mov	r3, r0
 1328 018c 002B     		cmp	r3, #0
 1329 018e 0FD1     		bne	.L120
1360:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
1361:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
 1330              		.loc 1 1361 0
 1331 0190 FFF7FEFF 		bl	vPortYield
 1332 0194 0CE0     		b	.L120
 1333              	.L117:
1362:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
1363:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				else
1364:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
1365:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1366:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
1367:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
1368:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			else
1369:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
1370:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				/* Try again. */
1371:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1334              		.loc 1 1371 0
 1335 0196 386A     		ldr	r0, [r7, #32]
 1336 0198 FFF7FEFF 		bl	prvUnlockQueue
1372:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 1337              		.loc 1 1372 0
 1338 019c FFF7FEFF 		bl	xTaskResumeAll
1373:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
1374:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
1375:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		else
1376:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
1377:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
1378:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
1379:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FAILED( pxQueue );
1380:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			return errQUEUE_EMPTY;
1381:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
1382:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
 1339              		.loc 1 1382 0
 1340 01a0 5EE7     		b	.L105
 1341              	.L116:
1377:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 1342              		.loc 1 1377 0
 1343 01a2 386A     		ldr	r0, [r7, #32]
 1344 01a4 FFF7FEFF 		bl	prvUnlockQueue
1378:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FAILED( pxQueue );
 1345              		.loc 1 1378 0
 1346 01a8 FFF7FEFF 		bl	xTaskResumeAll
1380:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
 1347              		.loc 1 1380 0
 1348 01ac 0023     		movs	r3, #0
 1349 01ae 00E0     		b	.L121
 1350              	.L120:
 1351              		.loc 1 1382 0
 1352 01b0 56E7     		b	.L105
 1353              	.L121:
1383:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** }
 1354              		.loc 1 1383 0
 1355 01b2 1846     		mov	r0, r3
 1356 01b4 2837     		adds	r7, r7, #40
 1357 01b6 BD46     		mov	sp, r7
 1358              		@ sp needed
 1359 01b8 80BD     		pop	{r7, pc}
 1360              		.cfi_endproc
 1361              	.LFE9:
 1363 01ba 00BF     		.section	.text.xQueueReceiveFromISR,"ax",%progbits
 1364              		.align	2
 1365              		.global	xQueueReceiveFromISR
 1366              		.thumb
 1367              		.thumb_func
 1369              	xQueueReceiveFromISR:
 1370              	.LFB10:
1384:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1385:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1386:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const px
1387:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** {
 1371              		.loc 1 1387 0
 1372              		.cfi_startproc
 1373              		@ args = 0, pretend = 0, frame = 32
 1374              		@ frame_needed = 1, uses_anonymous_args = 0
 1375 0000 80B5     		push	{r7, lr}
 1376              	.LCFI27:
 1377              		.cfi_def_cfa_offset 8
 1378              		.cfi_offset 7, -8
 1379              		.cfi_offset 14, -4
 1380 0002 88B0     		sub	sp, sp, #32
 1381              	.LCFI28:
 1382              		.cfi_def_cfa_offset 40
 1383 0004 00AF     		add	r7, sp, #0
 1384              	.LCFI29:
 1385              		.cfi_def_cfa_register 7
 1386 0006 F860     		str	r0, [r7, #12]
 1387 0008 B960     		str	r1, [r7, #8]
 1388 000a 7A60     		str	r2, [r7, #4]
1388:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1389:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1390:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1389              		.loc 1 1390 0
 1390 000c FB68     		ldr	r3, [r7, #12]
 1391 000e BB61     		str	r3, [r7, #24]
1391:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1392:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 1392              		.loc 1 1392 0
 1393 0010 BB69     		ldr	r3, [r7, #24]
 1394 0012 002B     		cmp	r3, #0
 1395 0014 02D1     		bne	.L123
 1396              		.loc 1 1392 0 is_stmt 0 discriminator 1
 1397 0016 FFF7FEFF 		bl	ulPortSetInterruptMask
 1398              	.L124:
 1399 001a FEE7     		b	.L124
 1400              	.L123:
1393:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 1401              		.loc 1 1393 0 is_stmt 1
 1402 001c BB68     		ldr	r3, [r7, #8]
 1403 001e 002B     		cmp	r3, #0
 1404 0020 03D1     		bne	.L125
 1405              		.loc 1 1393 0 is_stmt 0 discriminator 2
 1406 0022 BB69     		ldr	r3, [r7, #24]
 1407 0024 1B6C     		ldr	r3, [r3, #64]
 1408 0026 002B     		cmp	r3, #0
 1409 0028 01D1     		bne	.L126
 1410              	.L125:
 1411              		.loc 1 1393 0 discriminator 1
 1412 002a 0123     		movs	r3, #1
 1413 002c 00E0     		b	.L127
 1414              	.L126:
 1415              		.loc 1 1393 0 discriminator 3
 1416 002e 0023     		movs	r3, #0
 1417              	.L127:
 1418              		.loc 1 1393 0 discriminator 4
 1419 0030 002B     		cmp	r3, #0
 1420 0032 02D1     		bne	.L128
 1421              		.loc 1 1393 0 discriminator 1
 1422 0034 FFF7FEFF 		bl	ulPortSetInterruptMask
 1423              	.L129:
 1424 0038 FEE7     		b	.L129
 1425              	.L128:
1394:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1395:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1396:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1397:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1398:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1399:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1400:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1401:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1402:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1403:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1404:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1405:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1406:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1407:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1408:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1409:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 1426              		.loc 1 1409 0 is_stmt 1
 1427 003a FFF7FEFF 		bl	vPortValidateInterruptPriority
1410:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1411:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1428              		.loc 1 1411 0
 1429 003e FFF7FEFF 		bl	ulPortSetInterruptMask
 1430 0042 7861     		str	r0, [r7, #20]
1412:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
1413:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1414:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 1431              		.loc 1 1414 0
 1432 0044 BB69     		ldr	r3, [r7, #24]
 1433 0046 9B6B     		ldr	r3, [r3, #56]
 1434 0048 002B     		cmp	r3, #0
 1435 004a 28D0     		beq	.L130
1415:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
1416:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1417:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1418:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1436              		.loc 1 1418 0
 1437 004c B869     		ldr	r0, [r7, #24]
 1438 004e B968     		ldr	r1, [r7, #8]
 1439 0050 FFF7FEFF 		bl	prvCopyDataFromQueue
1419:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
 1440              		.loc 1 1419 0
 1441 0054 BB69     		ldr	r3, [r7, #24]
 1442 0056 9B6B     		ldr	r3, [r3, #56]
 1443 0058 5A1E     		subs	r2, r3, #1
 1444 005a BB69     		ldr	r3, [r7, #24]
 1445 005c 9A63     		str	r2, [r3, #56]
1420:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1421:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			/* If the queue is locked the event list will not be modified.
1422:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			Instead update the lock count so the task that unlocks the queue
1423:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			will know that an ISR has removed data while the queue was
1424:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			locked. */
1425:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			if( pxQueue->xRxLock == queueUNLOCKED )
 1446              		.loc 1 1425 0
 1447 005e BB69     		ldr	r3, [r7, #24]
 1448 0060 5B6C     		ldr	r3, [r3, #68]
 1449 0062 B3F1FF3F 		cmp	r3, #-1
 1450 0066 12D1     		bne	.L131
1426:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
1427:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1451              		.loc 1 1427 0
 1452 0068 BB69     		ldr	r3, [r7, #24]
 1453 006a 1B69     		ldr	r3, [r3, #16]
 1454 006c 002B     		cmp	r3, #0
 1455 006e 13D0     		beq	.L132
1428:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
1429:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1456              		.loc 1 1429 0
 1457 0070 BB69     		ldr	r3, [r7, #24]
 1458 0072 1033     		adds	r3, r3, #16
 1459 0074 1846     		mov	r0, r3
 1460 0076 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1461 007a 0346     		mov	r3, r0
 1462 007c 002B     		cmp	r3, #0
 1463 007e 0BD0     		beq	.L132
1430:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
1431:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						/* The task waiting has a higher priority than us so
1432:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						force a context switch. */
1433:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						if( pxHigherPriorityTaskWoken != NULL )
 1464              		.loc 1 1433 0
 1465 0080 7B68     		ldr	r3, [r7, #4]
 1466 0082 002B     		cmp	r3, #0
 1467 0084 08D0     		beq	.L132
1434:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						{
1435:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							*pxHigherPriorityTaskWoken = pdTRUE;
 1468              		.loc 1 1435 0
 1469 0086 7B68     		ldr	r3, [r7, #4]
 1470 0088 0122     		movs	r2, #1
 1471 008a 1A60     		str	r2, [r3]
 1472 008c 04E0     		b	.L132
 1473              	.L131:
1436:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						}
1437:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						else
1438:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						{
1439:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1440:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						}
1441:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
1442:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					else
1443:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
1444:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1445:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
1446:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
1447:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				else
1448:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
1449:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1450:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
1451:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
1452:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			else
1453:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
1454:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1455:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				knows that data was removed while it was locked. */
1456:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				++( pxQueue->xRxLock );
 1474              		.loc 1 1456 0
 1475 008e BB69     		ldr	r3, [r7, #24]
 1476 0090 5B6C     		ldr	r3, [r3, #68]
 1477 0092 5A1C     		adds	r2, r3, #1
 1478 0094 BB69     		ldr	r3, [r7, #24]
 1479 0096 5A64     		str	r2, [r3, #68]
 1480              	.L132:
1457:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
1458:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1459:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 1481              		.loc 1 1459 0 discriminator 4
 1482 0098 0123     		movs	r3, #1
 1483 009a FB61     		str	r3, [r7, #28]
 1484 009c 01E0     		b	.L133
 1485              	.L130:
1460:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
1461:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		else
1462:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
1463:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
 1486              		.loc 1 1463 0
 1487 009e 0023     		movs	r3, #0
 1488 00a0 FB61     		str	r3, [r7, #28]
 1489              	.L133:
1464:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1465:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
1466:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
1467:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1490              		.loc 1 1467 0
 1491 00a2 7869     		ldr	r0, [r7, #20]
 1492 00a4 FFF7FEFF 		bl	vPortClearInterruptMask
1468:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1469:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	return xReturn;
 1493              		.loc 1 1469 0
 1494 00a8 FB69     		ldr	r3, [r7, #28]
1470:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** }
 1495              		.loc 1 1470 0
 1496 00aa 1846     		mov	r0, r3
 1497 00ac 2037     		adds	r7, r7, #32
 1498 00ae BD46     		mov	sp, r7
 1499              		@ sp needed
 1500 00b0 80BD     		pop	{r7, pc}
 1501              		.cfi_endproc
 1502              	.LFE10:
 1504 00b2 00BF     		.section	.text.xQueuePeekFromISR,"ax",%progbits
 1505              		.align	2
 1506              		.global	xQueuePeekFromISR
 1507              		.thumb
 1508              		.thumb_func
 1510              	xQueuePeekFromISR:
 1511              	.LFB11:
1471:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1472:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1473:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
1474:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** {
 1512              		.loc 1 1474 0
 1513              		.cfi_startproc
 1514              		@ args = 0, pretend = 0, frame = 24
 1515              		@ frame_needed = 1, uses_anonymous_args = 0
 1516 0000 80B5     		push	{r7, lr}
 1517              	.LCFI30:
 1518              		.cfi_def_cfa_offset 8
 1519              		.cfi_offset 7, -8
 1520              		.cfi_offset 14, -4
 1521 0002 86B0     		sub	sp, sp, #24
 1522              	.LCFI31:
 1523              		.cfi_def_cfa_offset 32
 1524 0004 00AF     		add	r7, sp, #0
 1525              	.LCFI32:
 1526              		.cfi_def_cfa_register 7
 1527 0006 7860     		str	r0, [r7, #4]
 1528 0008 3960     		str	r1, [r7]
1475:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1476:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1477:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** int8_t *pcOriginalReadPosition;
1478:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1529              		.loc 1 1478 0
 1530 000a 7B68     		ldr	r3, [r7, #4]
 1531 000c 3B61     		str	r3, [r7, #16]
1479:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1480:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 1532              		.loc 1 1480 0
 1533 000e 3B69     		ldr	r3, [r7, #16]
 1534 0010 002B     		cmp	r3, #0
 1535 0012 02D1     		bne	.L136
 1536              		.loc 1 1480 0 is_stmt 0 discriminator 1
 1537 0014 FFF7FEFF 		bl	ulPortSetInterruptMask
 1538              	.L137:
 1539 0018 FEE7     		b	.L137
 1540              	.L136:
1481:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 1541              		.loc 1 1481 0 is_stmt 1
 1542 001a 3B68     		ldr	r3, [r7]
 1543 001c 002B     		cmp	r3, #0
 1544 001e 03D1     		bne	.L138
 1545              		.loc 1 1481 0 is_stmt 0 discriminator 2
 1546 0020 3B69     		ldr	r3, [r7, #16]
 1547 0022 1B6C     		ldr	r3, [r3, #64]
 1548 0024 002B     		cmp	r3, #0
 1549 0026 01D1     		bne	.L139
 1550              	.L138:
 1551              		.loc 1 1481 0 discriminator 1
 1552 0028 0123     		movs	r3, #1
 1553 002a 00E0     		b	.L140
 1554              	.L139:
 1555              		.loc 1 1481 0 discriminator 3
 1556 002c 0023     		movs	r3, #0
 1557              	.L140:
 1558              		.loc 1 1481 0 discriminator 4
 1559 002e 002B     		cmp	r3, #0
 1560 0030 02D1     		bne	.L141
 1561              		.loc 1 1481 0 discriminator 1
 1562 0032 FFF7FEFF 		bl	ulPortSetInterruptMask
 1563              	.L142:
 1564 0036 FEE7     		b	.L142
 1565              	.L141:
1482:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1483:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1484:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1485:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1486:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1487:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1488:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1489:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1490:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1491:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1492:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1493:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1494:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1495:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1496:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1497:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 1566              		.loc 1 1497 0 is_stmt 1
 1567 0038 FFF7FEFF 		bl	vPortValidateInterruptPriority
1498:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1499:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1568              		.loc 1 1499 0
 1569 003c FFF7FEFF 		bl	ulPortSetInterruptMask
 1570 0040 F860     		str	r0, [r7, #12]
1500:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
1501:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1502:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 1571              		.loc 1 1502 0
 1572 0042 3B69     		ldr	r3, [r7, #16]
 1573 0044 9B6B     		ldr	r3, [r3, #56]
 1574 0046 002B     		cmp	r3, #0
 1575 0048 0CD0     		beq	.L143
1503:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
1504:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR( pxQueue );
1505:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1506:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			/* Remember the read position so it can be reset as nothing is
1507:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			actually being removed from the queue. */
1508:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 1576              		.loc 1 1508 0
 1577 004a 3B69     		ldr	r3, [r7, #16]
 1578 004c DB68     		ldr	r3, [r3, #12]
 1579 004e BB60     		str	r3, [r7, #8]
1509:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1580              		.loc 1 1509 0
 1581 0050 3869     		ldr	r0, [r7, #16]
 1582 0052 3968     		ldr	r1, [r7]
 1583 0054 FFF7FEFF 		bl	prvCopyDataFromQueue
1510:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 1584              		.loc 1 1510 0
 1585 0058 3B69     		ldr	r3, [r7, #16]
 1586 005a BA68     		ldr	r2, [r7, #8]
 1587 005c DA60     		str	r2, [r3, #12]
1511:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1512:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 1588              		.loc 1 1512 0
 1589 005e 0123     		movs	r3, #1
 1590 0060 7B61     		str	r3, [r7, #20]
 1591 0062 01E0     		b	.L144
 1592              	.L143:
1513:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
1514:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		else
1515:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
1516:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
 1593              		.loc 1 1516 0
 1594 0064 0023     		movs	r3, #0
 1595 0066 7B61     		str	r3, [r7, #20]
 1596              	.L144:
1517:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1518:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
1519:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
1520:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1597              		.loc 1 1520 0
 1598 0068 F868     		ldr	r0, [r7, #12]
 1599 006a FFF7FEFF 		bl	vPortClearInterruptMask
1521:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1522:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	return xReturn;
 1600              		.loc 1 1522 0
 1601 006e 7B69     		ldr	r3, [r7, #20]
1523:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** }
 1602              		.loc 1 1523 0
 1603 0070 1846     		mov	r0, r3
 1604 0072 1837     		adds	r7, r7, #24
 1605 0074 BD46     		mov	sp, r7
 1606              		@ sp needed
 1607 0076 80BD     		pop	{r7, pc}
 1608              		.cfi_endproc
 1609              	.LFE11:
 1611              		.section	.text.uxQueueMessagesWaiting,"ax",%progbits
 1612              		.align	2
 1613              		.global	uxQueueMessagesWaiting
 1614              		.thumb
 1615              		.thumb_func
 1617              	uxQueueMessagesWaiting:
 1618              	.LFB12:
1524:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1525:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1526:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
1527:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** {
 1619              		.loc 1 1527 0
 1620              		.cfi_startproc
 1621              		@ args = 0, pretend = 0, frame = 16
 1622              		@ frame_needed = 1, uses_anonymous_args = 0
 1623 0000 80B5     		push	{r7, lr}
 1624              	.LCFI33:
 1625              		.cfi_def_cfa_offset 8
 1626              		.cfi_offset 7, -8
 1627              		.cfi_offset 14, -4
 1628 0002 84B0     		sub	sp, sp, #16
 1629              	.LCFI34:
 1630              		.cfi_def_cfa_offset 24
 1631 0004 00AF     		add	r7, sp, #0
 1632              	.LCFI35:
 1633              		.cfi_def_cfa_register 7
 1634 0006 7860     		str	r0, [r7, #4]
1528:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
1529:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1530:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	configASSERT( xQueue );
 1635              		.loc 1 1530 0
 1636 0008 7B68     		ldr	r3, [r7, #4]
 1637 000a 002B     		cmp	r3, #0
 1638 000c 02D1     		bne	.L147
 1639              		.loc 1 1530 0 is_stmt 0 discriminator 1
 1640 000e FFF7FEFF 		bl	ulPortSetInterruptMask
 1641              	.L148:
 1642 0012 FEE7     		b	.L148
 1643              	.L147:
1531:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1532:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 1644              		.loc 1 1532 0 is_stmt 1
 1645 0014 FFF7FEFF 		bl	vPortEnterCritical
1533:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
1534:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 1646              		.loc 1 1534 0
 1647 0018 7B68     		ldr	r3, [r7, #4]
 1648 001a 9B6B     		ldr	r3, [r3, #56]
 1649 001c FB60     		str	r3, [r7, #12]
1535:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
1536:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 1650              		.loc 1 1536 0
 1651 001e FFF7FEFF 		bl	vPortExitCritical
1537:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1538:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	return uxReturn;
 1652              		.loc 1 1538 0
 1653 0022 FB68     		ldr	r3, [r7, #12]
1539:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1654              		.loc 1 1539 0
 1655 0024 1846     		mov	r0, r3
 1656 0026 1037     		adds	r7, r7, #16
 1657 0028 BD46     		mov	sp, r7
 1658              		@ sp needed
 1659 002a 80BD     		pop	{r7, pc}
 1660              		.cfi_endproc
 1661              	.LFE12:
 1663              		.section	.text.uxQueueSpacesAvailable,"ax",%progbits
 1664              		.align	2
 1665              		.global	uxQueueSpacesAvailable
 1666              		.thumb
 1667              		.thumb_func
 1669              	uxQueueSpacesAvailable:
 1670              	.LFB13:
1540:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1541:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1542:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
1543:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** {
 1671              		.loc 1 1543 0
 1672              		.cfi_startproc
 1673              		@ args = 0, pretend = 0, frame = 16
 1674              		@ frame_needed = 1, uses_anonymous_args = 0
 1675 0000 80B5     		push	{r7, lr}
 1676              	.LCFI36:
 1677              		.cfi_def_cfa_offset 8
 1678              		.cfi_offset 7, -8
 1679              		.cfi_offset 14, -4
 1680 0002 84B0     		sub	sp, sp, #16
 1681              	.LCFI37:
 1682              		.cfi_def_cfa_offset 24
 1683 0004 00AF     		add	r7, sp, #0
 1684              	.LCFI38:
 1685              		.cfi_def_cfa_register 7
 1686 0006 7860     		str	r0, [r7, #4]
1544:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
1545:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** Queue_t *pxQueue;
1546:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1547:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	pxQueue = ( Queue_t * ) xQueue;
 1687              		.loc 1 1547 0
 1688 0008 7B68     		ldr	r3, [r7, #4]
 1689 000a FB60     		str	r3, [r7, #12]
1548:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 1690              		.loc 1 1548 0
 1691 000c FB68     		ldr	r3, [r7, #12]
 1692 000e 002B     		cmp	r3, #0
 1693 0010 02D1     		bne	.L151
 1694              		.loc 1 1548 0 is_stmt 0 discriminator 1
 1695 0012 FFF7FEFF 		bl	ulPortSetInterruptMask
 1696              	.L152:
 1697 0016 FEE7     		b	.L152
 1698              	.L151:
1549:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1550:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 1699              		.loc 1 1550 0 is_stmt 1
 1700 0018 FFF7FEFF 		bl	vPortEnterCritical
1551:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
1552:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 1701              		.loc 1 1552 0
 1702 001c FB68     		ldr	r3, [r7, #12]
 1703 001e DA6B     		ldr	r2, [r3, #60]
 1704 0020 FB68     		ldr	r3, [r7, #12]
 1705 0022 9B6B     		ldr	r3, [r3, #56]
 1706 0024 D31A     		subs	r3, r2, r3
 1707 0026 BB60     		str	r3, [r7, #8]
1553:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
1554:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 1708              		.loc 1 1554 0
 1709 0028 FFF7FEFF 		bl	vPortExitCritical
1555:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1556:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	return uxReturn;
 1710              		.loc 1 1556 0
 1711 002c BB68     		ldr	r3, [r7, #8]
1557:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1712              		.loc 1 1557 0
 1713 002e 1846     		mov	r0, r3
 1714 0030 1037     		adds	r7, r7, #16
 1715 0032 BD46     		mov	sp, r7
 1716              		@ sp needed
 1717 0034 80BD     		pop	{r7, pc}
 1718              		.cfi_endproc
 1719              	.LFE13:
 1721 0036 00BF     		.section	.text.uxQueueMessagesWaitingFromISR,"ax",%progbits
 1722              		.align	2
 1723              		.global	uxQueueMessagesWaitingFromISR
 1724              		.thumb
 1725              		.thumb_func
 1727              	uxQueueMessagesWaitingFromISR:
 1728              	.LFB14:
1558:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1559:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1560:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
1561:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** {
 1729              		.loc 1 1561 0
 1730              		.cfi_startproc
 1731              		@ args = 0, pretend = 0, frame = 16
 1732              		@ frame_needed = 1, uses_anonymous_args = 0
 1733 0000 80B5     		push	{r7, lr}
 1734              	.LCFI39:
 1735              		.cfi_def_cfa_offset 8
 1736              		.cfi_offset 7, -8
 1737              		.cfi_offset 14, -4
 1738 0002 84B0     		sub	sp, sp, #16
 1739              	.LCFI40:
 1740              		.cfi_def_cfa_offset 24
 1741 0004 00AF     		add	r7, sp, #0
 1742              	.LCFI41:
 1743              		.cfi_def_cfa_register 7
 1744 0006 7860     		str	r0, [r7, #4]
1562:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
1563:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1564:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	configASSERT( xQueue );
 1745              		.loc 1 1564 0
 1746 0008 7B68     		ldr	r3, [r7, #4]
 1747 000a 002B     		cmp	r3, #0
 1748 000c 02D1     		bne	.L155
 1749              		.loc 1 1564 0 is_stmt 0 discriminator 1
 1750 000e FFF7FEFF 		bl	ulPortSetInterruptMask
 1751              	.L156:
 1752 0012 FEE7     		b	.L156
 1753              	.L155:
1565:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1566:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 1754              		.loc 1 1566 0 is_stmt 1
 1755 0014 7B68     		ldr	r3, [r7, #4]
 1756 0016 9B6B     		ldr	r3, [r3, #56]
 1757 0018 FB60     		str	r3, [r7, #12]
1567:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1568:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	return uxReturn;
 1758              		.loc 1 1568 0
 1759 001a FB68     		ldr	r3, [r7, #12]
1569:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1760              		.loc 1 1569 0
 1761 001c 1846     		mov	r0, r3
 1762 001e 1037     		adds	r7, r7, #16
 1763 0020 BD46     		mov	sp, r7
 1764              		@ sp needed
 1765 0022 80BD     		pop	{r7, pc}
 1766              		.cfi_endproc
 1767              	.LFE14:
 1769              		.section	.text.vQueueDelete,"ax",%progbits
 1770              		.align	2
 1771              		.global	vQueueDelete
 1772              		.thumb
 1773              		.thumb_func
 1775              	vQueueDelete:
 1776              	.LFB15:
1570:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1571:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1572:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** void vQueueDelete( QueueHandle_t xQueue )
1573:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** {
 1777              		.loc 1 1573 0
 1778              		.cfi_startproc
 1779              		@ args = 0, pretend = 0, frame = 16
 1780              		@ frame_needed = 1, uses_anonymous_args = 0
 1781 0000 80B5     		push	{r7, lr}
 1782              	.LCFI42:
 1783              		.cfi_def_cfa_offset 8
 1784              		.cfi_offset 7, -8
 1785              		.cfi_offset 14, -4
 1786 0002 84B0     		sub	sp, sp, #16
 1787              	.LCFI43:
 1788              		.cfi_def_cfa_offset 24
 1789 0004 00AF     		add	r7, sp, #0
 1790              	.LCFI44:
 1791              		.cfi_def_cfa_register 7
 1792 0006 7860     		str	r0, [r7, #4]
1574:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1793              		.loc 1 1574 0
 1794 0008 7B68     		ldr	r3, [r7, #4]
 1795 000a FB60     		str	r3, [r7, #12]
1575:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1576:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 1796              		.loc 1 1576 0
 1797 000c FB68     		ldr	r3, [r7, #12]
 1798 000e 002B     		cmp	r3, #0
 1799 0010 02D1     		bne	.L159
 1800              		.loc 1 1576 0 is_stmt 0 discriminator 1
 1801 0012 FFF7FEFF 		bl	ulPortSetInterruptMask
 1802              	.L160:
 1803 0016 FEE7     		b	.L160
 1804              	.L159:
1577:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1578:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1579:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	#if ( configQUEUE_REGISTRY_SIZE > 0 )
1580:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
1581:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		vQueueUnregisterQueue( pxQueue );
 1805              		.loc 1 1581 0 is_stmt 1
 1806 0018 F868     		ldr	r0, [r7, #12]
 1807 001a FFF7FEFF 		bl	vQueueUnregisterQueue
1582:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
1583:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	#endif
1584:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	if( pxQueue->pcHead != NULL )
 1808              		.loc 1 1584 0
 1809 001e FB68     		ldr	r3, [r7, #12]
 1810 0020 1B68     		ldr	r3, [r3]
 1811 0022 002B     		cmp	r3, #0
 1812 0024 04D0     		beq	.L161
1585:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
1586:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		vPortFree( pxQueue->pcHead );
 1813              		.loc 1 1586 0
 1814 0026 FB68     		ldr	r3, [r7, #12]
 1815 0028 1B68     		ldr	r3, [r3]
 1816 002a 1846     		mov	r0, r3
 1817 002c FFF7FEFF 		bl	vPortFree
 1818              	.L161:
1587:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
1588:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	vPortFree( pxQueue );
 1819              		.loc 1 1588 0
 1820 0030 F868     		ldr	r0, [r7, #12]
 1821 0032 FFF7FEFF 		bl	vPortFree
1589:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** }
 1822              		.loc 1 1589 0
 1823 0036 1037     		adds	r7, r7, #16
 1824 0038 BD46     		mov	sp, r7
 1825              		@ sp needed
 1826 003a 80BD     		pop	{r7, pc}
 1827              		.cfi_endproc
 1828              	.LFE15:
 1830              		.section	.text.uxQueueGetQueueNumber,"ax",%progbits
 1831              		.align	2
 1832              		.global	uxQueueGetQueueNumber
 1833              		.thumb
 1834              		.thumb_func
 1836              	uxQueueGetQueueNumber:
 1837              	.LFB16:
1590:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1591:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1592:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1593:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1594:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
1595:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
 1838              		.loc 1 1595 0
 1839              		.cfi_startproc
 1840              		@ args = 0, pretend = 0, frame = 8
 1841              		@ frame_needed = 1, uses_anonymous_args = 0
 1842              		@ link register save eliminated.
 1843 0000 80B4     		push	{r7}
 1844              	.LCFI45:
 1845              		.cfi_def_cfa_offset 4
 1846              		.cfi_offset 7, -4
 1847 0002 83B0     		sub	sp, sp, #12
 1848              	.LCFI46:
 1849              		.cfi_def_cfa_offset 16
 1850 0004 00AF     		add	r7, sp, #0
 1851              	.LCFI47:
 1852              		.cfi_def_cfa_register 7
 1853 0006 7860     		str	r0, [r7, #4]
1596:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
 1854              		.loc 1 1596 0
 1855 0008 7B68     		ldr	r3, [r7, #4]
 1856 000a DB6C     		ldr	r3, [r3, #76]
1597:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
 1857              		.loc 1 1597 0
 1858 000c 1846     		mov	r0, r3
 1859 000e 0C37     		adds	r7, r7, #12
 1860 0010 BD46     		mov	sp, r7
 1861              		@ sp needed
 1862 0012 5DF8047B 		ldr	r7, [sp], #4
 1863 0016 7047     		bx	lr
 1864              		.cfi_endproc
 1865              	.LFE16:
 1867              		.section	.text.vQueueSetQueueNumber,"ax",%progbits
 1868              		.align	2
 1869              		.global	vQueueSetQueueNumber
 1870              		.thumb
 1871              		.thumb_func
 1873              	vQueueSetQueueNumber:
 1874              	.LFB17:
1598:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1599:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1600:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1601:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1602:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1603:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1604:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
1605:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
 1875              		.loc 1 1605 0
 1876              		.cfi_startproc
 1877              		@ args = 0, pretend = 0, frame = 8
 1878              		@ frame_needed = 1, uses_anonymous_args = 0
 1879              		@ link register save eliminated.
 1880 0000 80B4     		push	{r7}
 1881              	.LCFI48:
 1882              		.cfi_def_cfa_offset 4
 1883              		.cfi_offset 7, -4
 1884 0002 83B0     		sub	sp, sp, #12
 1885              	.LCFI49:
 1886              		.cfi_def_cfa_offset 16
 1887 0004 00AF     		add	r7, sp, #0
 1888              	.LCFI50:
 1889              		.cfi_def_cfa_register 7
 1890 0006 7860     		str	r0, [r7, #4]
 1891 0008 3960     		str	r1, [r7]
1606:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
 1892              		.loc 1 1606 0
 1893 000a 7B68     		ldr	r3, [r7, #4]
 1894 000c 3A68     		ldr	r2, [r7]
 1895 000e DA64     		str	r2, [r3, #76]
1607:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
 1896              		.loc 1 1607 0
 1897 0010 0C37     		adds	r7, r7, #12
 1898 0012 BD46     		mov	sp, r7
 1899              		@ sp needed
 1900 0014 5DF8047B 		ldr	r7, [sp], #4
 1901 0018 7047     		bx	lr
 1902              		.cfi_endproc
 1903              	.LFE17:
 1905 001a 00BF     		.section	.text.ucQueueGetQueueType,"ax",%progbits
 1906              		.align	2
 1907              		.global	ucQueueGetQueueType
 1908              		.thumb
 1909              		.thumb_func
 1911              	ucQueueGetQueueType:
 1912              	.LFB18:
1608:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1609:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1610:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1611:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1612:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1613:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1614:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
1615:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
 1913              		.loc 1 1615 0
 1914              		.cfi_startproc
 1915              		@ args = 0, pretend = 0, frame = 8
 1916              		@ frame_needed = 1, uses_anonymous_args = 0
 1917              		@ link register save eliminated.
 1918 0000 80B4     		push	{r7}
 1919              	.LCFI51:
 1920              		.cfi_def_cfa_offset 4
 1921              		.cfi_offset 7, -4
 1922 0002 83B0     		sub	sp, sp, #12
 1923              	.LCFI52:
 1924              		.cfi_def_cfa_offset 16
 1925 0004 00AF     		add	r7, sp, #0
 1926              	.LCFI53:
 1927              		.cfi_def_cfa_register 7
 1928 0006 7860     		str	r0, [r7, #4]
1616:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		return ( ( Queue_t * ) xQueue )->ucQueueType;
 1929              		.loc 1 1616 0
 1930 0008 7B68     		ldr	r3, [r7, #4]
 1931 000a 93F85030 		ldrb	r3, [r3, #80]	@ zero_extendqisi2
1617:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
 1932              		.loc 1 1617 0
 1933 000e 1846     		mov	r0, r3
 1934 0010 0C37     		adds	r7, r7, #12
 1935 0012 BD46     		mov	sp, r7
 1936              		@ sp needed
 1937 0014 5DF8047B 		ldr	r7, [sp], #4
 1938 0018 7047     		bx	lr
 1939              		.cfi_endproc
 1940              	.LFE18:
 1942 001a 00BF     		.section	.text.prvCopyDataToQueue,"ax",%progbits
 1943              		.align	2
 1944              		.thumb
 1945              		.thumb_func
 1947              	prvCopyDataToQueue:
 1948              	.LFB19:
1618:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1619:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1620:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1621:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1622:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
1623:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** {
 1949              		.loc 1 1623 0
 1950              		.cfi_startproc
 1951              		@ args = 0, pretend = 0, frame = 24
 1952              		@ frame_needed = 1, uses_anonymous_args = 0
 1953 0000 80B5     		push	{r7, lr}
 1954              	.LCFI54:
 1955              		.cfi_def_cfa_offset 8
 1956              		.cfi_offset 7, -8
 1957              		.cfi_offset 14, -4
 1958 0002 86B0     		sub	sp, sp, #24
 1959              	.LCFI55:
 1960              		.cfi_def_cfa_offset 32
 1961 0004 00AF     		add	r7, sp, #0
 1962              	.LCFI56:
 1963              		.cfi_def_cfa_register 7
 1964 0006 F860     		str	r0, [r7, #12]
 1965 0008 B960     		str	r1, [r7, #8]
 1966 000a 7A60     		str	r2, [r7, #4]
1624:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** BaseType_t xReturn = pdFALSE;
 1967              		.loc 1 1624 0
 1968 000c 0023     		movs	r3, #0
 1969 000e 7B61     		str	r3, [r7, #20]
1625:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1626:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 1970              		.loc 1 1626 0
 1971 0010 FB68     		ldr	r3, [r7, #12]
 1972 0012 1B6C     		ldr	r3, [r3, #64]
 1973 0014 002B     		cmp	r3, #0
 1974 0016 0DD1     		bne	.L168
1627:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
1628:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
1629:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
1630:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1975              		.loc 1 1630 0
 1976 0018 FB68     		ldr	r3, [r7, #12]
 1977 001a 1B68     		ldr	r3, [r3]
 1978 001c 002B     		cmp	r3, #0
 1979 001e 52D1     		bne	.L169
1631:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
1632:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				/* The mutex is no longer being held. */
1633:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 1980              		.loc 1 1633 0
 1981 0020 FB68     		ldr	r3, [r7, #12]
 1982 0022 5B68     		ldr	r3, [r3, #4]
 1983 0024 1846     		mov	r0, r3
 1984 0026 FFF7FEFF 		bl	xTaskPriorityDisinherit
 1985 002a 7861     		str	r0, [r7, #20]
1634:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				pxQueue->pxMutexHolder = NULL;
 1986              		.loc 1 1634 0
 1987 002c FB68     		ldr	r3, [r7, #12]
 1988 002e 0022     		movs	r2, #0
 1989 0030 5A60     		str	r2, [r3, #4]
 1990 0032 48E0     		b	.L169
 1991              	.L168:
1635:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
1636:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			else
1637:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
1638:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1639:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
1640:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
1641:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		#endif /* configUSE_MUTEXES */
1642:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
1643:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
 1992              		.loc 1 1643 0
 1993 0034 7B68     		ldr	r3, [r7, #4]
 1994 0036 002B     		cmp	r3, #0
 1995 0038 1AD1     		bne	.L170
1644:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
1645:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); 
 1996              		.loc 1 1645 0
 1997 003a FB68     		ldr	r3, [r7, #12]
 1998 003c 9A68     		ldr	r2, [r3, #8]
 1999 003e FB68     		ldr	r3, [r7, #12]
 2000 0040 1B6C     		ldr	r3, [r3, #64]
 2001 0042 1046     		mov	r0, r2
 2002 0044 B968     		ldr	r1, [r7, #8]
 2003 0046 1A46     		mov	r2, r3
 2004 0048 FFF7FEFF 		bl	memcpy
1646:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 2005              		.loc 1 1646 0
 2006 004c FB68     		ldr	r3, [r7, #12]
 2007 004e 9A68     		ldr	r2, [r3, #8]
 2008 0050 FB68     		ldr	r3, [r7, #12]
 2009 0052 1B6C     		ldr	r3, [r3, #64]
 2010 0054 1A44     		add	r2, r2, r3
 2011 0056 FB68     		ldr	r3, [r7, #12]
 2012 0058 9A60     		str	r2, [r3, #8]
1647:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison 
 2013              		.loc 1 1647 0
 2014 005a FB68     		ldr	r3, [r7, #12]
 2015 005c 9A68     		ldr	r2, [r3, #8]
 2016 005e FB68     		ldr	r3, [r7, #12]
 2017 0060 5B68     		ldr	r3, [r3, #4]
 2018 0062 9A42     		cmp	r2, r3
 2019 0064 2FD3     		bcc	.L169
1648:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
1649:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
 2020              		.loc 1 1649 0
 2021 0066 FB68     		ldr	r3, [r7, #12]
 2022 0068 1A68     		ldr	r2, [r3]
 2023 006a FB68     		ldr	r3, [r7, #12]
 2024 006c 9A60     		str	r2, [r3, #8]
 2025 006e 2AE0     		b	.L169
 2026              	.L170:
1650:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
1651:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		else
1652:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
1653:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1654:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
1655:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
1656:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	else
1657:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
1658:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize 
 2027              		.loc 1 1658 0
 2028 0070 FB68     		ldr	r3, [r7, #12]
 2029 0072 DA68     		ldr	r2, [r3, #12]
 2030 0074 FB68     		ldr	r3, [r7, #12]
 2031 0076 1B6C     		ldr	r3, [r3, #64]
 2032 0078 1046     		mov	r0, r2
 2033 007a B968     		ldr	r1, [r7, #8]
 2034 007c 1A46     		mov	r2, r3
 2035 007e FFF7FEFF 		bl	memcpy
1659:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 2036              		.loc 1 1659 0
 2037 0082 FB68     		ldr	r3, [r7, #12]
 2038 0084 DA68     		ldr	r2, [r3, #12]
 2039 0086 FB68     		ldr	r3, [r7, #12]
 2040 0088 1B6C     		ldr	r3, [r3, #64]
 2041 008a 5B42     		negs	r3, r3
 2042 008c 1A44     		add	r2, r2, r3
 2043 008e FB68     		ldr	r3, [r7, #12]
 2044 0090 DA60     		str	r2, [r3, #12]
1660:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as compariso
 2045              		.loc 1 1660 0
 2046 0092 FB68     		ldr	r3, [r7, #12]
 2047 0094 DA68     		ldr	r2, [r3, #12]
 2048 0096 FB68     		ldr	r3, [r7, #12]
 2049 0098 1B68     		ldr	r3, [r3]
 2050 009a 9A42     		cmp	r2, r3
 2051 009c 07D2     		bcs	.L171
1661:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
1662:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 2052              		.loc 1 1662 0
 2053 009e FB68     		ldr	r3, [r7, #12]
 2054 00a0 5A68     		ldr	r2, [r3, #4]
 2055 00a2 FB68     		ldr	r3, [r7, #12]
 2056 00a4 1B6C     		ldr	r3, [r3, #64]
 2057 00a6 5B42     		negs	r3, r3
 2058 00a8 1A44     		add	r2, r2, r3
 2059 00aa FB68     		ldr	r3, [r7, #12]
 2060 00ac DA60     		str	r2, [r3, #12]
 2061              	.L171:
1663:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
1664:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		else
1665:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
1666:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1667:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
1668:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1669:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		if( xPosition == queueOVERWRITE )
 2062              		.loc 1 1669 0
 2063 00ae 7B68     		ldr	r3, [r7, #4]
 2064 00b0 022B     		cmp	r3, #2
 2065 00b2 08D1     		bne	.L169
1670:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
1671:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 2066              		.loc 1 1671 0
 2067 00b4 FB68     		ldr	r3, [r7, #12]
 2068 00b6 9B6B     		ldr	r3, [r3, #56]
 2069 00b8 002B     		cmp	r3, #0
 2070 00ba 04D0     		beq	.L169
1672:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
1673:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				/* An item is not being added but overwritten, so subtract
1674:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				one from the recorded number of items in the queue so when
1675:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				one is added again below the number of recorded items remains
1676:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				correct. */
1677:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				--( pxQueue->uxMessagesWaiting );
 2071              		.loc 1 1677 0
 2072 00bc FB68     		ldr	r3, [r7, #12]
 2073 00be 9B6B     		ldr	r3, [r3, #56]
 2074 00c0 5A1E     		subs	r2, r3, #1
 2075 00c2 FB68     		ldr	r3, [r7, #12]
 2076 00c4 9A63     		str	r2, [r3, #56]
 2077              	.L169:
1678:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
1679:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			else
1680:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
1681:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1682:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
1683:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
1684:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		else
1685:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
1686:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1687:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
1688:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
1689:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1690:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	++( pxQueue->uxMessagesWaiting );
 2078              		.loc 1 1690 0
 2079 00c6 FB68     		ldr	r3, [r7, #12]
 2080 00c8 9B6B     		ldr	r3, [r3, #56]
 2081 00ca 5A1C     		adds	r2, r3, #1
 2082 00cc FB68     		ldr	r3, [r7, #12]
 2083 00ce 9A63     		str	r2, [r3, #56]
1691:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1692:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	return xReturn;
 2084              		.loc 1 1692 0
 2085 00d0 7B69     		ldr	r3, [r7, #20]
1693:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** }
 2086              		.loc 1 1693 0
 2087 00d2 1846     		mov	r0, r3
 2088 00d4 1837     		adds	r7, r7, #24
 2089 00d6 BD46     		mov	sp, r7
 2090              		@ sp needed
 2091 00d8 80BD     		pop	{r7, pc}
 2092              		.cfi_endproc
 2093              	.LFE19:
 2095 00da 00BF     		.section	.text.prvCopyDataFromQueue,"ax",%progbits
 2096              		.align	2
 2097              		.thumb
 2098              		.thumb_func
 2100              	prvCopyDataFromQueue:
 2101              	.LFB20:
1694:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1695:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1696:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
1697:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** {
 2102              		.loc 1 1697 0
 2103              		.cfi_startproc
 2104              		@ args = 0, pretend = 0, frame = 8
 2105              		@ frame_needed = 1, uses_anonymous_args = 0
 2106 0000 80B5     		push	{r7, lr}
 2107              	.LCFI57:
 2108              		.cfi_def_cfa_offset 8
 2109              		.cfi_offset 7, -8
 2110              		.cfi_offset 14, -4
 2111 0002 82B0     		sub	sp, sp, #8
 2112              	.LCFI58:
 2113              		.cfi_def_cfa_offset 16
 2114 0004 00AF     		add	r7, sp, #0
 2115              	.LCFI59:
 2116              		.cfi_def_cfa_register 7
 2117 0006 7860     		str	r0, [r7, #4]
 2118 0008 3960     		str	r1, [r7]
1698:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 2119              		.loc 1 1698 0
 2120 000a 7B68     		ldr	r3, [r7, #4]
 2121 000c 1B6C     		ldr	r3, [r3, #64]
 2122 000e 002B     		cmp	r3, #0
 2123 0010 19D0     		beq	.L173
1699:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
1700:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 2124              		.loc 1 1700 0
 2125 0012 7B68     		ldr	r3, [r7, #4]
 2126 0014 DA68     		ldr	r2, [r3, #12]
 2127 0016 7B68     		ldr	r3, [r7, #4]
 2128 0018 1B6C     		ldr	r3, [r3, #64]
 2129 001a 1A44     		add	r2, r2, r3
 2130 001c 7B68     		ldr	r3, [r7, #4]
 2131 001e DA60     		str	r2, [r3, #12]
1701:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of t
 2132              		.loc 1 1701 0
 2133 0020 7B68     		ldr	r3, [r7, #4]
 2134 0022 DA68     		ldr	r2, [r3, #12]
 2135 0024 7B68     		ldr	r3, [r7, #4]
 2136 0026 5B68     		ldr	r3, [r3, #4]
 2137 0028 9A42     		cmp	r2, r3
 2138 002a 03D3     		bcc	.L175
1702:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
1703:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 2139              		.loc 1 1703 0
 2140 002c 7B68     		ldr	r3, [r7, #4]
 2141 002e 1A68     		ldr	r2, [r3]
 2142 0030 7B68     		ldr	r3, [r7, #4]
 2143 0032 DA60     		str	r2, [r3, #12]
 2144              	.L175:
1704:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
1705:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		else
1706:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
1707:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1708:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
1709:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxIte
 2145              		.loc 1 1709 0
 2146 0034 7B68     		ldr	r3, [r7, #4]
 2147 0036 DA68     		ldr	r2, [r3, #12]
 2148 0038 7B68     		ldr	r3, [r7, #4]
 2149 003a 1B6C     		ldr	r3, [r3, #64]
 2150 003c 3868     		ldr	r0, [r7]
 2151 003e 1146     		mov	r1, r2
 2152 0040 1A46     		mov	r2, r3
 2153 0042 FFF7FEFF 		bl	memcpy
 2154              	.L173:
1710:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
1711:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** }
 2155              		.loc 1 1711 0
 2156 0046 0837     		adds	r7, r7, #8
 2157 0048 BD46     		mov	sp, r7
 2158              		@ sp needed
 2159 004a 80BD     		pop	{r7, pc}
 2160              		.cfi_endproc
 2161              	.LFE20:
 2163              		.section	.text.prvUnlockQueue,"ax",%progbits
 2164              		.align	2
 2165              		.thumb
 2166              		.thumb_func
 2168              	prvUnlockQueue:
 2169              	.LFB21:
1712:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1713:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1714:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue )
1715:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** {
 2170              		.loc 1 1715 0
 2171              		.cfi_startproc
 2172              		@ args = 0, pretend = 0, frame = 8
 2173              		@ frame_needed = 1, uses_anonymous_args = 0
 2174 0000 80B5     		push	{r7, lr}
 2175              	.LCFI60:
 2176              		.cfi_def_cfa_offset 8
 2177              		.cfi_offset 7, -8
 2178              		.cfi_offset 14, -4
 2179 0002 82B0     		sub	sp, sp, #8
 2180              	.LCFI61:
 2181              		.cfi_def_cfa_offset 16
 2182 0004 00AF     		add	r7, sp, #0
 2183              	.LCFI62:
 2184              		.cfi_def_cfa_register 7
 2185 0006 7860     		str	r0, [r7, #4]
1716:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1717:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1718:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	/* The lock counts contains the number of extra data items placed or
1719:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
1720:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	locked items can be added or removed, but the event lists cannot be
1721:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	updated. */
1722:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 2186              		.loc 1 1722 0
 2187 0008 FFF7FEFF 		bl	vPortEnterCritical
1723:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
1724:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		/* See if data was added to the queue while it was locked. */
1725:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 2188              		.loc 1 1725 0
 2189 000c 14E0     		b	.L177
 2190              	.L181:
1726:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
1727:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
1728:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			blocked waiting for data to become available? */
1729:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
1730:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
1731:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				if( pxQueue->pxQueueSetContainer != NULL )
1732:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
1733:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
1734:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
1735:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						/* The queue is a member of a queue set, and posting to
1736:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						the queue set caused a higher priority task to unblock.
1737:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						A context switch is required. */
1738:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						vTaskMissedYield();
1739:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
1740:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					else
1741:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
1742:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1743:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
1744:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
1745:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				else
1746:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
1747:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					/* Tasks that are removed from the event list will get added to
1748:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					the pending ready list as the scheduler is still suspended. */
1749:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1750:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
1751:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1752:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						{
1753:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1754:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							context	switch is required. */
1755:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							vTaskMissedYield();
1756:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						}
1757:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						else
1758:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						{
1759:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1760:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						}
1761:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
1762:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					else
1763:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
1764:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						break;
1765:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
1766:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
1767:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
1768:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			#else /* configUSE_QUEUE_SETS */
1769:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
1770:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				/* Tasks that are removed from the event list will get added to
1771:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				the pending ready list as the scheduler is still suspended. */
1772:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 2191              		.loc 1 1772 0
 2192 000e 7B68     		ldr	r3, [r7, #4]
 2193 0010 5B6A     		ldr	r3, [r3, #36]
 2194 0012 002B     		cmp	r3, #0
 2195 0014 0AD0     		beq	.L178
1773:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
1774:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 2196              		.loc 1 1774 0
 2197 0016 7B68     		ldr	r3, [r7, #4]
 2198 0018 2433     		adds	r3, r3, #36
 2199 001a 1846     		mov	r0, r3
 2200 001c FFF7FEFF 		bl	xTaskRemoveFromEventList
 2201 0020 0346     		mov	r3, r0
 2202 0022 002B     		cmp	r3, #0
 2203 0024 03D0     		beq	.L179
1775:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
1776:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						/* The task waiting has a higher priority so record that a
1777:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						context	switch is required. */
1778:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						vTaskMissedYield();
 2204              		.loc 1 1778 0
 2205 0026 FFF7FEFF 		bl	vTaskMissedYield
 2206 002a 00E0     		b	.L179
 2207              	.L178:
1779:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
1780:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					else
1781:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
1782:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1783:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
1784:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
1785:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				else
1786:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
1787:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					break;
 2208              		.loc 1 1787 0
 2209 002c 08E0     		b	.L180
 2210              	.L179:
1788:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
1789:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
1790:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			#endif /* configUSE_QUEUE_SETS */
1791:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1792:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			--( pxQueue->xTxLock );
 2211              		.loc 1 1792 0
 2212 002e 7B68     		ldr	r3, [r7, #4]
 2213 0030 9B6C     		ldr	r3, [r3, #72]
 2214 0032 5A1E     		subs	r2, r3, #1
 2215 0034 7B68     		ldr	r3, [r7, #4]
 2216 0036 9A64     		str	r2, [r3, #72]
 2217              	.L177:
1725:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
 2218              		.loc 1 1725 0 discriminator 1
 2219 0038 7B68     		ldr	r3, [r7, #4]
 2220 003a 9B6C     		ldr	r3, [r3, #72]
 2221 003c 002B     		cmp	r3, #0
 2222 003e E6DC     		bgt	.L181
 2223              	.L180:
1793:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
1794:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1795:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 2224              		.loc 1 1795 0
 2225 0040 7B68     		ldr	r3, [r7, #4]
 2226 0042 4FF0FF32 		mov	r2, #-1
 2227 0046 9A64     		str	r2, [r3, #72]
1796:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
1797:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 2228              		.loc 1 1797 0
 2229 0048 FFF7FEFF 		bl	vPortExitCritical
1798:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1799:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	/* Do the same for the Rx lock. */
1800:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 2230              		.loc 1 1800 0
 2231 004c FFF7FEFF 		bl	vPortEnterCritical
1801:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
1802:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 2232              		.loc 1 1802 0
 2233 0050 14E0     		b	.L182
 2234              	.L186:
1803:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
1804:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 2235              		.loc 1 1804 0
 2236 0052 7B68     		ldr	r3, [r7, #4]
 2237 0054 1B69     		ldr	r3, [r3, #16]
 2238 0056 002B     		cmp	r3, #0
 2239 0058 0FD0     		beq	.L183
1805:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
1806:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 2240              		.loc 1 1806 0
 2241 005a 7B68     		ldr	r3, [r7, #4]
 2242 005c 1033     		adds	r3, r3, #16
 2243 005e 1846     		mov	r0, r3
 2244 0060 FFF7FEFF 		bl	xTaskRemoveFromEventList
 2245 0064 0346     		mov	r3, r0
 2246 0066 002B     		cmp	r3, #0
 2247 0068 01D0     		beq	.L184
1807:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
1808:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					vTaskMissedYield();
 2248              		.loc 1 1808 0
 2249 006a FFF7FEFF 		bl	vTaskMissedYield
 2250              	.L184:
1809:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
1810:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				else
1811:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
1812:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1813:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
1814:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1815:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				--( pxQueue->xRxLock );
 2251              		.loc 1 1815 0 discriminator 2
 2252 006e 7B68     		ldr	r3, [r7, #4]
 2253 0070 5B6C     		ldr	r3, [r3, #68]
 2254 0072 5A1E     		subs	r2, r3, #1
 2255 0074 7B68     		ldr	r3, [r7, #4]
 2256 0076 5A64     		str	r2, [r3, #68]
 2257 0078 00E0     		b	.L182
 2258              	.L183:
1816:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
1817:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			else
1818:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
1819:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				break;
 2259              		.loc 1 1819 0
 2260 007a 03E0     		b	.L185
 2261              	.L182:
1802:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
 2262              		.loc 1 1802 0 discriminator 1
 2263 007c 7B68     		ldr	r3, [r7, #4]
 2264 007e 5B6C     		ldr	r3, [r3, #68]
 2265 0080 002B     		cmp	r3, #0
 2266 0082 E6DC     		bgt	.L186
 2267              	.L185:
1820:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
1821:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
1822:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1823:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 2268              		.loc 1 1823 0
 2269 0084 7B68     		ldr	r3, [r7, #4]
 2270 0086 4FF0FF32 		mov	r2, #-1
 2271 008a 5A64     		str	r2, [r3, #68]
1824:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
1825:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 2272              		.loc 1 1825 0
 2273 008c FFF7FEFF 		bl	vPortExitCritical
1826:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** }
 2274              		.loc 1 1826 0
 2275 0090 0837     		adds	r7, r7, #8
 2276 0092 BD46     		mov	sp, r7
 2277              		@ sp needed
 2278 0094 80BD     		pop	{r7, pc}
 2279              		.cfi_endproc
 2280              	.LFE21:
 2282 0096 00BF     		.section	.text.prvIsQueueEmpty,"ax",%progbits
 2283              		.align	2
 2284              		.thumb
 2285              		.thumb_func
 2287              	prvIsQueueEmpty:
 2288              	.LFB22:
1827:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1828:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1829:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
1830:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** {
 2289              		.loc 1 1830 0
 2290              		.cfi_startproc
 2291              		@ args = 0, pretend = 0, frame = 16
 2292              		@ frame_needed = 1, uses_anonymous_args = 0
 2293 0000 80B5     		push	{r7, lr}
 2294              	.LCFI63:
 2295              		.cfi_def_cfa_offset 8
 2296              		.cfi_offset 7, -8
 2297              		.cfi_offset 14, -4
 2298 0002 84B0     		sub	sp, sp, #16
 2299              	.LCFI64:
 2300              		.cfi_def_cfa_offset 24
 2301 0004 00AF     		add	r7, sp, #0
 2302              	.LCFI65:
 2303              		.cfi_def_cfa_register 7
 2304 0006 7860     		str	r0, [r7, #4]
1831:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1832:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1833:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 2305              		.loc 1 1833 0
 2306 0008 FFF7FEFF 		bl	vPortEnterCritical
1834:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
1835:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 2307              		.loc 1 1835 0
 2308 000c 7B68     		ldr	r3, [r7, #4]
 2309 000e 9B6B     		ldr	r3, [r3, #56]
 2310 0010 002B     		cmp	r3, #0
 2311 0012 02D1     		bne	.L188
1836:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
1837:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			xReturn = pdTRUE;
 2312              		.loc 1 1837 0
 2313 0014 0123     		movs	r3, #1
 2314 0016 FB60     		str	r3, [r7, #12]
 2315 0018 01E0     		b	.L189
 2316              	.L188:
1838:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
1839:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		else
1840:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
1841:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			xReturn = pdFALSE;
 2317              		.loc 1 1841 0
 2318 001a 0023     		movs	r3, #0
 2319 001c FB60     		str	r3, [r7, #12]
 2320              	.L189:
1842:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
1843:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
1844:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 2321              		.loc 1 1844 0
 2322 001e FFF7FEFF 		bl	vPortExitCritical
1845:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1846:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	return xReturn;
 2323              		.loc 1 1846 0
 2324 0022 FB68     		ldr	r3, [r7, #12]
1847:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** }
 2325              		.loc 1 1847 0
 2326 0024 1846     		mov	r0, r3
 2327 0026 1037     		adds	r7, r7, #16
 2328 0028 BD46     		mov	sp, r7
 2329              		@ sp needed
 2330 002a 80BD     		pop	{r7, pc}
 2331              		.cfi_endproc
 2332              	.LFE22:
 2334              		.section	.text.xQueueIsQueueEmptyFromISR,"ax",%progbits
 2335              		.align	2
 2336              		.global	xQueueIsQueueEmptyFromISR
 2337              		.thumb
 2338              		.thumb_func
 2340              	xQueueIsQueueEmptyFromISR:
 2341              	.LFB23:
1848:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1849:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1850:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
1851:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** {
 2342              		.loc 1 1851 0
 2343              		.cfi_startproc
 2344              		@ args = 0, pretend = 0, frame = 16
 2345              		@ frame_needed = 1, uses_anonymous_args = 0
 2346 0000 80B5     		push	{r7, lr}
 2347              	.LCFI66:
 2348              		.cfi_def_cfa_offset 8
 2349              		.cfi_offset 7, -8
 2350              		.cfi_offset 14, -4
 2351 0002 84B0     		sub	sp, sp, #16
 2352              	.LCFI67:
 2353              		.cfi_def_cfa_offset 24
 2354 0004 00AF     		add	r7, sp, #0
 2355              	.LCFI68:
 2356              		.cfi_def_cfa_register 7
 2357 0006 7860     		str	r0, [r7, #4]
1852:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1853:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1854:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	configASSERT( xQueue );
 2358              		.loc 1 1854 0
 2359 0008 7B68     		ldr	r3, [r7, #4]
 2360 000a 002B     		cmp	r3, #0
 2361 000c 02D1     		bne	.L192
 2362              		.loc 1 1854 0 is_stmt 0 discriminator 1
 2363 000e FFF7FEFF 		bl	ulPortSetInterruptMask
 2364              	.L193:
 2365 0012 FEE7     		b	.L193
 2366              	.L192:
1855:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
 2367              		.loc 1 1855 0 is_stmt 1
 2368 0014 7B68     		ldr	r3, [r7, #4]
 2369 0016 9B6B     		ldr	r3, [r3, #56]
 2370 0018 002B     		cmp	r3, #0
 2371 001a 02D1     		bne	.L194
1856:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
1857:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		xReturn = pdTRUE;
 2372              		.loc 1 1857 0
 2373 001c 0123     		movs	r3, #1
 2374 001e FB60     		str	r3, [r7, #12]
 2375 0020 01E0     		b	.L195
 2376              	.L194:
1858:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
1859:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	else
1860:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
1861:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		xReturn = pdFALSE;
 2377              		.loc 1 1861 0
 2378 0022 0023     		movs	r3, #0
 2379 0024 FB60     		str	r3, [r7, #12]
 2380              	.L195:
1862:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
1863:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1864:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	return xReturn;
 2381              		.loc 1 1864 0
 2382 0026 FB68     		ldr	r3, [r7, #12]
1865:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2383              		.loc 1 1865 0
 2384 0028 1846     		mov	r0, r3
 2385 002a 1037     		adds	r7, r7, #16
 2386 002c BD46     		mov	sp, r7
 2387              		@ sp needed
 2388 002e 80BD     		pop	{r7, pc}
 2389              		.cfi_endproc
 2390              	.LFE23:
 2392              		.section	.text.prvIsQueueFull,"ax",%progbits
 2393              		.align	2
 2394              		.thumb
 2395              		.thumb_func
 2397              	prvIsQueueFull:
 2398              	.LFB24:
1866:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1867:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1868:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
1869:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** {
 2399              		.loc 1 1869 0
 2400              		.cfi_startproc
 2401              		@ args = 0, pretend = 0, frame = 16
 2402              		@ frame_needed = 1, uses_anonymous_args = 0
 2403 0000 80B5     		push	{r7, lr}
 2404              	.LCFI69:
 2405              		.cfi_def_cfa_offset 8
 2406              		.cfi_offset 7, -8
 2407              		.cfi_offset 14, -4
 2408 0002 84B0     		sub	sp, sp, #16
 2409              	.LCFI70:
 2410              		.cfi_def_cfa_offset 24
 2411 0004 00AF     		add	r7, sp, #0
 2412              	.LCFI71:
 2413              		.cfi_def_cfa_register 7
 2414 0006 7860     		str	r0, [r7, #4]
1870:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1871:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1872:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 2415              		.loc 1 1872 0
 2416 0008 FFF7FEFF 		bl	vPortEnterCritical
1873:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
1874:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 2417              		.loc 1 1874 0
 2418 000c 7B68     		ldr	r3, [r7, #4]
 2419 000e 9A6B     		ldr	r2, [r3, #56]
 2420 0010 7B68     		ldr	r3, [r7, #4]
 2421 0012 DB6B     		ldr	r3, [r3, #60]
 2422 0014 9A42     		cmp	r2, r3
 2423 0016 02D1     		bne	.L198
1875:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
1876:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			xReturn = pdTRUE;
 2424              		.loc 1 1876 0
 2425 0018 0123     		movs	r3, #1
 2426 001a FB60     		str	r3, [r7, #12]
 2427 001c 01E0     		b	.L199
 2428              	.L198:
1877:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
1878:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		else
1879:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
1880:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			xReturn = pdFALSE;
 2429              		.loc 1 1880 0
 2430 001e 0023     		movs	r3, #0
 2431 0020 FB60     		str	r3, [r7, #12]
 2432              	.L199:
1881:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
1882:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
1883:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 2433              		.loc 1 1883 0
 2434 0022 FFF7FEFF 		bl	vPortExitCritical
1884:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1885:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	return xReturn;
 2435              		.loc 1 1885 0
 2436 0026 FB68     		ldr	r3, [r7, #12]
1886:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** }
 2437              		.loc 1 1886 0
 2438 0028 1846     		mov	r0, r3
 2439 002a 1037     		adds	r7, r7, #16
 2440 002c BD46     		mov	sp, r7
 2441              		@ sp needed
 2442 002e 80BD     		pop	{r7, pc}
 2443              		.cfi_endproc
 2444              	.LFE24:
 2446              		.section	.text.xQueueIsQueueFullFromISR,"ax",%progbits
 2447              		.align	2
 2448              		.global	xQueueIsQueueFullFromISR
 2449              		.thumb
 2450              		.thumb_func
 2452              	xQueueIsQueueFullFromISR:
 2453              	.LFB25:
1887:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1888:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1889:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
1890:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** {
 2454              		.loc 1 1890 0
 2455              		.cfi_startproc
 2456              		@ args = 0, pretend = 0, frame = 16
 2457              		@ frame_needed = 1, uses_anonymous_args = 0
 2458 0000 80B5     		push	{r7, lr}
 2459              	.LCFI72:
 2460              		.cfi_def_cfa_offset 8
 2461              		.cfi_offset 7, -8
 2462              		.cfi_offset 14, -4
 2463 0002 84B0     		sub	sp, sp, #16
 2464              	.LCFI73:
 2465              		.cfi_def_cfa_offset 24
 2466 0004 00AF     		add	r7, sp, #0
 2467              	.LCFI74:
 2468              		.cfi_def_cfa_register 7
 2469 0006 7860     		str	r0, [r7, #4]
1891:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1892:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1893:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	configASSERT( xQueue );
 2470              		.loc 1 1893 0
 2471 0008 7B68     		ldr	r3, [r7, #4]
 2472 000a 002B     		cmp	r3, #0
 2473 000c 02D1     		bne	.L202
 2474              		.loc 1 1893 0 is_stmt 0 discriminator 1
 2475 000e FFF7FEFF 		bl	ulPortSetInterruptMask
 2476              	.L203:
 2477 0012 FEE7     		b	.L203
 2478              	.L202:
1894:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
 2479              		.loc 1 1894 0 is_stmt 1
 2480 0014 7B68     		ldr	r3, [r7, #4]
 2481 0016 9A6B     		ldr	r2, [r3, #56]
 2482 0018 7B68     		ldr	r3, [r7, #4]
 2483 001a DB6B     		ldr	r3, [r3, #60]
 2484 001c 9A42     		cmp	r2, r3
 2485 001e 02D1     		bne	.L204
1895:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
1896:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		xReturn = pdTRUE;
 2486              		.loc 1 1896 0
 2487 0020 0123     		movs	r3, #1
 2488 0022 FB60     		str	r3, [r7, #12]
 2489 0024 01E0     		b	.L205
 2490              	.L204:
1897:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
1898:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	else
1899:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
1900:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		xReturn = pdFALSE;
 2491              		.loc 1 1900 0
 2492 0026 0023     		movs	r3, #0
 2493 0028 FB60     		str	r3, [r7, #12]
 2494              	.L205:
1901:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
1902:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1903:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	return xReturn;
 2495              		.loc 1 1903 0
 2496 002a FB68     		ldr	r3, [r7, #12]
1904:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2497              		.loc 1 1904 0
 2498 002c 1846     		mov	r0, r3
 2499 002e 1037     		adds	r7, r7, #16
 2500 0030 BD46     		mov	sp, r7
 2501              		@ sp needed
 2502 0032 80BD     		pop	{r7, pc}
 2503              		.cfi_endproc
 2504              	.LFE25:
 2506              		.section	.text.vQueueAddToRegistry,"ax",%progbits
 2507              		.align	2
 2508              		.global	vQueueAddToRegistry
 2509              		.thumb
 2510              		.thumb_func
 2512              	vQueueAddToRegistry:
 2513              	.LFB26:
1905:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1906:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1907:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
1908:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1909:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait 
1910:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
1911:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
1912:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1913:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1914:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		/* If the queue is already full we may have to block.  A critical section
1915:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		is required to prevent an interrupt removing something from the queue
1916:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		between the check to see if the queue is full and blocking on the queue. */
1917:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		portDISABLE_INTERRUPTS();
1918:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
1919:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
1920:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
1921:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				/* The queue is full - do we want to block or just leave without
1922:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				posting? */
1923:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
1924:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
1925:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					/* As this is called from a coroutine we cannot block directly, but
1926:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					return indicating that we need to block. */
1927:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
1928:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					portENABLE_INTERRUPTS();
1929:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					return errQUEUE_BLOCKED;
1930:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
1931:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				else
1932:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
1933:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					portENABLE_INTERRUPTS();
1934:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
1935:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
1936:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
1937:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
1938:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		portENABLE_INTERRUPTS();
1939:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1940:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		portDISABLE_INTERRUPTS();
1941:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
1942:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
1943:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
1944:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				/* There is room in the queue, copy the data into the queue. */
1945:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
1946:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				xReturn = pdPASS;
1947:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1948:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				/* Were any co-routines waiting for data to become available? */
1949:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1950:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
1951:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					/* In this instance the co-routine could be placed directly
1952:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					into the ready list as we are within a critical section.
1953:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					Instead the same pending ready list mechanism is used as if
1954:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					the event were caused from within an interrupt. */
1955:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1956:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
1957:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						/* The co-routine waiting has a higher priority so record
1958:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						that a yield might be appropriate. */
1959:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						xReturn = errQUEUE_YIELD;
1960:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
1961:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					else
1962:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
1963:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1964:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
1965:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
1966:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				else
1967:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
1968:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1969:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
1970:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
1971:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			else
1972:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
1973:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				xReturn = errQUEUE_FULL;
1974:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
1975:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
1976:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		portENABLE_INTERRUPTS();
1977:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1978:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		return xReturn;
1979:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
1980:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1981:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
1982:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1983:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1984:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
1985:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1986:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
1987:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
1988:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
1989:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1990:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
1991:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		/* If the queue is already empty we may have to block.  A critical section
1992:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		is required to prevent an interrupt adding something to the queue
1993:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		between the check to see if the queue is empty and blocking on the queue. */
1994:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		portDISABLE_INTERRUPTS();
1995:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
1996:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
1997:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
1998:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				/* There are no messages in the queue, do we want to block or just
1999:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				leave with nothing? */
2000:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
2001:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
2002:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					/* As this is a co-routine we cannot block directly, but return
2003:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					indicating that we need to block. */
2004:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
2005:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					portENABLE_INTERRUPTS();
2006:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					return errQUEUE_BLOCKED;
2007:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
2008:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				else
2009:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
2010:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					portENABLE_INTERRUPTS();
2011:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
2012:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
2013:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
2014:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			else
2015:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
2016:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2017:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
2018:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
2019:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		portENABLE_INTERRUPTS();
2020:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
2021:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		portDISABLE_INTERRUPTS();
2022:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
2023:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2024:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
2025:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				/* Data is available from the queue. */
2026:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
2027:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
2028:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
2029:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					pxQueue->u.pcReadFrom = pxQueue->pcHead;
2030:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
2031:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				else
2032:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
2033:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2034:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
2035:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				--( pxQueue->uxMessagesWaiting );
2036:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->u
2037:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
2038:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				xReturn = pdPASS;
2039:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
2040:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				/* Were any co-routines waiting for space to become available? */
2041:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2042:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
2043:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					/* In this instance the co-routine could be placed directly
2044:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					into the ready list as we are within a critical section.
2045:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					Instead the same pending ready list mechanism is used as if
2046:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					the event were caused from within an interrupt. */
2047:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2048:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
2049:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						xReturn = errQUEUE_YIELD;
2050:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
2051:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					else
2052:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
2053:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2054:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
2055:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
2056:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				else
2057:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
2058:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2059:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
2060:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
2061:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			else
2062:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
2063:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				xReturn = pdFAIL;
2064:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
2065:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
2066:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		portENABLE_INTERRUPTS();
2067:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
2068:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		return xReturn;
2069:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
2070:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
2071:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2072:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2073:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
2074:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2075:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
2076:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRou
2077:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
2078:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2079:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
2080:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		/* Cannot block within an ISR so if there is no space on the queue then
2081:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		exit without doing anything. */
2082:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2083:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
2084:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2085:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
2086:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			/* We only want to wake one co-routine per ISR, so check that a
2087:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			co-routine has not already been woken. */
2088:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			if( xCoRoutinePreviouslyWoken == pdFALSE )
2089:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
2090:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2091:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
2092:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2093:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
2094:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						return pdTRUE;
2095:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
2096:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					else
2097:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
2098:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2099:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
2100:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
2101:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				else
2102:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
2103:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2104:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
2105:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
2106:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			else
2107:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
2108:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2109:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
2110:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
2111:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		else
2112:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
2113:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2114:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
2115:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
2116:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		return xCoRoutinePreviouslyWoken;
2117:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
2118:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
2119:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2120:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2121:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
2122:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2123:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
2124:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWo
2125:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
2126:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
2127:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2128:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
2129:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		/* We cannot block from an ISR, so check there is data available. If
2130:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		not then just leave without doing anything. */
2131:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2132:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
2133:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			/* Copy the data from the queue. */
2134:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
2135:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
2136:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
2137:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				pxQueue->u.pcReadFrom = pxQueue->pcHead;
2138:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
2139:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			else
2140:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
2141:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2142:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
2143:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
2144:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->ux
2145:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
2146:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			if( ( *pxCoRoutineWoken ) == pdFALSE )
2147:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
2148:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2149:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
2150:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2151:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
2152:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						*pxCoRoutineWoken = pdTRUE;
2153:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
2154:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					else
2155:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					{
2156:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2157:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					}
2158:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
2159:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				else
2160:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				{
2161:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2162:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				}
2163:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
2164:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			else
2165:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
2166:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2167:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
2168:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
2169:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
2170:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
2171:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		else
2172:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
2173:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
2174:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
2175:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
2176:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		return xReturn;
2177:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
2178:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
2179:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2180:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2181:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
2182:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2183:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
2184:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified
2185:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
 2514              		.loc 1 2185 0
 2515              		.cfi_startproc
 2516              		@ args = 0, pretend = 0, frame = 16
 2517              		@ frame_needed = 1, uses_anonymous_args = 0
 2518              		@ link register save eliminated.
 2519 0000 80B4     		push	{r7}
 2520              	.LCFI75:
 2521              		.cfi_def_cfa_offset 4
 2522              		.cfi_offset 7, -4
 2523 0002 85B0     		sub	sp, sp, #20
 2524              	.LCFI76:
 2525              		.cfi_def_cfa_offset 24
 2526 0004 00AF     		add	r7, sp, #0
 2527              	.LCFI77:
 2528              		.cfi_def_cfa_register 7
 2529 0006 7860     		str	r0, [r7, #4]
 2530 0008 3960     		str	r1, [r7]
2186:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	UBaseType_t ux;
2187:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
2188:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		/* See if there is an empty space in the registry.  A NULL name denotes
2189:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		a free slot. */
2190:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 2531              		.loc 1 2190 0
 2532 000a 0023     		movs	r3, #0
 2533 000c FB60     		str	r3, [r7, #12]
 2534 000e 1DE0     		b	.L208
 2535              	.L211:
2191:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
2192:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 2536              		.loc 1 2192 0
 2537 0010 40F20003 		movw	r3, #:lower16:xQueueRegistry
 2538 0014 C0F20003 		movt	r3, #:upper16:xQueueRegistry
 2539 0018 FA68     		ldr	r2, [r7, #12]
 2540 001a 53F83230 		ldr	r3, [r3, r2, lsl #3]
 2541 001e 002B     		cmp	r3, #0
 2542 0020 11D1     		bne	.L209
2193:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
2194:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				/* Store the information on this queue. */
2195:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 2543              		.loc 1 2195 0
 2544 0022 40F20003 		movw	r3, #:lower16:xQueueRegistry
 2545 0026 C0F20003 		movt	r3, #:upper16:xQueueRegistry
 2546 002a FA68     		ldr	r2, [r7, #12]
 2547 002c 3968     		ldr	r1, [r7]
 2548 002e 43F83210 		str	r1, [r3, r2, lsl #3]
2196:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				xQueueRegistry[ ux ].xHandle = xQueue;
 2549              		.loc 1 2196 0
 2550 0032 40F20002 		movw	r2, #:lower16:xQueueRegistry
 2551 0036 C0F20002 		movt	r2, #:upper16:xQueueRegistry
 2552 003a FB68     		ldr	r3, [r7, #12]
 2553 003c DB00     		lsls	r3, r3, #3
 2554 003e 1344     		add	r3, r3, r2
 2555 0040 7A68     		ldr	r2, [r7, #4]
 2556 0042 5A60     		str	r2, [r3, #4]
2197:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
2198:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
2199:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				break;
 2557              		.loc 1 2199 0
 2558 0044 05E0     		b	.L207
 2559              	.L209:
2190:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
 2560              		.loc 1 2190 0
 2561 0046 FB68     		ldr	r3, [r7, #12]
 2562 0048 0133     		adds	r3, r3, #1
 2563 004a FB60     		str	r3, [r7, #12]
 2564              	.L208:
2190:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
 2565              		.loc 1 2190 0 is_stmt 0 discriminator 1
 2566 004c FB68     		ldr	r3, [r7, #12]
 2567 004e 072B     		cmp	r3, #7
 2568 0050 DED9     		bls	.L211
 2569              	.L207:
2200:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
2201:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			else
2202:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
2203:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2204:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
2205:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
2206:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
 2570              		.loc 1 2206 0 is_stmt 1
 2571 0052 1437     		adds	r7, r7, #20
 2572 0054 BD46     		mov	sp, r7
 2573              		@ sp needed
 2574 0056 5DF8047B 		ldr	r7, [sp], #4
 2575 005a 7047     		bx	lr
 2576              		.cfi_endproc
 2577              	.LFE26:
 2579              		.section	.text.vQueueUnregisterQueue,"ax",%progbits
 2580              		.align	2
 2581              		.global	vQueueUnregisterQueue
 2582              		.thumb
 2583              		.thumb_func
 2585              	vQueueUnregisterQueue:
 2586              	.LFB27:
2207:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
2208:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2209:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2210:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
2211:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2212:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
2213:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	void vQueueUnregisterQueue( QueueHandle_t xQueue )
2214:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
 2587              		.loc 1 2214 0
 2588              		.cfi_startproc
 2589              		@ args = 0, pretend = 0, frame = 16
 2590              		@ frame_needed = 1, uses_anonymous_args = 0
 2591              		@ link register save eliminated.
 2592 0000 80B4     		push	{r7}
 2593              	.LCFI78:
 2594              		.cfi_def_cfa_offset 4
 2595              		.cfi_offset 7, -4
 2596 0002 85B0     		sub	sp, sp, #20
 2597              	.LCFI79:
 2598              		.cfi_def_cfa_offset 24
 2599 0004 00AF     		add	r7, sp, #0
 2600              	.LCFI80:
 2601              		.cfi_def_cfa_register 7
 2602 0006 7860     		str	r0, [r7, #4]
2215:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	UBaseType_t ux;
2216:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
2217:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		/* See if the handle of the queue being unregistered in actually in the
2218:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		registry. */
2219:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 2603              		.loc 1 2219 0
 2604 0008 0023     		movs	r3, #0
 2605 000a FB60     		str	r3, [r7, #12]
 2606 000c 16E0     		b	.L213
 2607              	.L216:
2220:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
2221:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			if( xQueueRegistry[ ux ].xHandle == xQueue )
 2608              		.loc 1 2221 0
 2609 000e 40F20002 		movw	r2, #:lower16:xQueueRegistry
 2610 0012 C0F20002 		movt	r2, #:upper16:xQueueRegistry
 2611 0016 FB68     		ldr	r3, [r7, #12]
 2612 0018 DB00     		lsls	r3, r3, #3
 2613 001a 1344     		add	r3, r3, r2
 2614 001c 5A68     		ldr	r2, [r3, #4]
 2615 001e 7B68     		ldr	r3, [r7, #4]
 2616 0020 9A42     		cmp	r2, r3
 2617 0022 08D1     		bne	.L214
2222:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
2223:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				/* Set the name to NULL to show that this slot if free again. */
2224:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = NULL;
 2618              		.loc 1 2224 0
 2619 0024 40F20003 		movw	r3, #:lower16:xQueueRegistry
 2620 0028 C0F20003 		movt	r3, #:upper16:xQueueRegistry
 2621 002c FA68     		ldr	r2, [r7, #12]
 2622 002e 0021     		movs	r1, #0
 2623 0030 43F83210 		str	r1, [r3, r2, lsl #3]
2225:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				break;
 2624              		.loc 1 2225 0
 2625 0034 05E0     		b	.L212
 2626              	.L214:
2219:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
 2627              		.loc 1 2219 0
 2628 0036 FB68     		ldr	r3, [r7, #12]
 2629 0038 0133     		adds	r3, r3, #1
 2630 003a FB60     		str	r3, [r7, #12]
 2631              	.L213:
2219:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
 2632              		.loc 1 2219 0 is_stmt 0 discriminator 1
 2633 003c FB68     		ldr	r3, [r7, #12]
 2634 003e 072B     		cmp	r3, #7
 2635 0040 E5D9     		bls	.L216
 2636              	.L212:
2226:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
2227:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			else
2228:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			{
2229:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2230:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			}
2231:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
2232:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
2233:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2637              		.loc 1 2233 0 is_stmt 1
 2638 0042 1437     		adds	r7, r7, #20
 2639 0044 BD46     		mov	sp, r7
 2640              		@ sp needed
 2641 0046 5DF8047B 		ldr	r7, [sp], #4
 2642 004a 7047     		bx	lr
 2643              		.cfi_endproc
 2644              	.LFE27:
 2646              		.section	.text.vQueueWaitForMessageRestricted,"ax",%progbits
 2647              		.align	2
 2648              		.global	vQueueWaitForMessageRestricted
 2649              		.thumb
 2650              		.thumb_func
 2652              	vQueueWaitForMessageRestricted:
 2653              	.LFB28:
2234:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
2235:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2236:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2237:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
2238:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** #if ( configUSE_TIMERS == 1 )
2239:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
2240:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait )
2241:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	{
 2654              		.loc 1 2241 0
 2655              		.cfi_startproc
 2656              		@ args = 0, pretend = 0, frame = 16
 2657              		@ frame_needed = 1, uses_anonymous_args = 0
 2658 0000 80B5     		push	{r7, lr}
 2659              	.LCFI81:
 2660              		.cfi_def_cfa_offset 8
 2661              		.cfi_offset 7, -8
 2662              		.cfi_offset 14, -4
 2663 0002 84B0     		sub	sp, sp, #16
 2664              	.LCFI82:
 2665              		.cfi_def_cfa_offset 24
 2666 0004 00AF     		add	r7, sp, #0
 2667              	.LCFI83:
 2668              		.cfi_def_cfa_register 7
 2669 0006 7860     		str	r0, [r7, #4]
 2670 0008 3960     		str	r1, [r7]
2242:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 2671              		.loc 1 2242 0
 2672 000a 7B68     		ldr	r3, [r7, #4]
 2673 000c FB60     		str	r3, [r7, #12]
2243:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
2244:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		/* This function should not be called by application code hence the
2245:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
2246:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		designed for use by kernel code, and has special calling requirements.
2247:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		It can result in vListInsert() being called on a list that can only
2248:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		possibly ever have one item in it, so the list will be fast, but even
2249:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		so it should be called with the scheduler locked and not from a critical
2250:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		section. */
2251:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 
2252:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		/* Only do anything if there are no messages in the queue.  This function
2253:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		will not actually cause the task to block, just place it on a blocked
2254:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		list.  It will not block until the scheduler is unlocked - at which
2255:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		time a yield will be performed.  If an item is added to the queue while
2256:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		the queue is locked, and the calling task blocks on the queue, then the
2257:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		calling task will be immediately unblocked when the queue is unlocked. */
2258:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 2674              		.loc 1 2258 0
 2675 000e FFF7FEFF 		bl	vPortEnterCritical
 2676 0012 FB68     		ldr	r3, [r7, #12]
 2677 0014 5B6C     		ldr	r3, [r3, #68]
 2678 0016 B3F1FF3F 		cmp	r3, #-1
 2679 001a 02D1     		bne	.L218
 2680              		.loc 1 2258 0 is_stmt 0 discriminator 1
 2681 001c FB68     		ldr	r3, [r7, #12]
 2682 001e 0022     		movs	r2, #0
 2683 0020 5A64     		str	r2, [r3, #68]
 2684              	.L218:
 2685              		.loc 1 2258 0 discriminator 2
 2686 0022 FB68     		ldr	r3, [r7, #12]
 2687 0024 9B6C     		ldr	r3, [r3, #72]
 2688 0026 B3F1FF3F 		cmp	r3, #-1
 2689 002a 02D1     		bne	.L219
 2690              		.loc 1 2258 0 discriminator 1
 2691 002c FB68     		ldr	r3, [r7, #12]
 2692 002e 0022     		movs	r2, #0
 2693 0030 9A64     		str	r2, [r3, #72]
 2694              	.L219:
 2695              		.loc 1 2258 0 discriminator 2
 2696 0032 FFF7FEFF 		bl	vPortExitCritical
2259:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 2697              		.loc 1 2259 0 is_stmt 1 discriminator 2
 2698 0036 FB68     		ldr	r3, [r7, #12]
 2699 0038 9B6B     		ldr	r3, [r3, #56]
 2700 003a 002B     		cmp	r3, #0
 2701 003c 05D1     		bne	.L220
2260:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
2261:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			/* There is nothing in the queue, block for the specified period. */
2262:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 2702              		.loc 1 2262 0
 2703 003e FB68     		ldr	r3, [r7, #12]
 2704 0040 2433     		adds	r3, r3, #36
 2705 0042 1846     		mov	r0, r3
 2706 0044 3968     		ldr	r1, [r7]
 2707 0046 FFF7FEFF 		bl	vTaskPlaceOnEventListRestricted
 2708              	.L220:
2263:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
2264:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		else
2265:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		{
2266:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2267:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		}
2268:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 		prvUnlockQueue( pxQueue );
 2709              		.loc 1 2268 0
 2710 004a F868     		ldr	r0, [r7, #12]
 2711 004c FFF7FEFF 		bl	prvUnlockQueue
2269:lib/FreeRTOSV8.1.2/FreeRTOS/Source/queue.c **** 	}
 2712              		.loc 1 2269 0
 2713 0050 1037     		adds	r7, r7, #16
 2714 0052 BD46     		mov	sp, r7
 2715              		@ sp needed
 2716 0054 80BD     		pop	{r7, pc}
 2717              		.cfi_endproc
 2718              	.LFE28:
 2720 0056 00BF     		.text
 2721              	.Letext0:
 2722              		.file 2 "/usr/lib/gcc/arm-none-eabi/4.8.2/include/stddef.h"
 2723              		.file 3 "/usr/include/newlib/machine/_default_types.h"
 2724              		.file 4 "/usr/include/newlib/stdint.h"
 2725              		.file 5 "lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h"
 2726              		.file 6 "lib/FreeRTOSV8.1.2/FreeRTOS/Source/include/list.h"
 2727              		.file 7 "lib/FreeRTOSV8.1.2/FreeRTOS/Source/include/task.h"
 2728              		.file 8 "lib/FreeRTOSV8.1.2/FreeRTOS/Source/include/queue.h"
DEFINED SYMBOLS
                            *ABS*:00000000 queue.c
                            *COM*:00000040 xQueueRegistry
     /tmp/cco41iGu.s:21     .text.xQueueGenericReset:00000000 $t
     /tmp/cco41iGu.s:26     .text.xQueueGenericReset:00000000 xQueueGenericReset
     /tmp/cco41iGu.s:146    .text.xQueueGenericCreate:00000000 $t
     /tmp/cco41iGu.s:151    .text.xQueueGenericCreate:00000000 xQueueGenericCreate
     /tmp/cco41iGu.s:250    .text.xQueueCreateMutex:00000000 $t
     /tmp/cco41iGu.s:255    .text.xQueueCreateMutex:00000000 xQueueCreateMutex
     /tmp/cco41iGu.s:611    .text.xQueueGenericSend:00000000 xQueueGenericSend
     /tmp/cco41iGu.s:360    .text.xQueueGiveMutexRecursive:00000000 $t
     /tmp/cco41iGu.s:365    .text.xQueueGiveMutexRecursive:00000000 xQueueGiveMutexRecursive
     /tmp/cco41iGu.s:442    .text.xQueueTakeMutexRecursive:00000000 $t
     /tmp/cco41iGu.s:447    .text.xQueueTakeMutexRecursive:00000000 xQueueTakeMutexRecursive
     /tmp/cco41iGu.s:1071   .text.xQueueGenericReceive:00000000 xQueueGenericReceive
     /tmp/cco41iGu.s:527    .text.xQueueCreateCountingSemaphore:00000000 $t
     /tmp/cco41iGu.s:532    .text.xQueueCreateCountingSemaphore:00000000 xQueueCreateCountingSemaphore
     /tmp/cco41iGu.s:606    .text.xQueueGenericSend:00000000 $t
     /tmp/cco41iGu.s:1947   .text.prvCopyDataToQueue:00000000 prvCopyDataToQueue
     /tmp/cco41iGu.s:2397   .text.prvIsQueueFull:00000000 prvIsQueueFull
     /tmp/cco41iGu.s:2168   .text.prvUnlockQueue:00000000 prvUnlockQueue
     /tmp/cco41iGu.s:885    .text.xQueueGenericSendFromISR:00000000 $t
     /tmp/cco41iGu.s:890    .text.xQueueGenericSendFromISR:00000000 xQueueGenericSendFromISR
     /tmp/cco41iGu.s:1066   .text.xQueueGenericReceive:00000000 $t
     /tmp/cco41iGu.s:2100   .text.prvCopyDataFromQueue:00000000 prvCopyDataFromQueue
     /tmp/cco41iGu.s:2287   .text.prvIsQueueEmpty:00000000 prvIsQueueEmpty
     /tmp/cco41iGu.s:1364   .text.xQueueReceiveFromISR:00000000 $t
     /tmp/cco41iGu.s:1369   .text.xQueueReceiveFromISR:00000000 xQueueReceiveFromISR
     /tmp/cco41iGu.s:1505   .text.xQueuePeekFromISR:00000000 $t
     /tmp/cco41iGu.s:1510   .text.xQueuePeekFromISR:00000000 xQueuePeekFromISR
     /tmp/cco41iGu.s:1612   .text.uxQueueMessagesWaiting:00000000 $t
     /tmp/cco41iGu.s:1617   .text.uxQueueMessagesWaiting:00000000 uxQueueMessagesWaiting
     /tmp/cco41iGu.s:1664   .text.uxQueueSpacesAvailable:00000000 $t
     /tmp/cco41iGu.s:1669   .text.uxQueueSpacesAvailable:00000000 uxQueueSpacesAvailable
     /tmp/cco41iGu.s:1722   .text.uxQueueMessagesWaitingFromISR:00000000 $t
     /tmp/cco41iGu.s:1727   .text.uxQueueMessagesWaitingFromISR:00000000 uxQueueMessagesWaitingFromISR
     /tmp/cco41iGu.s:1770   .text.vQueueDelete:00000000 $t
     /tmp/cco41iGu.s:1775   .text.vQueueDelete:00000000 vQueueDelete
     /tmp/cco41iGu.s:2585   .text.vQueueUnregisterQueue:00000000 vQueueUnregisterQueue
     /tmp/cco41iGu.s:1831   .text.uxQueueGetQueueNumber:00000000 $t
     /tmp/cco41iGu.s:1836   .text.uxQueueGetQueueNumber:00000000 uxQueueGetQueueNumber
     /tmp/cco41iGu.s:1868   .text.vQueueSetQueueNumber:00000000 $t
     /tmp/cco41iGu.s:1873   .text.vQueueSetQueueNumber:00000000 vQueueSetQueueNumber
     /tmp/cco41iGu.s:1906   .text.ucQueueGetQueueType:00000000 $t
     /tmp/cco41iGu.s:1911   .text.ucQueueGetQueueType:00000000 ucQueueGetQueueType
     /tmp/cco41iGu.s:1943   .text.prvCopyDataToQueue:00000000 $t
     /tmp/cco41iGu.s:2096   .text.prvCopyDataFromQueue:00000000 $t
     /tmp/cco41iGu.s:2164   .text.prvUnlockQueue:00000000 $t
     /tmp/cco41iGu.s:2283   .text.prvIsQueueEmpty:00000000 $t
     /tmp/cco41iGu.s:2335   .text.xQueueIsQueueEmptyFromISR:00000000 $t
     /tmp/cco41iGu.s:2340   .text.xQueueIsQueueEmptyFromISR:00000000 xQueueIsQueueEmptyFromISR
     /tmp/cco41iGu.s:2393   .text.prvIsQueueFull:00000000 $t
     /tmp/cco41iGu.s:2447   .text.xQueueIsQueueFullFromISR:00000000 $t
     /tmp/cco41iGu.s:2452   .text.xQueueIsQueueFullFromISR:00000000 xQueueIsQueueFullFromISR
     /tmp/cco41iGu.s:2507   .text.vQueueAddToRegistry:00000000 $t
     /tmp/cco41iGu.s:2512   .text.vQueueAddToRegistry:00000000 vQueueAddToRegistry
     /tmp/cco41iGu.s:2580   .text.vQueueUnregisterQueue:00000000 $t
     /tmp/cco41iGu.s:2647   .text.vQueueWaitForMessageRestricted:00000000 $t
     /tmp/cco41iGu.s:2652   .text.vQueueWaitForMessageRestricted:00000000 vQueueWaitForMessageRestricted
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
ulPortSetInterruptMask
vPortEnterCritical
xTaskRemoveFromEventList
vPortYield
vListInitialise
vPortExitCritical
pvPortMalloc
vPortFree
xTaskGetCurrentTaskHandle
xTaskGetSchedulerState
vTaskSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
vPortValidateInterruptPriority
vPortClearInterruptMask
pvTaskIncrementMutexHeldCount
vTaskPriorityInherit
xTaskPriorityDisinherit
memcpy
vTaskMissedYield
vTaskPlaceOnEventListRestricted
