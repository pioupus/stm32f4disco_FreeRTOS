   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"tasks.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.global	pxCurrentTCB
  20              		.section	.bss.pxCurrentTCB,"aw",%nobits
  21              		.align	2
  24              	pxCurrentTCB:
  25 0000 00000000 		.space	4
  26              		.section	.bss.pxReadyTasksLists,"aw",%nobits
  27              		.align	2
  30              	pxReadyTasksLists:
  31 0000 00000000 		.space	100
  31      00000000 
  31      00000000 
  31      00000000 
  31      00000000 
  32              		.section	.bss.xDelayedTaskList1,"aw",%nobits
  33              		.align	2
  36              	xDelayedTaskList1:
  37 0000 00000000 		.space	20
  37      00000000 
  37      00000000 
  37      00000000 
  37      00000000 
  38              		.section	.bss.xDelayedTaskList2,"aw",%nobits
  39              		.align	2
  42              	xDelayedTaskList2:
  43 0000 00000000 		.space	20
  43      00000000 
  43      00000000 
  43      00000000 
  43      00000000 
  44              		.section	.bss.pxDelayedTaskList,"aw",%nobits
  45              		.align	2
  48              	pxDelayedTaskList:
  49 0000 00000000 		.space	4
  50              		.section	.bss.pxOverflowDelayedTaskList,"aw",%nobits
  51              		.align	2
  54              	pxOverflowDelayedTaskList:
  55 0000 00000000 		.space	4
  56              		.section	.bss.xPendingReadyList,"aw",%nobits
  57              		.align	2
  60              	xPendingReadyList:
  61 0000 00000000 		.space	20
  61      00000000 
  61      00000000 
  61      00000000 
  61      00000000 
  62              		.section	.bss.xTasksWaitingTermination,"aw",%nobits
  63              		.align	2
  66              	xTasksWaitingTermination:
  67 0000 00000000 		.space	20
  67      00000000 
  67      00000000 
  67      00000000 
  67      00000000 
  68              		.section	.bss.uxTasksDeleted,"aw",%nobits
  69              		.align	2
  72              	uxTasksDeleted:
  73 0000 00000000 		.space	4
  74              		.section	.bss.xSuspendedTaskList,"aw",%nobits
  75              		.align	2
  78              	xSuspendedTaskList:
  79 0000 00000000 		.space	20
  79      00000000 
  79      00000000 
  79      00000000 
  79      00000000 
  80              		.section	.bss.uxCurrentNumberOfTasks,"aw",%nobits
  81              		.align	2
  84              	uxCurrentNumberOfTasks:
  85 0000 00000000 		.space	4
  86              		.section	.bss.xTickCount,"aw",%nobits
  87              		.align	2
  90              	xTickCount:
  91 0000 00000000 		.space	4
  92              		.section	.bss.uxTopReadyPriority,"aw",%nobits
  93              		.align	2
  96              	uxTopReadyPriority:
  97 0000 00000000 		.space	4
  98              		.section	.bss.xSchedulerRunning,"aw",%nobits
  99              		.align	2
 102              	xSchedulerRunning:
 103 0000 00000000 		.space	4
 104              		.section	.bss.uxPendedTicks,"aw",%nobits
 105              		.align	2
 108              	uxPendedTicks:
 109 0000 00000000 		.space	4
 110              		.section	.bss.xYieldPending,"aw",%nobits
 111              		.align	2
 114              	xYieldPending:
 115 0000 00000000 		.space	4
 116              		.section	.bss.xNumOfOverflows,"aw",%nobits
 117              		.align	2
 120              	xNumOfOverflows:
 121 0000 00000000 		.space	4
 122              		.section	.bss.uxTaskNumber,"aw",%nobits
 123              		.align	2
 126              	uxTaskNumber:
 127 0000 00000000 		.space	4
 128              		.section	.data.xNextTaskUnblockTime,"aw",%progbits
 129              		.align	2
 132              	xNextTaskUnblockTime:
 133 0000 FFFFFFFF 		.word	-1
 134              		.section	.bss.uxSchedulerSuspended,"aw",%nobits
 135              		.align	2
 138              	uxSchedulerSuspended:
 139 0000 00000000 		.space	4
 140              		.section	.text.xTaskGenericCreate,"ax",%progbits
 141              		.align	2
 142              		.global	xTaskGenericCreate
 143              		.thumb
 144              		.thumb_func
 146              	xTaskGenericCreate:
 147              	.LFB1:
 148              		.file 1 "lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c"
   1:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*
   2:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****     FreeRTOS V8.1.2 - Copyright (C) 2014 Real Time Engineers Ltd.
   3:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****     All rights reserved
   4:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
   5:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
   7:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****     ***************************************************************************
   8:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****      *                                                                       *
   9:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  10:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****      *    robust, strictly quality controlled, supported, and cross          *
  11:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****      *    platform software that has become a de facto standard.             *
  12:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****      *                                                                       *
  13:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  14:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  15:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  16:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****      *                                                                       *
  17:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****      *    Thank you!                                                         *
  18:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****      *                                                                       *
  19:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****     ***************************************************************************
  20:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
  21:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****     This file is part of the FreeRTOS distribution.
  22:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
  23:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  24:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  25:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  26:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
  27:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****     >>!   NOTE: The modification to the GPL is included to allow you to     !<<
  28:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****     >>!   distribute a combined work that includes FreeRTOS without being   !<<
  29:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****     >>!   obliged to provide the source code for proprietary components     !<<
  30:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****     >>!   outside of the FreeRTOS kernel.                                   !<<
  31:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
  32:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  33:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  34:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  35:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****     link: http://www.freertos.org/a00114.html
  36:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
  37:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****     1 tab == 4 spaces!
  38:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
  39:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****     ***************************************************************************
  40:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****      *                                                                       *
  41:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  42:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****      *    not run, what could be wrong?"                                     *
  43:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****      *                                                                       *
  44:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  45:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****      *                                                                       *
  46:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****     ***************************************************************************
  47:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
  48:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  49:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****     license and Real Time Engineers Ltd. contact details.
  50:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
  51:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  52:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  53:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  54:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
  55:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  56:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  57:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****     licenses offer ticketed support, indemnification and middleware.
  58:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
  59:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  60:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****     engineered and independently SIL3 certified version for use in safety and
  61:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****     mission critical applications that require provable dependability.
  62:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
  63:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****     1 tab == 4 spaces!
  64:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** */
  65:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
  66:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /* Standard includes. */
  67:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #include <stdlib.h>
  68:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #include <string.h>
  69:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
  70:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  71:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  72:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** task.h is included from an application file. */
  73:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  74:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
  75:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /* FreeRTOS includes. */
  76:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #include "FreeRTOS.h"
  77:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #include "task.h"
  78:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #include "timers.h"
  79:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #include "StackMacros.h"
  80:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
  81:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  82:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  83:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** header files above, but not in this file, in order to generate the correct
  84:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** privileged Vs unprivileged linkage and placement. */
  85:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  86:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
  87:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
  88:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* At the bottom of this file are two optional functions that can be used
  89:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	to generate human readable text from the raw data generated by the
  90:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	uxTaskGetSystemState() function.  Note the formatting functions are provided
  91:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	for convenience only, and are NOT considered part of the kernel. */
  92:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#include <stdio.h>
  93:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
  94:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
  95:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /* Sanity check the configuration. */
  96:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if configUSE_TICKLESS_IDLE != 0
  97:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#if INCLUDE_vTaskSuspend != 1
  98:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
  99:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
 100:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
 101:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 102:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*
 103:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * Defines the size, in words, of the stack allocated to the idle task.
 104:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  */
 105:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
 106:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 107:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if( configUSE_PREEMPTION == 0 )
 108:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* If the cooperative scheduler is being used then a yield should not be
 109:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	performed just because a higher priority task has been woken. */
 110:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION()
 111:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #else
 112:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
 113:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif
 114:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 115:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*
 116:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
 117:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * and stores task state information, including a pointer to the task's context
 118:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * (the task's run time environment, including register values)
 119:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  */
 120:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** typedef struct tskTaskControlBlock
 121:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** {
 122:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the task
 123:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 124:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 125:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MU
 126:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#endif
 127:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 128:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	ListItem_t			xGenericListItem;	/*< The list that the state list item of a task is reference from d
 129:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
 130:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
 131:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	StackType_t			*pxStack;			/*< Points to the start of the stack. */
 132:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.
 133:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 134:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
 135:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		StackType_t		*pxEndOfStack;		/*< Points to the end of the stack on architectures where the stack 
 136:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#endif
 137:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 138:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 139:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		UBaseType_t 	uxCriticalNesting; 	/*< Holds the critical section nesting depth for ports that do n
 140:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#endif
 141:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 142:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 143:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It al
 144:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		UBaseType_t  	uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. 
 145:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#endif
 146:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 147:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 148:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		UBaseType_t 	uxBasePriority;		/*< The priority last assigned to the task - used by the priority i
 149:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		UBaseType_t 	uxMutexesHeld;
 150:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#endif
 151:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 152:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 153:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		TaskHookFunction_t pxTaskTag;
 154:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#endif
 155:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 156:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 157:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state
 158:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#endif
 159:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 160:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 161:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Allocate a Newlib reent structure that is specific to this task.
 162:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		Note Newlib support has been included by popular demand, but is not
 163:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
 164:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		responsible for resulting newlib operation.  User must be familiar with
 165:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		newlib and must provide system-wide implementations of the necessary
 166:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		stubs. Be warned that (at the time of writing) the current newlib design
 167:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		implements a system-wide malloc() that must be provided with locks. */
 168:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		struct 	_reent xNewLib_reent;
 169:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#endif
 170:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 171:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** } tskTCB;
 172:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 173:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
 174:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** below to enable the use of older kernel aware debuggers. */
 175:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** typedef tskTCB TCB_t;
 176:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 177:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*
 178:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to to
 179:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * be global, rather than file scope.
 180:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  */
 181:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 182:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#define static
 183:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif
 184:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 185:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*lint -e956 A manual analysis and inspection has been used to determine which
 186:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** static variables must be declared volatile. */
 187:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 188:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
 189:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 190:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 191:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks
 192:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
 193:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one f
 194:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list 
 195:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task
 196:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the sc
 197:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 198:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 199:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 200:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but 
 201:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static volatile UBaseType_t uxTasksDeleted = ( UBaseType_t ) 0U;
 202:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 203:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif
 204:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 205:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 206:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 207:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 208:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 209:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif
 210:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 211:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
 212:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 213:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle = NULL;			/*< Holds the handle of the idle tas
 214:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 215:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif
 216:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 217:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /* Other file private variables. --------------------------------*/
 218:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
 219:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) 0U;
 220:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
 221:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
 222:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
 223:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
 224:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
 225:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
 226:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= portMAX_DELAY;
 227:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 228:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /* Context switches are held pending while the scheduler is suspended.  Also,
 229:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** interrupts must not manipulate the xStateListItem of a TCB, or any of the
 230:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** lists the xStateListItem can be referenced from, if the scheduler is suspended.
 231:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** If an interrupt needs to unblock a task while the scheduler is suspended then it
 232:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** moves the task's event list item into the xPendingReadyList, ready for the
 233:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** kernel to move the task from the pending ready list into the real ready list
 234:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** when the scheduler is unsuspended.  The pending ready list itself can only be
 235:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** accessed from a critical section. */
 236:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
 237:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 238:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 239:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 240:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter
 241:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution tim
 242:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 243:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif
 244:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 245:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*lint +e956 */
 246:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 247:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 248:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 249:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*
 250:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 251:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
 252:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  */
 253:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
 254:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 255:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*
 256:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 257:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  */
 258:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #define tskBLOCKED_CHAR		( 'B' )
 259:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #define tskREADY_CHAR		( 'R' )
 260:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #define tskDELETED_CHAR		( 'D' )
 261:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #define tskSUSPENDED_CHAR	( 'S' )
 262:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 263:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 264:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 265:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
 266:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 267:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 268:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	performed in a generic way that is not optimised to any particular
 269:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	microcontroller architecture. */
 270:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 271:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* uxTopReadyPriority holds the priority of the highest priority ready
 272:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	state task. */
 273:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )														\
 274:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{																									\
 275:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( ( uxPriority ) > uxTopReadyPriority )														\
 276:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{																								\
 277:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			uxTopReadyPriority = ( uxPriority );														\
 278:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}																								\
 279:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	} /* taskRECORD_READY_PRIORITY */
 280:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 281:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 282:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 283:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
 284:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{																									\
 285:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */								\
 286:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )						\
 287:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{																								\
 288:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			configASSERT( uxTopReadyPriority );															\
 289:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			--uxTopReadyPriority;																		\
 290:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}																								\
 291:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 																										\
 292:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
 293:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		the	same priority get an equal share of the processor time. */									\
 294:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );		\
 295:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
 296:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 297:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 298:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 299:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 300:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	they are only required when a port optimised method of task selection is
 301:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	being used. */
 302:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )
 303:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 304:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 305:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 306:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 307:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 308:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	performed in a way that is tailored to the particular microcontroller
 309:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	architecture being used. */
 310:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 311:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* A port optimised version is provided.  Call the port defined macros. */
 312:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyP
 313:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 314:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 315:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 316:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
 317:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{																								\
 318:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTopPriority;																		\
 319:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 																									\
 320:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */							\
 321:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
 322:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
 323:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
 324:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 325:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 326:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 327:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 328:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* A port optimised version is provided, call it only if the TCB being reset
 329:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	is being referenced from a ready list.  If it is referenced from a delayed
 330:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	or suspended list then it won't be in a ready list. */
 331:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )														\
 332:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{																									\
 333:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
 334:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{																								\
 335:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
 336:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}																								\
 337:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
 338:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 339:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 340:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 341:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 342:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 343:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
 344:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** count overflows. */
 345:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #define taskSWITCH_DELAYED_LISTS()																	\
 346:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** {																									\
 347:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	List_t *pxTemp;																					\
 348:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 																									\
 349:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* The delayed tasks list should be empty when the lists are switched. */						\
 350:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
 351:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 																									\
 352:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	pxTemp = pxDelayedTaskList;																		\
 353:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
 354:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = pxTemp;																\
 355:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	xNumOfOverflows++;																				\
 356:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	prvResetNextTaskUnblockTime();																	\
 357:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** }
 358:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 359:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 360:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 361:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*
 362:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready list for
 363:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * the task.  It is inserted at the end of the list.
 364:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  */
 365:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #define prvAddTaskToReadyList( pxTCB )																\
 366:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	traceMOVED_TASK_TO_READY_STATE( pxTCB )															\
 367:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
 368:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) 
 369:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 370:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 371:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*
 372:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * Several functions take an TaskHandle_t parameter that can optionally be NULL,
 373:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 374:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 375:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 376:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  */
 377:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( TCB_t * ) pxCurrentTCB : ( T
 378:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 379:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /* The item value of the event list item is normally used to hold the priority
 380:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** of the task to which it belongs (coded to allow it to be held in reverse
 381:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** priority order).  However, it is occasionally borrowed for other purposes.  It
 382:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** is important its value is not updated due to a task priority change while it is
 383:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** being used for another purpose.  The following bit definition is used to inform
 384:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** the scheduler that the value should not be changed - in which case it is the
 385:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** responsibility of whichever module is using the value to ensure it gets set back
 386:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** to its original value when it is released. */
 387:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if configUSE_16_BIT_TICKS == 1
 388:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
 389:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #else
 390:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
 391:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif
 392:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 393:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /* Callback function prototypes. --------------------------*/
 394:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if configCHECK_FOR_STACK_OVERFLOW > 0
 395:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
 396:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif
 397:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 398:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if configUSE_TICK_HOOK > 0
 399:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	extern void vApplicationTickHook( void );
 400:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif
 401:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 402:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /* File private functions. --------------------------------*/
 403:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 404:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*
 405:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 406:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * into the TCB structure.
 407:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  */
 408:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t 
 409:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 410:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /**
 411:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * Utility task that simply returns pdTRUE if the task referenced by xTask is
 412:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * currently in the Suspended state, or pdFALSE if the task referenced by xTask
 413:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * is in any other state.
 414:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  */
 415:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
 416:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 417:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*
 418:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 419:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * automatically upon the creation of the first task.
 420:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  */
 421:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 422:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 423:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*
 424:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 425:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 426:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * creation of the first user task.
 427:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  *
 428:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 429:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 430:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  *
 431:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 432:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  *
 433:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  */
 434:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 435:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 436:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*
 437:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 438:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * including the stack pointed to by the TCB.
 439:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  *
 440:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 441:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 442:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  */
 443:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 444:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 445:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
 446:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 447:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif
 448:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 449:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*
 450:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 451:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 452:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * and its TCB deleted.
 453:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  */
 454:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 455:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 456:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*
 457:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 458:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * either the current or the overflow delayed task list.
 459:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  */
 460:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake ) PRIVILEGED_FUNCTION;
 461:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 462:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*
 463:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 464:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * allocation was successful.
 465:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  */
 466:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuff
 467:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 468:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*
 469:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * Fills an TaskStatus_t structure with information on each task that is
 470:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * referenced from the pxList list (which may be a ready list, a delayed list,
 471:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * a suspended list, etc.).
 472:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  *
 473:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 474:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * NORMAL APPLICATION CODE.
 475:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  */
 476:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 477:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 478:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, e
 479:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 480:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif
 481:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 482:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*
 483:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 484:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 485:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 486:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  */
 487:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 488:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 489:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
 490:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 491:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif
 492:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 493:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*
 494:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 495:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * next move a task from the Blocked state to the Running state.
 496:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  *
 497:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 498:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 499:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 500:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * set to a value other than 1.
 501:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  */
 502:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 503:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 504:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 505:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 506:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif
 507:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 508:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*
 509:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * Set xNextTaskUnblockTime to the time at which the next Blocked state task
 510:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * will exit the Blocked state.
 511:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  */
 512:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** static void prvResetNextTaskUnblockTime( void );
 513:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 514:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 515:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 516:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t
 517:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** {
 149              		.loc 1 517 0
 150              		.cfi_startproc
 151              		@ args = 16, pretend = 0, frame = 32
 152              		@ frame_needed = 1, uses_anonymous_args = 0
 153 0000 80B5     		push	{r7, lr}
 154              	.LCFI0:
 155              		.cfi_def_cfa_offset 8
 156              		.cfi_offset 7, -8
 157              		.cfi_offset 14, -4
 158 0002 8AB0     		sub	sp, sp, #40
 159              	.LCFI1:
 160              		.cfi_def_cfa_offset 48
 161 0004 02AF     		add	r7, sp, #8
 162              	.LCFI2:
 163              		.cfi_def_cfa 7, 40
 164 0006 F860     		str	r0, [r7, #12]
 165 0008 B960     		str	r1, [r7, #8]
 166 000a 3B60     		str	r3, [r7]
 167 000c 1346     		mov	r3, r2	@ movhi
 168 000e FB80     		strh	r3, [r7, #6]	@ movhi
 518:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
 519:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** TCB_t * pxNewTCB;
 520:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 521:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	configASSERT( pxTaskCode );
 169              		.loc 1 521 0
 170 0010 FB68     		ldr	r3, [r7, #12]
 171 0012 002B     		cmp	r3, #0
 172 0014 02D1     		bne	.L2
 173              		.loc 1 521 0 is_stmt 0 discriminator 1
 174 0016 FFF7FEFF 		bl	ulPortSetInterruptMask
 175              	.L3:
 176 001a FEE7     		b	.L3
 177              	.L2:
 522:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
 178              		.loc 1 522 0 is_stmt 1
 179 001c BB6A     		ldr	r3, [r7, #40]
 180 001e 042B     		cmp	r3, #4
 181 0020 02D9     		bls	.L4
 182              		.loc 1 522 0 is_stmt 0 discriminator 1
 183 0022 FFF7FEFF 		bl	ulPortSetInterruptMask
 184              	.L5:
 185 0026 FEE7     		b	.L5
 186              	.L4:
 523:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 524:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* Allocate the memory required by the TCB and stack for the new task,
 525:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	checking that the allocation was successful. */
 526:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 187              		.loc 1 526 0 is_stmt 1
 188 0028 FB88     		ldrh	r3, [r7, #6]
 189 002a 1846     		mov	r0, r3
 190 002c 396B     		ldr	r1, [r7, #48]
 191 002e FFF7FEFF 		bl	prvAllocateTCBAndStack
 192 0032 B861     		str	r0, [r7, #24]
 527:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 528:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	if( pxNewTCB != NULL )
 193              		.loc 1 528 0
 194 0034 BB69     		ldr	r3, [r7, #24]
 195 0036 002B     		cmp	r3, #0
 196 0038 00F09C80 		beq	.L6
 197              	.LBB7:
 529:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
 530:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		StackType_t *pxTopOfStack;
 531:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 532:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 533:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Should the task be created in privileged mode? */
 534:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			BaseType_t xRunPrivileged;
 535:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 536:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
 537:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				xRunPrivileged = pdTRUE;
 538:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
 539:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			else
 540:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
 541:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				xRunPrivileged = pdFALSE;
 542:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
 543:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			uxPriority &= ~portPRIVILEGE_BIT;
 544:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 545:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 546:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Calculate the top of stack address.  This depends on whether the
 547:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		stack grows from high memory to low (as per the 80x86) or vice versa.
 548:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		portSTACK_GROWTH is used to make the result positive or negative as
 549:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		required by the port. */
 550:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#if( portSTACK_GROWTH < 0 )
 551:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
 552:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
 198              		.loc 1 552 0
 199 003c BB69     		ldr	r3, [r7, #24]
 200 003e 1A6B     		ldr	r2, [r3, #48]
 201 0040 FB88     		ldrh	r3, [r7, #6]
 202 0042 03F18043 		add	r3, r3, #1073741824
 203 0046 013B     		subs	r3, r3, #1
 204 0048 9B00     		lsls	r3, r3, #2
 205 004a 1344     		add	r3, r3, r2
 206 004c 7B61     		str	r3, [r7, #20]
 553:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_
 207              		.loc 1 553 0
 208 004e 7B69     		ldr	r3, [r7, #20]
 209 0050 23F00703 		bic	r3, r3, #7
 210 0054 7B61     		str	r3, [r7, #20]
 554:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 555:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Check the alignment of the calculated top of stack is correct. */
 556:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_AL
 211              		.loc 1 556 0
 212 0056 7B69     		ldr	r3, [r7, #20]
 213 0058 03F00703 		and	r3, r3, #7
 214 005c 002B     		cmp	r3, #0
 215 005e 02D0     		beq	.L7
 216              		.loc 1 556 0 is_stmt 0 discriminator 1
 217 0060 FFF7FEFF 		bl	ulPortSetInterruptMask
 218              	.L8:
 219 0064 FEE7     		b	.L8
 220              	.L7:
 557:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
 558:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#else /* portSTACK_GROWTH */
 559:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
 560:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack;
 561:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 562:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Check the alignment of the stack buffer is correct. */
 563:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBY
 564:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 565:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* If we want to use stack checking on architectures that use
 566:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			a positive stack growth direction then we also need to store the
 567:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			other extreme of the stack space. */
 568:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 569:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
 570:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#endif /* portSTACK_GROWTH */
 571:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 572:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 573:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 221              		.loc 1 573 0 is_stmt 1
 222 0066 FB88     		ldrh	r3, [r7, #6]
 223 0068 0093     		str	r3, [sp]
 224 006a B869     		ldr	r0, [r7, #24]
 225 006c B968     		ldr	r1, [r7, #8]
 226 006e BA6A     		ldr	r2, [r7, #40]
 227 0070 7B6B     		ldr	r3, [r7, #52]
 228 0072 FFF7FEFF 		bl	prvInitialiseTCBVariables
 574:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 575:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Initialize the TCB stack to look as if the task was already running,
 576:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		but had been interrupted by the scheduler.  The return address is set
 577:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		to the start of the task function. Once the stack has been initialised
 578:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		the	top of stack variable is updated. */
 579:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 580:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
 581:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 582:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
 583:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#else /* portUSING_MPU_WRAPPERS */
 584:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
 585:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 229              		.loc 1 585 0
 230 0076 7869     		ldr	r0, [r7, #20]
 231 0078 F968     		ldr	r1, [r7, #12]
 232 007a 3A68     		ldr	r2, [r7]
 233 007c FFF7FEFF 		bl	pxPortInitialiseStack
 234 0080 0246     		mov	r2, r0
 235 0082 BB69     		ldr	r3, [r7, #24]
 236 0084 1A60     		str	r2, [r3]
 586:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
 587:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS */
 588:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 589:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 237              		.loc 1 589 0
 238 0086 FB6A     		ldr	r3, [r7, #44]
 239 0088 002B     		cmp	r3, #0
 240 008a 02D0     		beq	.L9
 590:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
 591:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 592:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			task can use this as a handle to delete the task later if
 593:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			required.*/
 594:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 241              		.loc 1 594 0
 242 008c FB6A     		ldr	r3, [r7, #44]
 243 008e BA69     		ldr	r2, [r7, #24]
 244 0090 1A60     		str	r2, [r3]
 245              	.L9:
 595:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
 596:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
 597:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
 598:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 599:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
 600:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 601:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Ensure interrupts don't access the task lists while they are being
 602:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		updated. */
 603:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 246              		.loc 1 603 0
 247 0092 FFF7FEFF 		bl	vPortEnterCritical
 604:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
 605:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			uxCurrentNumberOfTasks++;
 248              		.loc 1 605 0
 249 0096 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 250 009a C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 251 009e 1B68     		ldr	r3, [r3]
 252 00a0 5A1C     		adds	r2, r3, #1
 253 00a2 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 254 00a6 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 255 00aa 1A60     		str	r2, [r3]
 606:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 256              		.loc 1 606 0
 257 00ac 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 258 00b0 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 259 00b4 1B68     		ldr	r3, [r3]
 260 00b6 002B     		cmp	r3, #0
 261 00b8 0FD1     		bne	.L10
 607:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
 608:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* There are no other tasks, or all the other tasks are in
 609:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				the suspended state - make this the current task. */
 610:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 262              		.loc 1 610 0
 263 00ba 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 264 00be C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 265 00c2 BA69     		ldr	r2, [r7, #24]
 266 00c4 1A60     		str	r2, [r3]
 611:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 612:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 267              		.loc 1 612 0
 268 00c6 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 269 00ca C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 270 00ce 1B68     		ldr	r3, [r3]
 271 00d0 012B     		cmp	r3, #1
 272 00d2 18D1     		bne	.L11
 613:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
 614:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					/* This is the first task to be created so do the preliminary
 615:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					initialisation required.  We will not recover if this call
 616:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					fails, but we will report the failure. */
 617:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					prvInitialiseTaskLists();
 273              		.loc 1 617 0
 274 00d4 FFF7FEFF 		bl	prvInitialiseTaskLists
 275 00d8 15E0     		b	.L11
 276              	.L10:
 618:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
 619:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				else
 620:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
 621:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 622:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
 623:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
 624:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			else
 625:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
 626:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* If the scheduler is not already running, make this task the
 627:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				current task if it is the highest priority task to be created
 628:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				so far. */
 629:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 277              		.loc 1 629 0
 278 00da 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 279 00de C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 280 00e2 1B68     		ldr	r3, [r3]
 281 00e4 002B     		cmp	r3, #0
 282 00e6 0ED1     		bne	.L11
 630:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
 631:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 283              		.loc 1 631 0
 284 00e8 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 285 00ec C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 286 00f0 1B68     		ldr	r3, [r3]
 287 00f2 DA6A     		ldr	r2, [r3, #44]
 288 00f4 BB6A     		ldr	r3, [r7, #40]
 289 00f6 9A42     		cmp	r2, r3
 290 00f8 05D8     		bhi	.L11
 632:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					{
 633:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 291              		.loc 1 633 0
 292 00fa 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 293 00fe C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 294 0102 BA69     		ldr	r2, [r7, #24]
 295 0104 1A60     		str	r2, [r3]
 296              	.L11:
 634:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					}
 635:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					else
 636:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					{
 637:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
 638:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					}
 639:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
 640:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				else
 641:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
 642:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 643:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
 644:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
 645:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 646:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
 297              		.loc 1 646 0 discriminator 2
 298 0106 40F20003 		movw	r3, #:lower16:uxTaskNumber
 299 010a C0F20003 		movt	r3, #:upper16:uxTaskNumber
 300 010e 1B68     		ldr	r3, [r3]
 301 0110 5A1C     		adds	r2, r3, #1
 302 0112 40F20003 		movw	r3, #:lower16:uxTaskNumber
 303 0116 C0F20003 		movt	r3, #:upper16:uxTaskNumber
 304 011a 1A60     		str	r2, [r3]
 647:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 648:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 649:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
 650:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* Add a counter into the TCB for tracing only. */
 651:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 305              		.loc 1 651 0 discriminator 2
 306 011c 40F20003 		movw	r3, #:lower16:uxTaskNumber
 307 0120 C0F20003 		movt	r3, #:upper16:uxTaskNumber
 308 0124 1A68     		ldr	r2, [r3]
 309 0126 BB69     		ldr	r3, [r7, #24]
 310 0128 1A64     		str	r2, [r3, #64]
 652:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
 653:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			#endif /* configUSE_TRACE_FACILITY */
 654:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 655:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 656:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			prvAddTaskToReadyList( pxNewTCB );
 311              		.loc 1 656 0 discriminator 2
 312 012a BB69     		ldr	r3, [r7, #24]
 313 012c DB6A     		ldr	r3, [r3, #44]
 314 012e 0122     		movs	r2, #1
 315 0130 9A40     		lsls	r2, r2, r3
 316 0132 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 317 0136 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 318 013a 1B68     		ldr	r3, [r3]
 319 013c 1A43     		orrs	r2, r2, r3
 320 013e 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 321 0142 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 322 0146 1A60     		str	r2, [r3]
 323 0148 BB69     		ldr	r3, [r7, #24]
 324 014a DA6A     		ldr	r2, [r3, #44]
 325 014c 1346     		mov	r3, r2
 326 014e 9B00     		lsls	r3, r3, #2
 327 0150 1344     		add	r3, r3, r2
 328 0152 9B00     		lsls	r3, r3, #2
 329 0154 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 330 0158 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 331 015c 1A44     		add	r2, r2, r3
 332 015e BB69     		ldr	r3, [r7, #24]
 333 0160 0433     		adds	r3, r3, #4
 334 0162 1046     		mov	r0, r2
 335 0164 1946     		mov	r1, r3
 336 0166 FFF7FEFF 		bl	vListInsertEnd
 657:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 658:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			xReturn = pdPASS;
 337              		.loc 1 658 0 discriminator 2
 338 016a 0123     		movs	r3, #1
 339 016c FB61     		str	r3, [r7, #28]
 659:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			portSETUP_TCB( pxNewTCB );
 660:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
 661:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 340              		.loc 1 661 0 discriminator 2
 341 016e FFF7FEFF 		bl	vPortExitCritical
 342              	.LBE7:
 343 0172 02E0     		b	.L12
 344              	.L6:
 662:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
 663:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	else
 664:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
 665:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 345              		.loc 1 665 0
 346 0174 4FF0FF33 		mov	r3, #-1
 347 0178 FB61     		str	r3, [r7, #28]
 348              	.L12:
 666:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		traceTASK_CREATE_FAILED();
 667:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
 668:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 669:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
 349              		.loc 1 669 0
 350 017a FB69     		ldr	r3, [r7, #28]
 351 017c 012B     		cmp	r3, #1
 352 017e 11D1     		bne	.L13
 670:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
 671:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 353              		.loc 1 671 0
 354 0180 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 355 0184 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 356 0188 1B68     		ldr	r3, [r3]
 357 018a 002B     		cmp	r3, #0
 358 018c 0AD0     		beq	.L13
 672:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
 673:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* If the created task is of a higher priority than the current task
 674:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			then it should run now. */
 675:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 359              		.loc 1 675 0
 360 018e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 361 0192 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 362 0196 1B68     		ldr	r3, [r3]
 363 0198 DA6A     		ldr	r2, [r3, #44]
 364 019a BB6A     		ldr	r3, [r7, #40]
 365 019c 9A42     		cmp	r2, r3
 366 019e 01D2     		bcs	.L13
 676:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
 677:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				taskYIELD_IF_USING_PREEMPTION();
 367              		.loc 1 677 0
 368 01a0 FFF7FEFF 		bl	vPortYield
 369              	.L13:
 678:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
 679:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			else
 680:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
 681:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 682:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
 683:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
 684:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
 685:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
 686:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 687:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
 688:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
 689:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 690:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	return xReturn;
 370              		.loc 1 690 0
 371 01a4 FB69     		ldr	r3, [r7, #28]
 691:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** }
 372              		.loc 1 691 0
 373 01a6 1846     		mov	r0, r3
 374 01a8 2037     		adds	r7, r7, #32
 375 01aa BD46     		mov	sp, r7
 376              		@ sp needed
 377 01ac 80BD     		pop	{r7, pc}
 378              		.cfi_endproc
 379              	.LFE1:
 381 01ae 00BF     		.section	.text.vTaskDelete,"ax",%progbits
 382              		.align	2
 383              		.global	vTaskDelete
 384              		.thumb
 385              		.thumb_func
 387              	vTaskDelete:
 388              	.LFB2:
 692:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 693:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 694:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 695:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 696:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	void vTaskDelete( TaskHandle_t xTaskToDelete )
 697:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
 389              		.loc 1 697 0
 390              		.cfi_startproc
 391              		@ args = 0, pretend = 0, frame = 16
 392              		@ frame_needed = 1, uses_anonymous_args = 0
 393 0000 80B5     		push	{r7, lr}
 394              	.LCFI3:
 395              		.cfi_def_cfa_offset 8
 396              		.cfi_offset 7, -8
 397              		.cfi_offset 14, -4
 398 0002 84B0     		sub	sp, sp, #16
 399              	.LCFI4:
 400              		.cfi_def_cfa_offset 24
 401 0004 00AF     		add	r7, sp, #0
 402              	.LCFI5:
 403              		.cfi_def_cfa_register 7
 404 0006 7860     		str	r0, [r7, #4]
 698:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 699:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 700:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 405              		.loc 1 700 0
 406 0008 FFF7FEFF 		bl	vPortEnterCritical
 701:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
 702:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the calling task that is
 703:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			being deleted. */
 704:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 407              		.loc 1 704 0
 408 000c 7B68     		ldr	r3, [r7, #4]
 409 000e 002B     		cmp	r3, #0
 410 0010 05D1     		bne	.L16
 411              		.loc 1 704 0 is_stmt 0 discriminator 1
 412 0012 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 413 0016 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 414 001a 1B68     		ldr	r3, [r3]
 415 001c 00E0     		b	.L17
 416              	.L16:
 417              		.loc 1 704 0 discriminator 2
 418 001e 7B68     		ldr	r3, [r7, #4]
 419              	.L17:
 420              		.loc 1 704 0 discriminator 3
 421 0020 FB60     		str	r3, [r7, #12]
 705:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 706:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready list and place in the	termination list.
 707:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			This will stop the task from be scheduled.  The idle task will check
 708:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			the termination list and free up any memory allocated by the
 709:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			scheduler for the TCB and stack. */
 710:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 422              		.loc 1 710 0 is_stmt 1 discriminator 3
 423 0022 FB68     		ldr	r3, [r7, #12]
 424 0024 0433     		adds	r3, r3, #4
 425 0026 1846     		mov	r0, r3
 426 0028 FFF7FEFF 		bl	uxListRemove
 427 002c 0346     		mov	r3, r0
 428 002e 002B     		cmp	r3, #0
 429 0030 1ED1     		bne	.L18
 711:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
 712:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 430              		.loc 1 712 0
 431 0032 FB68     		ldr	r3, [r7, #12]
 432 0034 D96A     		ldr	r1, [r3, #44]
 433 0036 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 434 003a C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 435 003e 0B46     		mov	r3, r1
 436 0040 9B00     		lsls	r3, r3, #2
 437 0042 0B44     		add	r3, r3, r1
 438 0044 9B00     		lsls	r3, r3, #2
 439 0046 1344     		add	r3, r3, r2
 440 0048 1B68     		ldr	r3, [r3]
 441 004a 002B     		cmp	r3, #0
 442 004c 10D1     		bne	.L18
 443              		.loc 1 712 0 is_stmt 0 discriminator 1
 444 004e FB68     		ldr	r3, [r7, #12]
 445 0050 DB6A     		ldr	r3, [r3, #44]
 446 0052 0122     		movs	r2, #1
 447 0054 02FA03F3 		lsl	r3, r2, r3
 448 0058 DA43     		mvns	r2, r3
 449 005a 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 450 005e C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 451 0062 1B68     		ldr	r3, [r3]
 452 0064 1A40     		ands	r2, r2, r3
 453 0066 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 454 006a C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 455 006e 1A60     		str	r2, [r3]
 456              	.L18:
 713:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
 714:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			else
 715:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
 716:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 717:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
 718:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 719:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
 720:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 457              		.loc 1 720 0 is_stmt 1
 458 0070 FB68     		ldr	r3, [r7, #12]
 459 0072 9B6A     		ldr	r3, [r3, #40]
 460 0074 002B     		cmp	r3, #0
 461 0076 04D0     		beq	.L20
 721:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
 722:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 462              		.loc 1 722 0
 463 0078 FB68     		ldr	r3, [r7, #12]
 464 007a 1833     		adds	r3, r3, #24
 465 007c 1846     		mov	r0, r3
 466 007e FFF7FEFF 		bl	uxListRemove
 467              	.L20:
 723:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
 724:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			else
 725:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
 726:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 727:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
 728:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 729:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 468              		.loc 1 729 0
 469 0082 FB68     		ldr	r3, [r7, #12]
 470 0084 0433     		adds	r3, r3, #4
 471 0086 40F20000 		movw	r0, #:lower16:xTasksWaitingTermination
 472 008a C0F20000 		movt	r0, #:upper16:xTasksWaitingTermination
 473 008e 1946     		mov	r1, r3
 474 0090 FFF7FEFF 		bl	vListInsertEnd
 730:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 731:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 732:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			there is a task that has been deleted and that it should therefore
 733:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			check the xTasksWaitingTermination list. */
 734:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			++uxTasksDeleted;
 475              		.loc 1 734 0
 476 0094 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 477 0098 C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 478 009c 1B68     		ldr	r3, [r3]
 479 009e 5A1C     		adds	r2, r3, #1
 480 00a0 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 481 00a4 C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 482 00a8 1A60     		str	r2, [r3]
 735:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 736:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 737:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			can detect that the task lists need re-generating. */
 738:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
 483              		.loc 1 738 0
 484 00aa 40F20003 		movw	r3, #:lower16:uxTaskNumber
 485 00ae C0F20003 		movt	r3, #:upper16:uxTaskNumber
 486 00b2 1B68     		ldr	r3, [r3]
 487 00b4 5A1C     		adds	r2, r3, #1
 488 00b6 40F20003 		movw	r3, #:lower16:uxTaskNumber
 489 00ba C0F20003 		movt	r3, #:upper16:uxTaskNumber
 490 00be 1A60     		str	r2, [r3]
 739:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 740:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			traceTASK_DELETE( pxTCB );
 741:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
 742:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 491              		.loc 1 742 0
 492 00c0 FFF7FEFF 		bl	vPortExitCritical
 743:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 744:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if it is the currently running task that has just
 745:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		been deleted. */
 746:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 493              		.loc 1 746 0
 494 00c4 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 495 00c8 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 496 00cc 1B68     		ldr	r3, [r3]
 497 00ce 002B     		cmp	r3, #0
 498 00d0 1AD0     		beq	.L15
 747:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
 748:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
 499              		.loc 1 748 0
 500 00d2 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 501 00d6 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 502 00da 1B68     		ldr	r3, [r3]
 503 00dc FA68     		ldr	r2, [r7, #12]
 504 00de 9A42     		cmp	r2, r3
 505 00e0 0CD1     		bne	.L22
 749:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
 750:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
 506              		.loc 1 750 0
 507 00e2 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 508 00e6 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 509 00ea 1B68     		ldr	r3, [r3]
 510 00ec 002B     		cmp	r3, #0
 511 00ee 02D0     		beq	.L23
 512              		.loc 1 750 0 is_stmt 0 discriminator 1
 513 00f0 FFF7FEFF 		bl	ulPortSetInterruptMask
 514              	.L24:
 515 00f4 FEE7     		b	.L24
 516              	.L23:
 751:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 752:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* The pre-delete hook is primarily for the Windows simulator,
 753:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				in which Windows specific clean up operations are performed,
 754:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				after which it is not possible to yield away from this task -
 755:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				hence xYieldPending is used to latch that a context switch is
 756:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				required. */
 757:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
 758:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 517              		.loc 1 758 0 is_stmt 1
 518 00f6 FFF7FEFF 		bl	vPortYield
 519 00fa 05E0     		b	.L15
 520              	.L22:
 759:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
 760:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			else
 761:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
 762:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* Reset the next expected unblock time in case it referred to
 763:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				the task that has just been deleted. */
 764:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				taskENTER_CRITICAL();
 521              		.loc 1 764 0
 522 00fc FFF7FEFF 		bl	vPortEnterCritical
 765:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
 766:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					prvResetNextTaskUnblockTime();
 523              		.loc 1 766 0
 524 0100 FFF7FEFF 		bl	prvResetNextTaskUnblockTime
 767:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
 768:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				taskEXIT_CRITICAL();
 525              		.loc 1 768 0
 526 0104 FFF7FEFF 		bl	vPortExitCritical
 527              	.L15:
 769:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
 770:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
 771:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
 528              		.loc 1 771 0
 529 0108 1037     		adds	r7, r7, #16
 530 010a BD46     		mov	sp, r7
 531              		@ sp needed
 532 010c 80BD     		pop	{r7, pc}
 533              		.cfi_endproc
 534              	.LFE2:
 536 010e 00BF     		.section	.text.vTaskDelayUntil,"ax",%progbits
 537              		.align	2
 538              		.global	vTaskDelayUntil
 539              		.thumb
 540              		.thumb_func
 542              	vTaskDelayUntil:
 543              	.LFB3:
 772:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 773:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
 774:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 775:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 776:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 777:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 778:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
 779:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
 544              		.loc 1 779 0
 545              		.cfi_startproc
 546              		@ args = 0, pretend = 0, frame = 24
 547              		@ frame_needed = 1, uses_anonymous_args = 0
 548 0000 80B5     		push	{r7, lr}
 549              	.LCFI6:
 550              		.cfi_def_cfa_offset 8
 551              		.cfi_offset 7, -8
 552              		.cfi_offset 14, -4
 553 0002 86B0     		sub	sp, sp, #24
 554              	.LCFI7:
 555              		.cfi_def_cfa_offset 32
 556 0004 00AF     		add	r7, sp, #0
 557              	.LCFI8:
 558              		.cfi_def_cfa_register 7
 559 0006 7860     		str	r0, [r7, #4]
 560 0008 3960     		str	r1, [r7]
 780:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
 781:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 561              		.loc 1 781 0
 562 000a 0023     		movs	r3, #0
 563 000c 7B61     		str	r3, [r7, #20]
 782:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 783:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		configASSERT( pxPreviousWakeTime );
 564              		.loc 1 783 0
 565 000e 7B68     		ldr	r3, [r7, #4]
 566 0010 002B     		cmp	r3, #0
 567 0012 02D1     		bne	.L26
 568              		.loc 1 783 0 is_stmt 0 discriminator 1
 569 0014 FFF7FEFF 		bl	ulPortSetInterruptMask
 570              	.L27:
 571 0018 FEE7     		b	.L27
 572              	.L26:
 784:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 573              		.loc 1 784 0 is_stmt 1
 574 001a 3B68     		ldr	r3, [r7]
 575 001c 002B     		cmp	r3, #0
 576 001e 02D1     		bne	.L28
 577              		.loc 1 784 0 is_stmt 0 discriminator 1
 578 0020 FFF7FEFF 		bl	ulPortSetInterruptMask
 579              	.L29:
 580 0024 FEE7     		b	.L29
 581              	.L28:
 785:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		configASSERT( uxSchedulerSuspended == 0 );
 582              		.loc 1 785 0 is_stmt 1
 583 0026 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 584 002a C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 585 002e 1B68     		ldr	r3, [r3]
 586 0030 002B     		cmp	r3, #0
 587 0032 02D0     		beq	.L30
 588              		.loc 1 785 0 is_stmt 0 discriminator 1
 589 0034 FFF7FEFF 		bl	ulPortSetInterruptMask
 590              	.L31:
 591 0038 FEE7     		b	.L31
 592              	.L30:
 786:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 787:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
 593              		.loc 1 787 0 is_stmt 1
 594 003a FFF7FEFF 		bl	vTaskSuspendAll
 595              	.LBB8:
 788:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
 789:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
 790:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			block. */
 791:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			const TickType_t xConstTickCount = xTickCount;
 596              		.loc 1 791 0
 597 003e 40F20003 		movw	r3, #:lower16:xTickCount
 598 0042 C0F20003 		movt	r3, #:upper16:xTickCount
 599 0046 1B68     		ldr	r3, [r3]
 600 0048 3B61     		str	r3, [r7, #16]
 792:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 793:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
 794:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 601              		.loc 1 794 0
 602 004a 7B68     		ldr	r3, [r7, #4]
 603 004c 1A68     		ldr	r2, [r3]
 604 004e 3B68     		ldr	r3, [r7]
 605 0050 1344     		add	r3, r3, r2
 606 0052 FB60     		str	r3, [r7, #12]
 795:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 796:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			if( xConstTickCount < *pxPreviousWakeTime )
 607              		.loc 1 796 0
 608 0054 7B68     		ldr	r3, [r7, #4]
 609 0056 1A68     		ldr	r2, [r3]
 610 0058 3B69     		ldr	r3, [r7, #16]
 611 005a 9A42     		cmp	r2, r3
 612 005c 0BD9     		bls	.L32
 797:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
 798:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* The tick count has overflowed since this function was
 799:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				lasted called.  In this case the only time we should ever
 800:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
 801:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
 802:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
 803:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 613              		.loc 1 803 0
 614 005e 7B68     		ldr	r3, [r7, #4]
 615 0060 1A68     		ldr	r2, [r3]
 616 0062 FB68     		ldr	r3, [r7, #12]
 617 0064 9A42     		cmp	r2, r3
 618 0066 11D9     		bls	.L33
 619              		.loc 1 803 0 is_stmt 0 discriminator 1
 620 0068 FA68     		ldr	r2, [r7, #12]
 621 006a 3B69     		ldr	r3, [r7, #16]
 622 006c 9A42     		cmp	r2, r3
 623 006e 0DD9     		bls	.L33
 804:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
 805:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 624              		.loc 1 805 0 is_stmt 1
 625 0070 0123     		movs	r3, #1
 626 0072 7B61     		str	r3, [r7, #20]
 627 0074 0AE0     		b	.L33
 628              	.L32:
 806:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
 807:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				else
 808:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
 809:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 810:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
 811:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
 812:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			else
 813:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
 814:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
 815:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
 816:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				tick time is less than the wake time. */
 817:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 629              		.loc 1 817 0
 630 0076 7B68     		ldr	r3, [r7, #4]
 631 0078 1A68     		ldr	r2, [r3]
 632 007a FB68     		ldr	r3, [r7, #12]
 633 007c 9A42     		cmp	r2, r3
 634 007e 03D8     		bhi	.L34
 635              		.loc 1 817 0 is_stmt 0 discriminator 1
 636 0080 FA68     		ldr	r2, [r7, #12]
 637 0082 3B69     		ldr	r3, [r7, #16]
 638 0084 9A42     		cmp	r2, r3
 639 0086 01D9     		bls	.L33
 640              	.L34:
 818:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
 819:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 641              		.loc 1 819 0 is_stmt 1
 642 0088 0123     		movs	r3, #1
 643 008a 7B61     		str	r3, [r7, #20]
 644              	.L33:
 820:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
 821:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				else
 822:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
 823:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 824:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
 825:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
 826:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 827:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Update the wake time ready for the next call. */
 828:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 645              		.loc 1 828 0
 646 008c 7B68     		ldr	r3, [r7, #4]
 647 008e FA68     		ldr	r2, [r7, #12]
 648 0090 1A60     		str	r2, [r3]
 829:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 830:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			if( xShouldDelay != pdFALSE )
 649              		.loc 1 830 0
 650 0092 7B69     		ldr	r3, [r7, #20]
 651 0094 002B     		cmp	r3, #0
 652 0096 23D0     		beq	.L35
 831:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
 832:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY_UNTIL();
 833:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 834:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* Remove the task from the ready list before adding it to the
 835:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				blocked list as the same list item is used for both lists. */
 836:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 653              		.loc 1 836 0
 654 0098 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 655 009c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 656 00a0 1B68     		ldr	r3, [r3]
 657 00a2 0433     		adds	r3, r3, #4
 658 00a4 1846     		mov	r0, r3
 659 00a6 FFF7FEFF 		bl	uxListRemove
 660 00aa 0346     		mov	r3, r0
 661 00ac 002B     		cmp	r3, #0
 662 00ae 14D1     		bne	.L36
 837:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
 838:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					/* The current task must be in a ready list, so there is
 839:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					no need to check, and the port reset macro can be called
 840:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					directly. */
 841:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 663              		.loc 1 841 0
 664 00b0 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 665 00b4 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 666 00b8 1B68     		ldr	r3, [r3]
 667 00ba DB6A     		ldr	r3, [r3, #44]
 668 00bc 0122     		movs	r2, #1
 669 00be 02FA03F3 		lsl	r3, r2, r3
 670 00c2 DA43     		mvns	r2, r3
 671 00c4 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 672 00c8 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 673 00cc 1B68     		ldr	r3, [r3]
 674 00ce 1A40     		ands	r2, r2, r3
 675 00d0 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 676 00d4 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 677 00d8 1A60     		str	r2, [r3]
 678              	.L36:
 842:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
 843:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				else
 844:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
 845:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 846:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
 847:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 848:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 679              		.loc 1 848 0 discriminator 2
 680 00da F868     		ldr	r0, [r7, #12]
 681 00dc FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 682              	.L35:
 683              	.LBE8:
 849:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
 850:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			else
 851:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
 852:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 853:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
 854:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
 855:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 684              		.loc 1 855 0
 685 00e0 FFF7FEFF 		bl	xTaskResumeAll
 686 00e4 B860     		str	r0, [r7, #8]
 856:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 857:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 858:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
 859:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 687              		.loc 1 859 0
 688 00e6 BB68     		ldr	r3, [r7, #8]
 689 00e8 002B     		cmp	r3, #0
 690 00ea 01D1     		bne	.L25
 860:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
 861:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
 691              		.loc 1 861 0
 692 00ec FFF7FEFF 		bl	vPortYield
 693              	.L25:
 862:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
 863:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
 864:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
 865:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 866:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
 867:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
 694              		.loc 1 867 0
 695 00f0 1837     		adds	r7, r7, #24
 696 00f2 BD46     		mov	sp, r7
 697              		@ sp needed
 698 00f4 80BD     		pop	{r7, pc}
 699              		.cfi_endproc
 700              	.LFE3:
 702 00f6 00BF     		.section	.text.vTaskDelay,"ax",%progbits
 703              		.align	2
 704              		.global	vTaskDelay
 705              		.thumb
 706              		.thumb_func
 708              	vTaskDelay:
 709              	.LFB4:
 868:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 869:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelayUntil */
 870:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 871:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 872:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 873:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 874:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	void vTaskDelay( const TickType_t xTicksToDelay )
 875:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
 710              		.loc 1 875 0
 711              		.cfi_startproc
 712              		@ args = 0, pretend = 0, frame = 16
 713              		@ frame_needed = 1, uses_anonymous_args = 0
 714 0000 80B5     		push	{r7, lr}
 715              	.LCFI9:
 716              		.cfi_def_cfa_offset 8
 717              		.cfi_offset 7, -8
 718              		.cfi_offset 14, -4
 719 0002 84B0     		sub	sp, sp, #16
 720              	.LCFI10:
 721              		.cfi_def_cfa_offset 24
 722 0004 00AF     		add	r7, sp, #0
 723              	.LCFI11:
 724              		.cfi_def_cfa_register 7
 725 0006 7860     		str	r0, [r7, #4]
 876:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
 877:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	BaseType_t xAlreadyYielded = pdFALSE;
 726              		.loc 1 877 0
 727 0008 0023     		movs	r3, #0
 728 000a FB60     		str	r3, [r7, #12]
 878:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 879:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 880:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
 881:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( xTicksToDelay > ( TickType_t ) 0U )
 729              		.loc 1 881 0
 730 000c 7B68     		ldr	r3, [r7, #4]
 731 000e 002B     		cmp	r3, #0
 732 0010 3AD0     		beq	.L39
 882:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
 883:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			configASSERT( uxSchedulerSuspended == 0 );
 733              		.loc 1 883 0
 734 0012 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 735 0016 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 736 001a 1B68     		ldr	r3, [r3]
 737 001c 002B     		cmp	r3, #0
 738 001e 02D0     		beq	.L40
 739              		.loc 1 883 0 is_stmt 0 discriminator 1
 740 0020 FFF7FEFF 		bl	ulPortSetInterruptMask
 741              	.L41:
 742 0024 FEE7     		b	.L41
 743              	.L40:
 884:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
 744              		.loc 1 884 0 is_stmt 1
 745 0026 FFF7FEFF 		bl	vTaskSuspendAll
 885:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
 886:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY();
 887:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 888:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* A task that is removed from the event list while the
 889:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
 890:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				list or removed from the blocked list until the scheduler
 891:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				is resumed.
 892:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 893:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				This task cannot be in an event list as it is the currently
 894:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				executing task. */
 895:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 896:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* Calculate the time to wake - this may overflow but this is
 897:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				not a problem. */
 898:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 746              		.loc 1 898 0
 747 002a 40F20003 		movw	r3, #:lower16:xTickCount
 748 002e C0F20003 		movt	r3, #:upper16:xTickCount
 749 0032 1A68     		ldr	r2, [r3]
 750 0034 7B68     		ldr	r3, [r7, #4]
 751 0036 1344     		add	r3, r3, r2
 752 0038 BB60     		str	r3, [r7, #8]
 899:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 900:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 901:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 902:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				both lists. */
 903:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 753              		.loc 1 903 0
 754 003a 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 755 003e C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 756 0042 1B68     		ldr	r3, [r3]
 757 0044 0433     		adds	r3, r3, #4
 758 0046 1846     		mov	r0, r3
 759 0048 FFF7FEFF 		bl	uxListRemove
 760 004c 0346     		mov	r3, r0
 761 004e 002B     		cmp	r3, #0
 762 0050 14D1     		bne	.L42
 904:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
 905:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					/* The current task must be in a ready list, so there is
 906:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					no need to check, and the port reset macro can be called
 907:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					directly. */
 908:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 763              		.loc 1 908 0
 764 0052 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 765 0056 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 766 005a 1B68     		ldr	r3, [r3]
 767 005c DB6A     		ldr	r3, [r3, #44]
 768 005e 0122     		movs	r2, #1
 769 0060 02FA03F3 		lsl	r3, r2, r3
 770 0064 DA43     		mvns	r2, r3
 771 0066 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 772 006a C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 773 006e 1B68     		ldr	r3, [r3]
 774 0070 1A40     		ands	r2, r2, r3
 775 0072 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 776 0076 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 777 007a 1A60     		str	r2, [r3]
 778              	.L42:
 909:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
 910:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				else
 911:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
 912:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 913:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
 914:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 779              		.loc 1 914 0 discriminator 1
 780 007c B868     		ldr	r0, [r7, #8]
 781 007e FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 915:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
 916:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 782              		.loc 1 916 0 discriminator 1
 783 0082 FFF7FEFF 		bl	xTaskResumeAll
 784 0086 F860     		str	r0, [r7, #12]
 785              	.L39:
 917:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
 918:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
 919:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
 920:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 921:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
 922:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 923:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 924:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
 925:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 786              		.loc 1 925 0
 787 0088 FB68     		ldr	r3, [r7, #12]
 788 008a 002B     		cmp	r3, #0
 789 008c 01D1     		bne	.L38
 926:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
 927:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
 790              		.loc 1 927 0
 791 008e FFF7FEFF 		bl	vPortYield
 792              	.L38:
 928:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
 929:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
 930:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
 931:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 932:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
 933:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
 793              		.loc 1 933 0
 794 0092 1037     		adds	r7, r7, #16
 795 0094 BD46     		mov	sp, r7
 796              		@ sp needed
 797 0096 80BD     		pop	{r7, pc}
 798              		.cfi_endproc
 799              	.LFE4:
 801              		.section	.text.uxTaskPriorityGet,"ax",%progbits
 802              		.align	2
 803              		.global	uxTaskPriorityGet
 804              		.thumb
 805              		.thumb_func
 807              	uxTaskPriorityGet:
 808              	.LFB5:
 934:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 935:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelay */
 936:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 937:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 938:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_eTaskGetState == 1 )
 939:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 940:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	eTaskState eTaskGetState( TaskHandle_t xTask )
 941:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
 942:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	eTaskState eReturn;
 943:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	List_t *pxStateList;
 944:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
 945:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 946:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		configASSERT( pxTCB );
 947:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 948:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
 949:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
 950:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* The task calling this function is querying its own state. */
 951:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			eReturn = eRunning;
 952:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
 953:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
 954:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
 955:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
 956:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
 957:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xGenericListItem ) );
 958:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
 959:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
 960:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 961:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
 962:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
 963:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* The task being queried is referenced from one of the Blocked
 964:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				lists. */
 965:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				eReturn = eBlocked;
 966:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
 967:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 968:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
 969:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				else if( pxStateList == &xSuspendedTaskList )
 970:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
 971:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					/* The task being queried is referenced from the suspended
 972:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					list.  Is it genuinely suspended or is it block
 973:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					indefinitely? */
 974:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
 975:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					{
 976:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						eReturn = eSuspended;
 977:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					}
 978:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					else
 979:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					{
 980:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						eReturn = eBlocked;
 981:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					}
 982:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
 983:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			#endif
 984:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 985:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
 986:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				else if( pxStateList == &xTasksWaitingTermination )
 987:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
 988:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					/* The task being queried is referenced from the deleted
 989:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					tasks list. */
 990:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					eReturn = eDeleted;
 991:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
 992:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			#endif
 993:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
 994:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			else
 995:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
 996:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* If the task is not in any other state, it must be in the
 997:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				Ready (including pending ready) state. */
 998:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				eReturn = eReady;
 999:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
1000:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
1001:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1002:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		return eReturn;
1003:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1004:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1005:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_eTaskGetState */
1006:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1007:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1008:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1009:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1010:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
1011:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
 809              		.loc 1 1011 0
 810              		.cfi_startproc
 811              		@ args = 0, pretend = 0, frame = 16
 812              		@ frame_needed = 1, uses_anonymous_args = 0
 813 0000 80B5     		push	{r7, lr}
 814              	.LCFI12:
 815              		.cfi_def_cfa_offset 8
 816              		.cfi_offset 7, -8
 817              		.cfi_offset 14, -4
 818 0002 84B0     		sub	sp, sp, #16
 819              	.LCFI13:
 820              		.cfi_def_cfa_offset 24
 821 0004 00AF     		add	r7, sp, #0
 822              	.LCFI14:
 823              		.cfi_def_cfa_register 7
 824 0006 7860     		str	r0, [r7, #4]
1012:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1013:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn;
1014:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1015:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 825              		.loc 1 1015 0
 826 0008 FFF7FEFF 		bl	vPortEnterCritical
1016:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
1017:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are changing the
1018:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			priority of the calling function. */
1019:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
 827              		.loc 1 1019 0
 828 000c 7B68     		ldr	r3, [r7, #4]
 829 000e 002B     		cmp	r3, #0
 830 0010 05D1     		bne	.L45
 831              		.loc 1 1019 0 is_stmt 0 discriminator 1
 832 0012 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 833 0016 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 834 001a 1B68     		ldr	r3, [r3]
 835 001c 00E0     		b	.L46
 836              	.L45:
 837              		.loc 1 1019 0 discriminator 2
 838 001e 7B68     		ldr	r3, [r7, #4]
 839              	.L46:
 840              		.loc 1 1019 0 discriminator 3
 841 0020 FB60     		str	r3, [r7, #12]
1020:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 842              		.loc 1 1020 0 is_stmt 1 discriminator 3
 843 0022 FB68     		ldr	r3, [r7, #12]
 844 0024 DB6A     		ldr	r3, [r3, #44]
 845 0026 BB60     		str	r3, [r7, #8]
1021:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
1022:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 846              		.loc 1 1022 0 discriminator 3
 847 0028 FFF7FEFF 		bl	vPortExitCritical
1023:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1024:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		return uxReturn;
 848              		.loc 1 1024 0 discriminator 3
 849 002c BB68     		ldr	r3, [r7, #8]
1025:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
 850              		.loc 1 1025 0 discriminator 3
 851 002e 1846     		mov	r0, r3
 852 0030 1037     		adds	r7, r7, #16
 853 0032 BD46     		mov	sp, r7
 854              		@ sp needed
 855 0034 80BD     		pop	{r7, pc}
 856              		.cfi_endproc
 857              	.LFE5:
 859 0036 00BF     		.section	.text.vTaskPrioritySet,"ax",%progbits
 860              		.align	2
 861              		.global	vTaskPrioritySet
 862              		.thumb
 863              		.thumb_func
 865              	vTaskPrioritySet:
 866              	.LFB6:
1026:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1027:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1028:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1029:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1030:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
1031:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1032:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
1033:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
 867              		.loc 1 1033 0
 868              		.cfi_startproc
 869              		@ args = 0, pretend = 0, frame = 24
 870              		@ frame_needed = 1, uses_anonymous_args = 0
 871 0000 80B5     		push	{r7, lr}
 872              	.LCFI15:
 873              		.cfi_def_cfa_offset 8
 874              		.cfi_offset 7, -8
 875              		.cfi_offset 14, -4
 876 0002 86B0     		sub	sp, sp, #24
 877              	.LCFI16:
 878              		.cfi_def_cfa_offset 32
 879 0004 00AF     		add	r7, sp, #0
 880              	.LCFI17:
 881              		.cfi_def_cfa_register 7
 882 0006 7860     		str	r0, [r7, #4]
 883 0008 3960     		str	r1, [r7]
1034:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1035:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
1036:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
 884              		.loc 1 1036 0
 885 000a 0023     		movs	r3, #0
 886 000c 7B61     		str	r3, [r7, #20]
1037:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1038:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 887              		.loc 1 1038 0
 888 000e 3B68     		ldr	r3, [r7]
 889 0010 042B     		cmp	r3, #4
 890 0012 02D9     		bls	.L49
 891              		.loc 1 1038 0 is_stmt 0 discriminator 1
 892 0014 FFF7FEFF 		bl	ulPortSetInterruptMask
 893              	.L50:
 894 0018 FEE7     		b	.L50
 895              	.L49:
1039:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1040:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Ensure the new priority is valid. */
1041:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 896              		.loc 1 1041 0 is_stmt 1
 897 001a 3B68     		ldr	r3, [r7]
 898 001c 042B     		cmp	r3, #4
 899 001e 01D9     		bls	.L51
1042:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
1043:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 900              		.loc 1 1043 0
 901 0020 0423     		movs	r3, #4
 902 0022 3B60     		str	r3, [r7]
 903              	.L51:
1044:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
1045:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
1046:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
1047:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1048:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
1049:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1050:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 904              		.loc 1 1050 0
 905 0024 FFF7FEFF 		bl	vPortEnterCritical
1051:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
1052:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1053:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			task that is being changed. */
1054:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
 906              		.loc 1 1054 0
 907 0028 7B68     		ldr	r3, [r7, #4]
 908 002a 002B     		cmp	r3, #0
 909 002c 05D1     		bne	.L52
 910              		.loc 1 1054 0 is_stmt 0 discriminator 1
 911 002e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 912 0032 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 913 0036 1B68     		ldr	r3, [r3]
 914 0038 00E0     		b	.L53
 915              	.L52:
 916              		.loc 1 1054 0 discriminator 2
 917 003a 7B68     		ldr	r3, [r7, #4]
 918              	.L53:
 919              		.loc 1 1054 0 discriminator 3
 920 003c 3B61     		str	r3, [r7, #16]
1055:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1056:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
1057:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1058:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
1059:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
1060:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxBasePriority;
 921              		.loc 1 1060 0 is_stmt 1 discriminator 3
 922 003e 3B69     		ldr	r3, [r7, #16]
 923 0040 9B6C     		ldr	r3, [r3, #72]
 924 0042 FB60     		str	r3, [r7, #12]
1061:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
1062:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			#else
1063:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
1064:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxPriority;
1065:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
1066:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			#endif
1067:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1068:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			if( uxCurrentBasePriority != uxNewPriority )
 925              		.loc 1 1068 0 discriminator 3
 926 0044 FA68     		ldr	r2, [r7, #12]
 927 0046 3B68     		ldr	r3, [r7]
 928 0048 9A42     		cmp	r2, r3
 929 004a 00F08A80 		beq	.L54
1069:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
1070:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* The priority change may have readied a task of higher
1071:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				priority than the calling task. */
1072:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				if( uxNewPriority > uxCurrentBasePriority )
 930              		.loc 1 1072 0
 931 004e 3A68     		ldr	r2, [r7]
 932 0050 FB68     		ldr	r3, [r7, #12]
 933 0052 9A42     		cmp	r2, r3
 934 0054 13D9     		bls	.L55
1073:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
1074:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					if( pxTCB != pxCurrentTCB )
 935              		.loc 1 1074 0
 936 0056 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 937 005a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 938 005e 1B68     		ldr	r3, [r3]
 939 0060 3A69     		ldr	r2, [r7, #16]
 940 0062 9A42     		cmp	r2, r3
 941 0064 15D0     		beq	.L56
1075:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					{
1076:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						/* The priority of a task other than the currently
1077:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						running task is being raised.  Is the priority being
1078:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						raised above that of the running task? */
1079:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						if( uxNewPriority >= pxCurrentTCB->uxPriority )
 942              		.loc 1 1079 0
 943 0066 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 944 006a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 945 006e 1B68     		ldr	r3, [r3]
 946 0070 DA6A     		ldr	r2, [r3, #44]
 947 0072 3B68     		ldr	r3, [r7]
 948 0074 9A42     		cmp	r2, r3
 949 0076 0CD8     		bhi	.L56
1080:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						{
1081:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							xYieldRequired = pdTRUE;
 950              		.loc 1 1081 0
 951 0078 0123     		movs	r3, #1
 952 007a 7B61     		str	r3, [r7, #20]
 953 007c 09E0     		b	.L56
 954              	.L55:
1082:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						}
1083:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						else
1084:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						{
1085:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
1086:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						}
1087:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					}
1088:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					else
1089:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					{
1090:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						/* The priority of the running task is being raised,
1091:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						but the running task must already be the highest
1092:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						priority task able to run so no yield is required. */
1093:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					}
1094:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
1095:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				else if( pxTCB == pxCurrentTCB )
 955              		.loc 1 1095 0
 956 007e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 957 0082 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 958 0086 1B68     		ldr	r3, [r3]
 959 0088 3A69     		ldr	r2, [r7, #16]
 960 008a 9A42     		cmp	r2, r3
 961 008c 01D1     		bne	.L56
1096:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
1097:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					/* Setting the priority of the running task down means
1098:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					there may now be another task of higher priority that
1099:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					is ready to execute. */
1100:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					xYieldRequired = pdTRUE;
 962              		.loc 1 1100 0
 963 008e 0123     		movs	r3, #1
 964 0090 7B61     		str	r3, [r7, #20]
 965              	.L56:
1101:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
1102:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				else
1103:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
1104:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					/* Setting the priority of any other task down does not
1105:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					require a yield as the running task must be above the
1106:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					new priority of the task being modified. */
1107:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
1108:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1109:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* Remember the ready list the task might be referenced from
1110:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				before its uxPriority member is changed so the
1111:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY() macro can function correctly. */
1112:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				uxPriorityUsedOnEntry = pxTCB->uxPriority;
 966              		.loc 1 1112 0
 967 0092 3B69     		ldr	r3, [r7, #16]
 968 0094 DB6A     		ldr	r3, [r3, #44]
 969 0096 BB60     		str	r3, [r7, #8]
1113:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1114:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
1115:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
1116:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					/* Only change the priority being used if the task is not
1117:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					currently using an inherited priority. */
1118:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 970              		.loc 1 1118 0
 971 0098 3B69     		ldr	r3, [r7, #16]
 972 009a 9A6C     		ldr	r2, [r3, #72]
 973 009c 3B69     		ldr	r3, [r7, #16]
 974 009e DB6A     		ldr	r3, [r3, #44]
 975 00a0 9A42     		cmp	r2, r3
 976 00a2 02D1     		bne	.L57
1119:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					{
1120:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 977              		.loc 1 1120 0
 978 00a4 3B69     		ldr	r3, [r7, #16]
 979 00a6 3A68     		ldr	r2, [r7]
 980 00a8 DA62     		str	r2, [r3, #44]
 981              	.L57:
1121:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					}
1122:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					else
1123:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					{
1124:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1125:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					}
1126:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1127:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					/* The base priority gets set whatever. */
1128:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
 982              		.loc 1 1128 0
 983 00aa 3B69     		ldr	r3, [r7, #16]
 984 00ac 3A68     		ldr	r2, [r7]
 985 00ae 9A64     		str	r2, [r3, #72]
1129:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
1130:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				#else
1131:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
1132:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
1133:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
1134:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				#endif
1135:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1136:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* Only reset the event list item value if the value is not
1137:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				being used for anything else. */
1138:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE 
 986              		.loc 1 1138 0
 987 00b0 3B69     		ldr	r3, [r7, #16]
 988 00b2 9B69     		ldr	r3, [r3, #24]
 989 00b4 002B     		cmp	r3, #0
 990 00b6 04DB     		blt	.L58
1139:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
1140:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - (
 991              		.loc 1 1140 0
 992 00b8 3B68     		ldr	r3, [r7]
 993 00ba C3F10502 		rsb	r2, r3, #5
 994 00be 3B69     		ldr	r3, [r7, #16]
 995 00c0 9A61     		str	r2, [r3, #24]
 996              	.L58:
1141:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
1142:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				else
1143:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
1144:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1145:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
1146:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1147:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
1148:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				nothing more than change it's priority variable. However, if
1149:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
1150:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				in the list appropriate to its new priority. */
1151:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGeneri
 997              		.loc 1 1151 0
 998 00c2 3B69     		ldr	r3, [r7, #16]
 999 00c4 5969     		ldr	r1, [r3, #20]
 1000 00c6 BA68     		ldr	r2, [r7, #8]
 1001 00c8 1346     		mov	r3, r2
 1002 00ca 9B00     		lsls	r3, r3, #2
 1003 00cc 1344     		add	r3, r3, r2
 1004 00ce 9B00     		lsls	r3, r3, #2
 1005 00d0 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 1006 00d4 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 1007 00d8 1344     		add	r3, r3, r2
 1008 00da 9942     		cmp	r1, r3
 1009 00dc 01D1     		bne	.L59
 1010              		.loc 1 1151 0 is_stmt 0 discriminator 1
 1011 00de 0123     		movs	r3, #1
 1012 00e0 00E0     		b	.L60
 1013              	.L59:
 1014              		.loc 1 1151 0 discriminator 2
 1015 00e2 0023     		movs	r3, #0
 1016              	.L60:
 1017              		.loc 1 1151 0 discriminator 3
 1018 00e4 002B     		cmp	r3, #0
 1019 00e6 37D0     		beq	.L61
1152:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
1153:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					/* The task is currently in its ready list - remove before adding
1154:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
1155:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					can do this even if the scheduler is suspended. */
1156:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 1020              		.loc 1 1156 0 is_stmt 1
 1021 00e8 3B69     		ldr	r3, [r7, #16]
 1022 00ea 0433     		adds	r3, r3, #4
 1023 00ec 1846     		mov	r0, r3
 1024 00ee FFF7FEFF 		bl	uxListRemove
 1025 00f2 0346     		mov	r3, r0
 1026 00f4 002B     		cmp	r3, #0
 1027 00f6 0FD1     		bne	.L62
1157:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					{
1158:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						/* It is known that the task is in its ready list so
1159:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						there is no need to check again and the port level
1160:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						reset macro can be called directly. */
1161:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
 1028              		.loc 1 1161 0
 1029 00f8 BB68     		ldr	r3, [r7, #8]
 1030 00fa 0122     		movs	r2, #1
 1031 00fc 02FA03F3 		lsl	r3, r2, r3
 1032 0100 DA43     		mvns	r2, r3
 1033 0102 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1034 0106 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1035 010a 1B68     		ldr	r3, [r3]
 1036 010c 1A40     		ands	r2, r2, r3
 1037 010e 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1038 0112 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1039 0116 1A60     		str	r2, [r3]
 1040              	.L62:
1162:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					}
1163:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					else
1164:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					{
1165:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1166:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					}
1167:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1041              		.loc 1 1167 0 discriminator 3
 1042 0118 3B69     		ldr	r3, [r7, #16]
 1043 011a DB6A     		ldr	r3, [r3, #44]
 1044 011c 0122     		movs	r2, #1
 1045 011e 9A40     		lsls	r2, r2, r3
 1046 0120 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1047 0124 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1048 0128 1B68     		ldr	r3, [r3]
 1049 012a 1A43     		orrs	r2, r2, r3
 1050 012c 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1051 0130 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1052 0134 1A60     		str	r2, [r3]
 1053 0136 3B69     		ldr	r3, [r7, #16]
 1054 0138 DA6A     		ldr	r2, [r3, #44]
 1055 013a 1346     		mov	r3, r2
 1056 013c 9B00     		lsls	r3, r3, #2
 1057 013e 1344     		add	r3, r3, r2
 1058 0140 9B00     		lsls	r3, r3, #2
 1059 0142 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 1060 0146 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 1061 014a 1A44     		add	r2, r2, r3
 1062 014c 3B69     		ldr	r3, [r7, #16]
 1063 014e 0433     		adds	r3, r3, #4
 1064 0150 1046     		mov	r0, r2
 1065 0152 1946     		mov	r1, r3
 1066 0154 FFF7FEFF 		bl	vListInsertEnd
 1067              	.L61:
1168:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
1169:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				else
1170:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
1171:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1172:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
1173:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1174:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				if( xYieldRequired == pdTRUE )
 1068              		.loc 1 1174 0
 1069 0158 7B69     		ldr	r3, [r7, #20]
 1070 015a 012B     		cmp	r3, #1
 1071 015c 01D1     		bne	.L54
1175:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
1176:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
 1072              		.loc 1 1176 0
 1073 015e FFF7FEFF 		bl	vPortYield
 1074              	.L54:
1177:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
1178:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				else
1179:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
1180:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1181:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
1182:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1183:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* Remove compiler warning about unused variables when the port
1184:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				optimised task selection is not being used. */
1185:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				( void ) uxPriorityUsedOnEntry;
1186:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
1187:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
1188:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 1075              		.loc 1 1188 0
 1076 0162 FFF7FEFF 		bl	vPortExitCritical
1189:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
 1077              		.loc 1 1189 0
 1078 0166 1837     		adds	r7, r7, #24
 1079 0168 BD46     		mov	sp, r7
 1080              		@ sp needed
 1081 016a 80BD     		pop	{r7, pc}
 1082              		.cfi_endproc
 1083              	.LFE6:
 1085              		.section	.text.vTaskSuspend,"ax",%progbits
 1086              		.align	2
 1087              		.global	vTaskSuspend
 1088              		.thumb
 1089              		.thumb_func
 1091              	vTaskSuspend:
 1092              	.LFB7:
1190:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1191:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskPrioritySet */
1192:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1193:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1194:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1195:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1196:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
1197:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
 1093              		.loc 1 1197 0
 1094              		.cfi_startproc
 1095              		@ args = 0, pretend = 0, frame = 16
 1096              		@ frame_needed = 1, uses_anonymous_args = 0
 1097 0000 80B5     		push	{r7, lr}
 1098              	.LCFI18:
 1099              		.cfi_def_cfa_offset 8
 1100              		.cfi_offset 7, -8
 1101              		.cfi_offset 14, -4
 1102 0002 84B0     		sub	sp, sp, #16
 1103              	.LCFI19:
 1104              		.cfi_def_cfa_offset 24
 1105 0004 00AF     		add	r7, sp, #0
 1106              	.LCFI20:
 1107              		.cfi_def_cfa_register 7
 1108 0006 7860     		str	r0, [r7, #4]
1198:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1199:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1200:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 1109              		.loc 1 1200 0
 1110 0008 FFF7FEFF 		bl	vPortEnterCritical
1201:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
1202:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the running task that is
1203:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			being suspended. */
1204:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 1111              		.loc 1 1204 0
 1112 000c 7B68     		ldr	r3, [r7, #4]
 1113 000e 002B     		cmp	r3, #0
 1114 0010 05D1     		bne	.L64
 1115              		.loc 1 1204 0 is_stmt 0 discriminator 1
 1116 0012 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1117 0016 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1118 001a 1B68     		ldr	r3, [r3]
 1119 001c 00E0     		b	.L65
 1120              	.L64:
 1121              		.loc 1 1204 0 discriminator 2
 1122 001e 7B68     		ldr	r3, [r7, #4]
 1123              	.L65:
 1124              		.loc 1 1204 0 discriminator 3
 1125 0020 FB60     		str	r3, [r7, #12]
1205:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1206:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
1207:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1208:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the
1209:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			suspended list. */
1210:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 1126              		.loc 1 1210 0 is_stmt 1 discriminator 3
 1127 0022 FB68     		ldr	r3, [r7, #12]
 1128 0024 0433     		adds	r3, r3, #4
 1129 0026 1846     		mov	r0, r3
 1130 0028 FFF7FEFF 		bl	uxListRemove
 1131 002c 0346     		mov	r3, r0
 1132 002e 002B     		cmp	r3, #0
 1133 0030 1ED1     		bne	.L66
1211:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
1212:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 1134              		.loc 1 1212 0
 1135 0032 FB68     		ldr	r3, [r7, #12]
 1136 0034 D96A     		ldr	r1, [r3, #44]
 1137 0036 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 1138 003a C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 1139 003e 0B46     		mov	r3, r1
 1140 0040 9B00     		lsls	r3, r3, #2
 1141 0042 0B44     		add	r3, r3, r1
 1142 0044 9B00     		lsls	r3, r3, #2
 1143 0046 1344     		add	r3, r3, r2
 1144 0048 1B68     		ldr	r3, [r3]
 1145 004a 002B     		cmp	r3, #0
 1146 004c 10D1     		bne	.L66
 1147              		.loc 1 1212 0 is_stmt 0 discriminator 1
 1148 004e FB68     		ldr	r3, [r7, #12]
 1149 0050 DB6A     		ldr	r3, [r3, #44]
 1150 0052 0122     		movs	r2, #1
 1151 0054 02FA03F3 		lsl	r3, r2, r3
 1152 0058 DA43     		mvns	r2, r3
 1153 005a 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1154 005e C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1155 0062 1B68     		ldr	r3, [r3]
 1156 0064 1A40     		ands	r2, r2, r3
 1157 0066 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1158 006a C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1159 006e 1A60     		str	r2, [r3]
 1160              	.L66:
1213:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
1214:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			else
1215:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
1216:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1217:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
1218:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1219:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
1220:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 1161              		.loc 1 1220 0 is_stmt 1
 1162 0070 FB68     		ldr	r3, [r7, #12]
 1163 0072 9B6A     		ldr	r3, [r3, #40]
 1164 0074 002B     		cmp	r3, #0
 1165 0076 04D0     		beq	.L68
1221:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
1222:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1166              		.loc 1 1222 0
 1167 0078 FB68     		ldr	r3, [r7, #12]
 1168 007a 1833     		adds	r3, r3, #24
 1169 007c 1846     		mov	r0, r3
 1170 007e FFF7FEFF 		bl	uxListRemove
 1171              	.L68:
1223:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
1224:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			else
1225:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
1226:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1227:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
1228:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1229:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 1172              		.loc 1 1229 0
 1173 0082 FB68     		ldr	r3, [r7, #12]
 1174 0084 0433     		adds	r3, r3, #4
 1175 0086 40F20000 		movw	r0, #:lower16:xSuspendedTaskList
 1176 008a C0F20000 		movt	r0, #:upper16:xSuspendedTaskList
 1177 008e 1946     		mov	r1, r3
 1178 0090 FFF7FEFF 		bl	vListInsertEnd
1230:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
1231:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 1179              		.loc 1 1231 0
 1180 0094 FFF7FEFF 		bl	vPortExitCritical
1232:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1233:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
 1181              		.loc 1 1233 0
 1182 0098 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1183 009c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1184 00a0 1B68     		ldr	r3, [r3]
 1185 00a2 FA68     		ldr	r2, [r7, #12]
 1186 00a4 9A42     		cmp	r2, r3
 1187 00a6 29D1     		bne	.L69
1234:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
1235:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 1188              		.loc 1 1235 0
 1189 00a8 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 1190 00ac C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 1191 00b0 1B68     		ldr	r3, [r3]
 1192 00b2 002B     		cmp	r3, #0
 1193 00b4 0CD0     		beq	.L70
1236:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
1237:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* The current task has just been suspended. */
1238:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
 1194              		.loc 1 1238 0
 1195 00b6 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1196 00ba C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1197 00be 1B68     		ldr	r3, [r3]
 1198 00c0 002B     		cmp	r3, #0
 1199 00c2 02D0     		beq	.L71
 1200              		.loc 1 1238 0 is_stmt 0 discriminator 1
 1201 00c4 FFF7FEFF 		bl	ulPortSetInterruptMask
 1202              	.L72:
 1203 00c8 FEE7     		b	.L72
 1204              	.L71:
1239:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 1205              		.loc 1 1239 0 is_stmt 1
 1206 00ca FFF7FEFF 		bl	vPortYield
 1207 00ce 22E0     		b	.L63
 1208              	.L70:
1240:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
1241:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			else
1242:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
1243:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
1244:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1245:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				must be adjusted to point to a different task. */
1246:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 1209              		.loc 1 1246 0
 1210 00d0 40F20003 		movw	r3, #:lower16:xSuspendedTaskList
 1211 00d4 C0F20003 		movt	r3, #:upper16:xSuspendedTaskList
 1212 00d8 1A68     		ldr	r2, [r3]
 1213 00da 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 1214 00de C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 1215 00e2 1B68     		ldr	r3, [r3]
 1216 00e4 9A42     		cmp	r2, r3
 1217 00e6 06D1     		bne	.L74
1247:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
1248:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
1249:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
1250:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					be set to point to it no matter what its relative priority
1251:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					is. */
1252:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					pxCurrentTCB = NULL;
 1218              		.loc 1 1252 0
 1219 00e8 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1220 00ec C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1221 00f0 0022     		movs	r2, #0
 1222 00f2 1A60     		str	r2, [r3]
 1223 00f4 0FE0     		b	.L63
 1224              	.L74:
1253:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
1254:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				else
1255:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
1256:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					vTaskSwitchContext();
 1225              		.loc 1 1256 0
 1226 00f6 FFF7FEFF 		bl	vTaskSwitchContext
 1227 00fa 0CE0     		b	.L63
 1228              	.L69:
1257:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
1258:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
1259:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
1260:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
1261:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
1262:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 1229              		.loc 1 1262 0
 1230 00fc 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 1231 0100 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 1232 0104 1B68     		ldr	r3, [r3]
 1233 0106 002B     		cmp	r3, #0
 1234 0108 05D0     		beq	.L63
1263:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
1264:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* A task other than the currently running task was suspended,
1265:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				reset the next expected unblock time in case it referred to the
1266:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				task that is now in the Suspended state. */
1267:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				taskENTER_CRITICAL();
 1235              		.loc 1 1267 0
 1236 010a FFF7FEFF 		bl	vPortEnterCritical
1268:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
1269:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					prvResetNextTaskUnblockTime();
 1237              		.loc 1 1269 0
 1238 010e FFF7FEFF 		bl	prvResetNextTaskUnblockTime
1270:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
1271:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				taskEXIT_CRITICAL();
 1239              		.loc 1 1271 0
 1240 0112 FFF7FEFF 		bl	vPortExitCritical
 1241              	.L63:
1272:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
1273:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			else
1274:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
1275:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1276:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
1277:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
1278:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
 1242              		.loc 1 1278 0
 1243 0116 1037     		adds	r7, r7, #16
 1244 0118 BD46     		mov	sp, r7
 1245              		@ sp needed
 1246 011a 80BD     		pop	{r7, pc}
 1247              		.cfi_endproc
 1248              	.LFE7:
 1250              		.section	.text.prvTaskIsTaskSuspended,"ax",%progbits
 1251              		.align	2
 1252              		.thumb
 1253              		.thumb_func
 1255              	prvTaskIsTaskSuspended:
 1256              	.LFB8:
1279:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1280:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1281:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1282:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1283:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1284:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1285:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1286:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
 1257              		.loc 1 1286 0
 1258              		.cfi_startproc
 1259              		@ args = 0, pretend = 0, frame = 16
 1260              		@ frame_needed = 1, uses_anonymous_args = 0
 1261 0000 80B5     		push	{r7, lr}
 1262              	.LCFI21:
 1263              		.cfi_def_cfa_offset 8
 1264              		.cfi_offset 7, -8
 1265              		.cfi_offset 14, -4
 1266 0002 84B0     		sub	sp, sp, #16
 1267              	.LCFI22:
 1268              		.cfi_def_cfa_offset 24
 1269 0004 00AF     		add	r7, sp, #0
 1270              	.LCFI23:
 1271              		.cfi_def_cfa_register 7
 1272 0006 7860     		str	r0, [r7, #4]
1287:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
 1273              		.loc 1 1287 0
 1274 0008 0023     		movs	r3, #0
 1275 000a FB60     		str	r3, [r7, #12]
1288:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
 1276              		.loc 1 1288 0
 1277 000c 7B68     		ldr	r3, [r7, #4]
 1278 000e BB60     		str	r3, [r7, #8]
1289:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1290:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Accesses xPendingReadyList so must be called from a critical
1291:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		section. */
1292:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1293:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
1294:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		configASSERT( xTask );
 1279              		.loc 1 1294 0
 1280 0010 7B68     		ldr	r3, [r7, #4]
 1281 0012 002B     		cmp	r3, #0
 1282 0014 02D1     		bne	.L77
 1283              		.loc 1 1294 0 is_stmt 0 discriminator 1
 1284 0016 FFF7FEFF 		bl	ulPortSetInterruptMask
 1285              	.L78:
 1286 001a FEE7     		b	.L78
 1287              	.L77:
1295:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1296:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Is the task being resumed actually in the suspended list? */
1297:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 1288              		.loc 1 1297 0 is_stmt 1
 1289 001c BB68     		ldr	r3, [r7, #8]
 1290 001e 5A69     		ldr	r2, [r3, #20]
 1291 0020 40F20003 		movw	r3, #:lower16:xSuspendedTaskList
 1292 0024 C0F20003 		movt	r3, #:upper16:xSuspendedTaskList
 1293 0028 9A42     		cmp	r2, r3
 1294 002a 01D1     		bne	.L79
 1295              		.loc 1 1297 0 is_stmt 0 discriminator 1
 1296 002c 0123     		movs	r3, #1
 1297 002e 00E0     		b	.L80
 1298              	.L79:
 1299              		.loc 1 1297 0 discriminator 2
 1300 0030 0023     		movs	r3, #0
 1301              	.L80:
 1302              		.loc 1 1297 0 discriminator 3
 1303 0032 002B     		cmp	r3, #0
 1304 0034 12D0     		beq	.L81
1298:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
1299:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
1300:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 1305              		.loc 1 1300 0 is_stmt 1
 1306 0036 BB68     		ldr	r3, [r7, #8]
 1307 0038 9A6A     		ldr	r2, [r3, #40]
 1308 003a 40F20003 		movw	r3, #:lower16:xPendingReadyList
 1309 003e C0F20003 		movt	r3, #:upper16:xPendingReadyList
 1310 0042 9A42     		cmp	r2, r3
 1311 0044 0AD0     		beq	.L81
1301:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
1302:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* Is it in the suspended list because it is in the	Suspended
1303:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				state, or because is is blocked with no timeout? */
1304:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
 1312              		.loc 1 1304 0
 1313 0046 BB68     		ldr	r3, [r7, #8]
 1314 0048 9B6A     		ldr	r3, [r3, #40]
 1315 004a 002B     		cmp	r3, #0
 1316 004c 01D1     		bne	.L82
 1317              		.loc 1 1304 0 is_stmt 0 discriminator 1
 1318 004e 0123     		movs	r3, #1
 1319 0050 00E0     		b	.L83
 1320              	.L82:
 1321              		.loc 1 1304 0 discriminator 2
 1322 0052 0023     		movs	r3, #0
 1323              	.L83:
 1324              		.loc 1 1304 0 discriminator 3
 1325 0054 002B     		cmp	r3, #0
 1326 0056 01D0     		beq	.L81
1305:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
1306:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
 1327              		.loc 1 1306 0 is_stmt 1
 1328 0058 0123     		movs	r3, #1
 1329 005a FB60     		str	r3, [r7, #12]
 1330              	.L81:
1307:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
1308:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				else
1309:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
1310:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1311:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
1312:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
1313:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			else
1314:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
1315:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1316:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
1317:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
1318:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
1319:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
1320:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1321:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
1322:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1323:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		return xReturn;
 1331              		.loc 1 1323 0
 1332 005c FB68     		ldr	r3, [r7, #12]
1324:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 1333              		.loc 1 1324 0
 1334 005e 1846     		mov	r0, r3
 1335 0060 1037     		adds	r7, r7, #16
 1336 0062 BD46     		mov	sp, r7
 1337              		@ sp needed
 1338 0064 80BD     		pop	{r7, pc}
 1339              		.cfi_endproc
 1340              	.LFE8:
 1342 0066 00BF     		.section	.text.vTaskResume,"ax",%progbits
 1343              		.align	2
 1344              		.global	vTaskResume
 1345              		.thumb
 1346              		.thumb_func
 1348              	vTaskResume:
 1349              	.LFB9:
1325:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1326:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1327:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1328:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1329:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1330:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1331:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	void vTaskResume( TaskHandle_t xTaskToResume )
1332:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
 1350              		.loc 1 1332 0
 1351              		.cfi_startproc
 1352              		@ args = 0, pretend = 0, frame = 16
 1353              		@ frame_needed = 1, uses_anonymous_args = 0
 1354 0000 80B5     		push	{r7, lr}
 1355              	.LCFI24:
 1356              		.cfi_def_cfa_offset 8
 1357              		.cfi_offset 7, -8
 1358              		.cfi_offset 14, -4
 1359 0002 84B0     		sub	sp, sp, #16
 1360              	.LCFI25:
 1361              		.cfi_def_cfa_offset 24
 1362 0004 00AF     		add	r7, sp, #0
 1363              	.LCFI26:
 1364              		.cfi_def_cfa_register 7
 1365 0006 7860     		str	r0, [r7, #4]
1333:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
 1366              		.loc 1 1333 0
 1367 0008 7B68     		ldr	r3, [r7, #4]
 1368 000a FB60     		str	r3, [r7, #12]
1334:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1335:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* It does not make sense to resume the calling task. */
1336:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToResume );
 1369              		.loc 1 1336 0
 1370 000c 7B68     		ldr	r3, [r7, #4]
 1371 000e 002B     		cmp	r3, #0
 1372 0010 02D1     		bne	.L86
 1373              		.loc 1 1336 0 is_stmt 0 discriminator 1
 1374 0012 FFF7FEFF 		bl	ulPortSetInterruptMask
 1375              	.L87:
 1376 0016 FEE7     		b	.L87
 1377              	.L86:
1337:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1338:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1339:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		currently executing task. */
1340:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 1378              		.loc 1 1340 0 is_stmt 1
 1379 0018 FB68     		ldr	r3, [r7, #12]
 1380 001a 002B     		cmp	r3, #0
 1381 001c 42D0     		beq	.L85
 1382              		.loc 1 1340 0 is_stmt 0 discriminator 1
 1383 001e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1384 0022 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1385 0026 1B68     		ldr	r3, [r3]
 1386 0028 FA68     		ldr	r2, [r7, #12]
 1387 002a 9A42     		cmp	r2, r3
 1388 002c 3AD0     		beq	.L85
1341:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
1342:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
 1389              		.loc 1 1342 0 is_stmt 1
 1390 002e FFF7FEFF 		bl	vPortEnterCritical
1343:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
1344:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1391              		.loc 1 1344 0
 1392 0032 F868     		ldr	r0, [r7, #12]
 1393 0034 FFF7FEFF 		bl	prvTaskIsTaskSuspended
 1394 0038 0346     		mov	r3, r0
 1395 003a 012B     		cmp	r3, #1
 1396 003c 30D1     		bne	.L89
1345:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
1346:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
1347:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1348:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					/* As we are in a critical section we can access the ready
1349:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					lists even if the scheduler is suspended. */
1350:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
 1397              		.loc 1 1350 0
 1398 003e FB68     		ldr	r3, [r7, #12]
 1399 0040 0433     		adds	r3, r3, #4
 1400 0042 1846     		mov	r0, r3
 1401 0044 FFF7FEFF 		bl	uxListRemove
1351:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1402              		.loc 1 1351 0
 1403 0048 FB68     		ldr	r3, [r7, #12]
 1404 004a DB6A     		ldr	r3, [r3, #44]
 1405 004c 0122     		movs	r2, #1
 1406 004e 9A40     		lsls	r2, r2, r3
 1407 0050 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1408 0054 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1409 0058 1B68     		ldr	r3, [r3]
 1410 005a 1A43     		orrs	r2, r2, r3
 1411 005c 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1412 0060 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1413 0064 1A60     		str	r2, [r3]
 1414 0066 FB68     		ldr	r3, [r7, #12]
 1415 0068 DA6A     		ldr	r2, [r3, #44]
 1416 006a 1346     		mov	r3, r2
 1417 006c 9B00     		lsls	r3, r3, #2
 1418 006e 1344     		add	r3, r3, r2
 1419 0070 9B00     		lsls	r3, r3, #2
 1420 0072 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 1421 0076 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 1422 007a 1A44     		add	r2, r2, r3
 1423 007c FB68     		ldr	r3, [r7, #12]
 1424 007e 0433     		adds	r3, r3, #4
 1425 0080 1046     		mov	r0, r2
 1426 0082 1946     		mov	r1, r3
 1427 0084 FFF7FEFF 		bl	vListInsertEnd
1352:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1353:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					/* We may have just resumed a higher priority task. */
1354:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1428              		.loc 1 1354 0
 1429 0088 FB68     		ldr	r3, [r7, #12]
 1430 008a DA6A     		ldr	r2, [r3, #44]
 1431 008c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1432 0090 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1433 0094 1B68     		ldr	r3, [r3]
 1434 0096 DB6A     		ldr	r3, [r3, #44]
 1435 0098 9A42     		cmp	r2, r3
 1436 009a 01D3     		bcc	.L89
1355:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					{
1356:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						/* This yield may not cause the task just resumed to run,
1357:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						but will leave the lists in the correct state for the
1358:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						next yield. */
1359:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						taskYIELD_IF_USING_PREEMPTION();
 1437              		.loc 1 1359 0
 1438 009c FFF7FEFF 		bl	vPortYield
 1439              	.L89:
1360:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					}
1361:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					else
1362:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					{
1363:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1364:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					}
1365:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
1366:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				else
1367:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
1368:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1369:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
1370:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
1371:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
 1440              		.loc 1 1371 0 discriminator 2
 1441 00a0 FFF7FEFF 		bl	vPortExitCritical
 1442              	.L85:
1372:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
1373:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
1374:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
1375:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1376:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
1377:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
 1443              		.loc 1 1377 0
 1444 00a4 1037     		adds	r7, r7, #16
 1445 00a6 BD46     		mov	sp, r7
 1446              		@ sp needed
 1447 00a8 80BD     		pop	{r7, pc}
 1448              		.cfi_endproc
 1449              	.LFE9:
 1451 00aa 00BF     		.section	.text.xTaskResumeFromISR,"ax",%progbits
 1452              		.align	2
 1453              		.global	xTaskResumeFromISR
 1454              		.thumb
 1455              		.thumb_func
 1457              	xTaskResumeFromISR:
 1458              	.LFB10:
1378:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1379:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1380:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1381:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1382:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1383:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1384:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1385:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1386:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
 1459              		.loc 1 1386 0
 1460              		.cfi_startproc
 1461              		@ args = 0, pretend = 0, frame = 24
 1462              		@ frame_needed = 1, uses_anonymous_args = 0
 1463 0000 80B5     		push	{r7, lr}
 1464              	.LCFI27:
 1465              		.cfi_def_cfa_offset 8
 1466              		.cfi_offset 7, -8
 1467              		.cfi_offset 14, -4
 1468 0002 86B0     		sub	sp, sp, #24
 1469              	.LCFI28:
 1470              		.cfi_def_cfa_offset 32
 1471 0004 00AF     		add	r7, sp, #0
 1472              	.LCFI29:
 1473              		.cfi_def_cfa_register 7
 1474 0006 7860     		str	r0, [r7, #4]
1387:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
 1475              		.loc 1 1387 0
 1476 0008 0023     		movs	r3, #0
 1477 000a 7B61     		str	r3, [r7, #20]
1388:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
 1478              		.loc 1 1388 0
 1479 000c 7B68     		ldr	r3, [r7, #4]
 1480 000e 3B61     		str	r3, [r7, #16]
1389:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
1390:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1391:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToResume );
 1481              		.loc 1 1391 0
 1482 0010 7B68     		ldr	r3, [r7, #4]
 1483 0012 002B     		cmp	r3, #0
 1484 0014 02D1     		bne	.L91
 1485              		.loc 1 1391 0 is_stmt 0 discriminator 1
 1486 0016 FFF7FEFF 		bl	ulPortSetInterruptMask
 1487              	.L92:
 1488 001a FEE7     		b	.L92
 1489              	.L91:
1392:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1393:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1394:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1395:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1396:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1397:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1398:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
1399:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1400:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1401:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
1402:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1403:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1404:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1405:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1406:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1407:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		provided on the following link:
1408:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1409:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 1490              		.loc 1 1409 0 is_stmt 1
 1491 001c FFF7FEFF 		bl	vPortValidateInterruptPriority
1410:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1411:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1492              		.loc 1 1411 0
 1493 0020 FFF7FEFF 		bl	ulPortSetInterruptMask
 1494 0024 F860     		str	r0, [r7, #12]
1412:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
1413:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1495              		.loc 1 1413 0
 1496 0026 3869     		ldr	r0, [r7, #16]
 1497 0028 FFF7FEFF 		bl	prvTaskIsTaskSuspended
 1498 002c 0346     		mov	r3, r0
 1499 002e 012B     		cmp	r3, #1
 1500 0030 41D1     		bne	.L93
1414:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
1415:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1416:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1417:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* Check the ready lists can be accessed. */
1418:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1501              		.loc 1 1418 0
 1502 0032 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1503 0036 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1504 003a 1B68     		ldr	r3, [r3]
 1505 003c 002B     		cmp	r3, #0
 1506 003e 31D1     		bne	.L94
1419:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
1420:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					/* Ready lists can be accessed so move the task from the
1421:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					suspended list to the ready list directly. */
1422:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1507              		.loc 1 1422 0
 1508 0040 3B69     		ldr	r3, [r7, #16]
 1509 0042 DA6A     		ldr	r2, [r3, #44]
 1510 0044 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1511 0048 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1512 004c 1B68     		ldr	r3, [r3]
 1513 004e DB6A     		ldr	r3, [r3, #44]
 1514 0050 9A42     		cmp	r2, r3
 1515 0052 01D3     		bcc	.L95
1423:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					{
1424:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 1516              		.loc 1 1424 0
 1517 0054 0123     		movs	r3, #1
 1518 0056 7B61     		str	r3, [r7, #20]
 1519              	.L95:
1425:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					}
1426:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					else
1427:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					{
1428:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1429:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					}
1430:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1431:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
 1520              		.loc 1 1431 0 discriminator 1
 1521 0058 3B69     		ldr	r3, [r7, #16]
 1522 005a 0433     		adds	r3, r3, #4
 1523 005c 1846     		mov	r0, r3
 1524 005e FFF7FEFF 		bl	uxListRemove
1432:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1525              		.loc 1 1432 0 discriminator 1
 1526 0062 3B69     		ldr	r3, [r7, #16]
 1527 0064 DB6A     		ldr	r3, [r3, #44]
 1528 0066 0122     		movs	r2, #1
 1529 0068 9A40     		lsls	r2, r2, r3
 1530 006a 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1531 006e C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1532 0072 1B68     		ldr	r3, [r3]
 1533 0074 1A43     		orrs	r2, r2, r3
 1534 0076 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1535 007a C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1536 007e 1A60     		str	r2, [r3]
 1537 0080 3B69     		ldr	r3, [r7, #16]
 1538 0082 DA6A     		ldr	r2, [r3, #44]
 1539 0084 1346     		mov	r3, r2
 1540 0086 9B00     		lsls	r3, r3, #2
 1541 0088 1344     		add	r3, r3, r2
 1542 008a 9B00     		lsls	r3, r3, #2
 1543 008c 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 1544 0090 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 1545 0094 1A44     		add	r2, r2, r3
 1546 0096 3B69     		ldr	r3, [r7, #16]
 1547 0098 0433     		adds	r3, r3, #4
 1548 009a 1046     		mov	r0, r2
 1549 009c 1946     		mov	r1, r3
 1550 009e FFF7FEFF 		bl	vListInsertEnd
 1551 00a2 08E0     		b	.L93
 1552              	.L94:
1433:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
1434:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				else
1435:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
1436:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					/* The delayed or ready lists cannot be accessed so the task
1437:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					is held in the pending ready list until the scheduler is
1438:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					unsuspended. */
1439:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1553              		.loc 1 1439 0
 1554 00a4 3B69     		ldr	r3, [r7, #16]
 1555 00a6 1833     		adds	r3, r3, #24
 1556 00a8 40F20000 		movw	r0, #:lower16:xPendingReadyList
 1557 00ac C0F20000 		movt	r0, #:upper16:xPendingReadyList
 1558 00b0 1946     		mov	r1, r3
 1559 00b2 FFF7FEFF 		bl	vListInsertEnd
 1560              	.L93:
1440:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
1441:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
1442:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			else
1443:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
1444:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1445:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
1446:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
1447:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1561              		.loc 1 1447 0
 1562 00b6 F868     		ldr	r0, [r7, #12]
 1563 00b8 FFF7FEFF 		bl	vPortClearInterruptMask
1448:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1449:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		return xYieldRequired;
 1564              		.loc 1 1449 0
 1565 00bc 7B69     		ldr	r3, [r7, #20]
1450:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
 1566              		.loc 1 1450 0
 1567 00be 1846     		mov	r0, r3
 1568 00c0 1837     		adds	r7, r7, #24
 1569 00c2 BD46     		mov	sp, r7
 1570              		@ sp needed
 1571 00c4 80BD     		pop	{r7, pc}
 1572              		.cfi_endproc
 1573              	.LFE10:
 1575 00c6 00BF     		.section	.rodata
 1576              		.align	2
 1577              	.LC0:
 1578 0000 49444C45 		.ascii	"IDLE\000"
 1578      00
 1579 0005 000000   		.section	.text.vTaskStartScheduler,"ax",%progbits
 1580              		.align	2
 1581              		.global	vTaskStartScheduler
 1582              		.thumb
 1583              		.thumb_func
 1585              	vTaskStartScheduler:
 1586              	.LFB11:
1451:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1452:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1453:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1454:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1455:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** void vTaskStartScheduler( void )
1456:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** {
 1587              		.loc 1 1456 0
 1588              		.cfi_startproc
 1589              		@ args = 0, pretend = 0, frame = 8
 1590              		@ frame_needed = 1, uses_anonymous_args = 0
 1591 0000 80B5     		push	{r7, lr}
 1592              	.LCFI30:
 1593              		.cfi_def_cfa_offset 8
 1594              		.cfi_offset 7, -8
 1595              		.cfi_offset 14, -4
 1596 0002 86B0     		sub	sp, sp, #24
 1597              	.LCFI31:
 1598              		.cfi_def_cfa_offset 32
 1599 0004 04AF     		add	r7, sp, #16
 1600              	.LCFI32:
 1601              		.cfi_def_cfa 7, 16
1457:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
1458:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1459:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1460:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1461:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
1462:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
1463:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		be returned by the xTaskGetIdleTaskHandle() function. */
1464:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORI
1465:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
1466:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#else
1467:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
1468:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Create the idle task without storing its handle. */
1469:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORI
 1602              		.loc 1 1469 0
 1603 0006 0023     		movs	r3, #0
 1604 0008 0093     		str	r3, [sp]
 1605 000a 0023     		movs	r3, #0
 1606 000c 0193     		str	r3, [sp, #4]
 1607 000e 0023     		movs	r3, #0
 1608 0010 0293     		str	r3, [sp, #8]
 1609 0012 0023     		movs	r3, #0
 1610 0014 0393     		str	r3, [sp, #12]
 1611 0016 40F20000 		movw	r0, #:lower16:prvIdleTask
 1612 001a C0F20000 		movt	r0, #:upper16:prvIdleTask
 1613 001e 40F20001 		movw	r1, #:lower16:.LC0
 1614 0022 C0F20001 		movt	r1, #:upper16:.LC0
 1615 0026 8222     		movs	r2, #130
 1616 0028 0023     		movs	r3, #0
 1617 002a FFF7FEFF 		bl	xTaskGenericCreate
 1618 002e 7860     		str	r0, [r7, #4]
1470:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
1471:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_xTaskGetIdleTaskHandle */
1472:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1473:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1474:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
1475:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( xReturn == pdPASS )
 1619              		.loc 1 1475 0
 1620 0030 7B68     		ldr	r3, [r7, #4]
 1621 0032 012B     		cmp	r3, #1
 1622 0034 02D1     		bne	.L99
1476:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
1477:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			xReturn = xTimerCreateTimerTask();
 1623              		.loc 1 1477 0
 1624 0036 FFF7FEFF 		bl	xTimerCreateTimerTask
 1625 003a 7860     		str	r0, [r7, #4]
 1626              	.L99:
1478:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
1479:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
1480:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
1481:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1482:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
1483:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
1484:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_TIMERS */
1485:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1486:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
 1627              		.loc 1 1486 0
 1628 003c 7B68     		ldr	r3, [r7, #4]
 1629 003e 012B     		cmp	r3, #1
 1630 0040 10D1     		bne	.L100
1487:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
1488:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1489:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1490:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1491:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1492:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		starts to run. */
1493:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
 1631              		.loc 1 1493 0
 1632 0042 FFF7FEFF 		bl	ulPortSetInterruptMask
1494:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1495:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
1496:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
1497:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
1498:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			structure specific to the task that will run first. */
1499:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
1500:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
1501:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
1502:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1503:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1633              		.loc 1 1503 0
 1634 0046 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 1635 004a C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 1636 004e 0122     		movs	r2, #1
 1637 0050 1A60     		str	r2, [r3]
1504:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		xTickCount = ( TickType_t ) 0U;
 1638              		.loc 1 1504 0
 1639 0052 40F20003 		movw	r3, #:lower16:xTickCount
 1640 0056 C0F20003 		movt	r3, #:upper16:xTickCount
 1641 005a 0022     		movs	r2, #0
 1642 005c 1A60     		str	r2, [r3]
1505:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1506:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1507:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1508:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		the run time counter time base. */
1509:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1510:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1511:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1512:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		portable interface. */
1513:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
 1643              		.loc 1 1513 0
 1644 005e FFF7FEFF 		bl	xPortStartScheduler
 1645 0062 05E0     		b	.L98
 1646              	.L100:
1514:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
1515:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1516:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			function will not return. */
1517:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
1518:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
1519:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
1520:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1521:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
1522:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
1523:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	else
1524:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
1525:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* This line will only be reached if the kernel could not be started,
1526:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		because there was not enough FreeRTOS heap to create the idle task
1527:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		or the timer task. */
1528:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		configASSERT( xReturn );
 1647              		.loc 1 1528 0
 1648 0064 7B68     		ldr	r3, [r7, #4]
 1649 0066 002B     		cmp	r3, #0
 1650 0068 02D1     		bne	.L98
 1651              		.loc 1 1528 0 is_stmt 0 discriminator 1
 1652 006a FFF7FEFF 		bl	ulPortSetInterruptMask
 1653              	.L102:
 1654 006e FEE7     		b	.L102
 1655              	.L98:
1529:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
1530:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** }
 1656              		.loc 1 1530 0 is_stmt 1
 1657 0070 0837     		adds	r7, r7, #8
 1658 0072 BD46     		mov	sp, r7
 1659              		@ sp needed
 1660 0074 80BD     		pop	{r7, pc}
 1661              		.cfi_endproc
 1662              	.LFE11:
 1664 0076 00BF     		.section	.text.vTaskEndScheduler,"ax",%progbits
 1665              		.align	2
 1666              		.global	vTaskEndScheduler
 1667              		.thumb
 1668              		.thumb_func
 1670              	vTaskEndScheduler:
 1671              	.LFB12:
1531:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1532:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1533:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** void vTaskEndScheduler( void )
1534:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** {
 1672              		.loc 1 1534 0
 1673              		.cfi_startproc
 1674              		@ args = 0, pretend = 0, frame = 0
 1675              		@ frame_needed = 1, uses_anonymous_args = 0
 1676 0000 80B5     		push	{r7, lr}
 1677              	.LCFI33:
 1678              		.cfi_def_cfa_offset 8
 1679              		.cfi_offset 7, -8
 1680              		.cfi_offset 14, -4
 1681 0002 00AF     		add	r7, sp, #0
 1682              	.LCFI34:
 1683              		.cfi_def_cfa_register 7
1535:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1536:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1537:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1538:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	portDISABLE_INTERRUPTS();
 1684              		.loc 1 1538 0
 1685 0004 FFF7FEFF 		bl	ulPortSetInterruptMask
1539:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1686              		.loc 1 1539 0
 1687 0008 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 1688 000c C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 1689 0010 0022     		movs	r2, #0
 1690 0012 1A60     		str	r2, [r3]
1540:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	vPortEndScheduler();
 1691              		.loc 1 1540 0
 1692 0014 FFF7FEFF 		bl	vPortEndScheduler
1541:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** }
 1693              		.loc 1 1541 0
 1694 0018 80BD     		pop	{r7, pc}
 1695              		.cfi_endproc
 1696              	.LFE12:
 1698 001a 00BF     		.section	.text.vTaskSuspendAll,"ax",%progbits
 1699              		.align	2
 1700              		.global	vTaskSuspendAll
 1701              		.thumb
 1702              		.thumb_func
 1704              	vTaskSuspendAll:
 1705              	.LFB13:
1542:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1543:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1544:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** void vTaskSuspendAll( void )
1545:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** {
 1706              		.loc 1 1545 0
 1707              		.cfi_startproc
 1708              		@ args = 0, pretend = 0, frame = 0
 1709              		@ frame_needed = 1, uses_anonymous_args = 0
 1710              		@ link register save eliminated.
 1711 0000 80B4     		push	{r7}
 1712              	.LCFI35:
 1713              		.cfi_def_cfa_offset 4
 1714              		.cfi_offset 7, -4
 1715 0002 00AF     		add	r7, sp, #0
 1716              	.LCFI36:
 1717              		.cfi_def_cfa_register 7
1546:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* A critical section is not required as the variable is of type
1547:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	BaseType_t.  Please read Richard Barry's reply in the following link to a
1548:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	post in the FreeRTOS support forum before reporting this as a bug! -
1549:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	http://goo.gl/wu4acr */
1550:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	++uxSchedulerSuspended;
 1718              		.loc 1 1550 0
 1719 0004 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1720 0008 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1721 000c 1B68     		ldr	r3, [r3]
 1722 000e 5A1C     		adds	r2, r3, #1
 1723 0010 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1724 0014 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1725 0018 1A60     		str	r2, [r3]
1551:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** }
 1726              		.loc 1 1551 0
 1727 001a BD46     		mov	sp, r7
 1728              		@ sp needed
 1729 001c 5DF8047B 		ldr	r7, [sp], #4
 1730 0020 7047     		bx	lr
 1731              		.cfi_endproc
 1732              	.LFE13:
 1734 0022 00BF     		.section	.text.xTaskResumeAll,"ax",%progbits
 1735              		.align	2
 1736              		.global	xTaskResumeAll
 1737              		.thumb
 1738              		.thumb_func
 1740              	xTaskResumeAll:
 1741              	.LFB14:
1552:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1553:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1554:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1555:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1556:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void )
1557:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
1558:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	TickType_t xReturn;
1559:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1560:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
1561:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
1562:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			xReturn = 0;
1563:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
1564:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
1565:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
1566:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* There are other idle priority tasks in the ready state.  If
1567:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			time slicing is used then the very next tick interrupt must be
1568:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			processed. */
1569:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			xReturn = 0;
1570:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
1571:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
1572:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
1573:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			xReturn = xNextTaskUnblockTime - xTickCount;
1574:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
1575:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1576:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		return xReturn;
1577:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
1578:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1579:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
1580:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1581:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1582:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** BaseType_t xTaskResumeAll( void )
1583:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** {
 1742              		.loc 1 1583 0
 1743              		.cfi_startproc
 1744              		@ args = 0, pretend = 0, frame = 8
 1745              		@ frame_needed = 1, uses_anonymous_args = 0
 1746 0000 80B5     		push	{r7, lr}
 1747              	.LCFI37:
 1748              		.cfi_def_cfa_offset 8
 1749              		.cfi_offset 7, -8
 1750              		.cfi_offset 14, -4
 1751 0002 82B0     		sub	sp, sp, #8
 1752              	.LCFI38:
 1753              		.cfi_def_cfa_offset 16
 1754 0004 00AF     		add	r7, sp, #0
 1755              	.LCFI39:
 1756              		.cfi_def_cfa_register 7
1584:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** TCB_t *pxTCB;
1585:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** BaseType_t xAlreadyYielded = pdFALSE;
 1757              		.loc 1 1585 0
 1758 0006 0023     		movs	r3, #0
 1759 0008 7B60     		str	r3, [r7, #4]
1586:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1587:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
1588:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	previous call to vTaskSuspendAll(). */
1589:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended );
 1760              		.loc 1 1589 0
 1761 000a 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1762 000e C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1763 0012 1B68     		ldr	r3, [r3]
 1764 0014 002B     		cmp	r3, #0
 1765 0016 02D1     		bne	.L106
 1766              		.loc 1 1589 0 is_stmt 0 discriminator 1
 1767 0018 FFF7FEFF 		bl	ulPortSetInterruptMask
 1768              	.L107:
 1769 001c FEE7     		b	.L107
 1770              	.L106:
1590:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1591:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1592:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1593:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1594:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1595:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
1596:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
 1771              		.loc 1 1596 0 is_stmt 1
 1772 001e FFF7FEFF 		bl	vPortEnterCritical
1597:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
1598:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		--uxSchedulerSuspended;
 1773              		.loc 1 1598 0
 1774 0022 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1775 0026 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1776 002a 1B68     		ldr	r3, [r3]
 1777 002c 5A1E     		subs	r2, r3, #1
 1778 002e 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1779 0032 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1780 0036 1A60     		str	r2, [r3]
1599:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1600:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1781              		.loc 1 1600 0
 1782 0038 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1783 003c C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1784 0040 1B68     		ldr	r3, [r3]
 1785 0042 002B     		cmp	r3, #0
 1786 0044 7FD1     		bne	.L108
1601:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
1602:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 1787              		.loc 1 1602 0
 1788 0046 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 1789 004a C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 1790 004e 1B68     		ldr	r3, [r3]
 1791 0050 002B     		cmp	r3, #0
 1792 0052 78D0     		beq	.L108
1603:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
1604:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
1605:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				appropriate ready list. */
1606:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 1793              		.loc 1 1606 0
 1794 0054 40E0     		b	.L109
 1795              	.L110:
1607:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
1608:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 1796              		.loc 1 1608 0
 1797 0056 40F20003 		movw	r3, #:lower16:xPendingReadyList
 1798 005a C0F20003 		movt	r3, #:upper16:xPendingReadyList
 1799 005e DB68     		ldr	r3, [r3, #12]
 1800 0060 DB68     		ldr	r3, [r3, #12]
 1801 0062 3B60     		str	r3, [r7]
1609:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1802              		.loc 1 1609 0
 1803 0064 3B68     		ldr	r3, [r7]
 1804 0066 1833     		adds	r3, r3, #24
 1805 0068 1846     		mov	r0, r3
 1806 006a FFF7FEFF 		bl	uxListRemove
1610:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 1807              		.loc 1 1610 0
 1808 006e 3B68     		ldr	r3, [r7]
 1809 0070 0433     		adds	r3, r3, #4
 1810 0072 1846     		mov	r0, r3
 1811 0074 FFF7FEFF 		bl	uxListRemove
1611:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1812              		.loc 1 1611 0
 1813 0078 3B68     		ldr	r3, [r7]
 1814 007a DB6A     		ldr	r3, [r3, #44]
 1815 007c 0122     		movs	r2, #1
 1816 007e 9A40     		lsls	r2, r2, r3
 1817 0080 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1818 0084 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1819 0088 1B68     		ldr	r3, [r3]
 1820 008a 1A43     		orrs	r2, r2, r3
 1821 008c 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1822 0090 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1823 0094 1A60     		str	r2, [r3]
 1824 0096 3B68     		ldr	r3, [r7]
 1825 0098 DA6A     		ldr	r2, [r3, #44]
 1826 009a 1346     		mov	r3, r2
 1827 009c 9B00     		lsls	r3, r3, #2
 1828 009e 1344     		add	r3, r3, r2
 1829 00a0 9B00     		lsls	r3, r3, #2
 1830 00a2 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 1831 00a6 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 1832 00aa 1A44     		add	r2, r2, r3
 1833 00ac 3B68     		ldr	r3, [r7]
 1834 00ae 0433     		adds	r3, r3, #4
 1835 00b0 1046     		mov	r0, r2
 1836 00b2 1946     		mov	r1, r3
 1837 00b4 FFF7FEFF 		bl	vListInsertEnd
1612:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1613:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					/* If we have moved a task that has a priority higher than
1614:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					the current task then we should yield. */
1615:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1838              		.loc 1 1615 0
 1839 00b8 3B68     		ldr	r3, [r7]
 1840 00ba DA6A     		ldr	r2, [r3, #44]
 1841 00bc 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1842 00c0 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1843 00c4 1B68     		ldr	r3, [r3]
 1844 00c6 DB6A     		ldr	r3, [r3, #44]
 1845 00c8 9A42     		cmp	r2, r3
 1846 00ca 05D3     		bcc	.L109
1616:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					{
1617:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						xYieldPending = pdTRUE;
 1847              		.loc 1 1617 0
 1848 00cc 40F20003 		movw	r3, #:lower16:xYieldPending
 1849 00d0 C0F20003 		movt	r3, #:upper16:xYieldPending
 1850 00d4 0122     		movs	r2, #1
 1851 00d6 1A60     		str	r2, [r3]
 1852              	.L109:
1606:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
 1853              		.loc 1 1606 0 discriminator 1
 1854 00d8 40F20003 		movw	r3, #:lower16:xPendingReadyList
 1855 00dc C0F20003 		movt	r3, #:upper16:xPendingReadyList
 1856 00e0 1B68     		ldr	r3, [r3]
 1857 00e2 002B     		cmp	r3, #0
 1858 00e4 B7D1     		bne	.L110
1618:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					}
1619:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					else
1620:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					{
1621:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1622:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					}
1623:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
1624:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1625:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1626:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				they should be processed now.  This ensures the tick count does
1627:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				not	slip, and that any delayed tasks are resumed at the correct
1628:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				time. */
1629:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				if( uxPendedTicks > ( UBaseType_t ) 0U )
 1859              		.loc 1 1629 0
 1860 00e6 40F20003 		movw	r3, #:lower16:uxPendedTicks
 1861 00ea C0F20003 		movt	r3, #:upper16:uxPendedTicks
 1862 00ee 1B68     		ldr	r3, [r3]
 1863 00f0 002B     		cmp	r3, #0
 1864 00f2 1DD0     		beq	.L111
1630:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
1631:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					while( uxPendedTicks > ( UBaseType_t ) 0U )
 1865              		.loc 1 1631 0
 1866 00f4 15E0     		b	.L112
 1867              	.L114:
1632:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					{
1633:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						if( xTaskIncrementTick() != pdFALSE )
 1868              		.loc 1 1633 0
 1869 00f6 FFF7FEFF 		bl	xTaskIncrementTick
 1870 00fa 0346     		mov	r3, r0
 1871 00fc 002B     		cmp	r3, #0
 1872 00fe 05D0     		beq	.L113
1634:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						{
1635:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							xYieldPending = pdTRUE;
 1873              		.loc 1 1635 0
 1874 0100 40F20003 		movw	r3, #:lower16:xYieldPending
 1875 0104 C0F20003 		movt	r3, #:upper16:xYieldPending
 1876 0108 0122     		movs	r2, #1
 1877 010a 1A60     		str	r2, [r3]
 1878              	.L113:
1636:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						}
1637:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						else
1638:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						{
1639:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
1640:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						}
1641:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						--uxPendedTicks;
 1879              		.loc 1 1641 0
 1880 010c 40F20003 		movw	r3, #:lower16:uxPendedTicks
 1881 0110 C0F20003 		movt	r3, #:upper16:uxPendedTicks
 1882 0114 1B68     		ldr	r3, [r3]
 1883 0116 5A1E     		subs	r2, r3, #1
 1884 0118 40F20003 		movw	r3, #:lower16:uxPendedTicks
 1885 011c C0F20003 		movt	r3, #:upper16:uxPendedTicks
 1886 0120 1A60     		str	r2, [r3]
 1887              	.L112:
1631:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					{
 1888              		.loc 1 1631 0 discriminator 1
 1889 0122 40F20003 		movw	r3, #:lower16:uxPendedTicks
 1890 0126 C0F20003 		movt	r3, #:upper16:uxPendedTicks
 1891 012a 1B68     		ldr	r3, [r3]
 1892 012c 002B     		cmp	r3, #0
 1893 012e E2D1     		bne	.L114
 1894              	.L111:
1642:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					}
1643:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
1644:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				else
1645:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
1646:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1647:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
1648:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1649:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				if( xYieldPending == pdTRUE )
 1895              		.loc 1 1649 0
 1896 0130 40F20003 		movw	r3, #:lower16:xYieldPending
 1897 0134 C0F20003 		movt	r3, #:upper16:xYieldPending
 1898 0138 1B68     		ldr	r3, [r3]
 1899 013a 012B     		cmp	r3, #1
 1900 013c 03D1     		bne	.L108
1650:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
1651:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					#if( configUSE_PREEMPTION != 0 )
1652:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					{
1653:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						xAlreadyYielded = pdTRUE;
 1901              		.loc 1 1653 0
 1902 013e 0123     		movs	r3, #1
 1903 0140 7B60     		str	r3, [r7, #4]
1654:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					}
1655:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					#endif
1656:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
 1904              		.loc 1 1656 0
 1905 0142 FFF7FEFF 		bl	vPortYield
 1906              	.L108:
1657:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
1658:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				else
1659:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
1660:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1661:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
1662:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
1663:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
1664:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
1665:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
1666:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1667:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
1668:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
1669:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
 1907              		.loc 1 1669 0
 1908 0146 FFF7FEFF 		bl	vPortExitCritical
1670:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1671:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	return xAlreadyYielded;
 1909              		.loc 1 1671 0
 1910 014a 7B68     		ldr	r3, [r7, #4]
1672:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** }
 1911              		.loc 1 1672 0
 1912 014c 1846     		mov	r0, r3
 1913 014e 0837     		adds	r7, r7, #8
 1914 0150 BD46     		mov	sp, r7
 1915              		@ sp needed
 1916 0152 80BD     		pop	{r7, pc}
 1917              		.cfi_endproc
 1918              	.LFE14:
 1920              		.section	.text.xTaskGetTickCount,"ax",%progbits
 1921              		.align	2
 1922              		.global	xTaskGetTickCount
 1923              		.thumb
 1924              		.thumb_func
 1926              	xTaskGetTickCount:
 1927              	.LFB15:
1673:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1674:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1675:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** TickType_t xTaskGetTickCount( void )
1676:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** {
 1928              		.loc 1 1676 0
 1929              		.cfi_startproc
 1930              		@ args = 0, pretend = 0, frame = 8
 1931              		@ frame_needed = 1, uses_anonymous_args = 0
 1932 0000 80B5     		push	{r7, lr}
 1933              	.LCFI40:
 1934              		.cfi_def_cfa_offset 8
 1935              		.cfi_offset 7, -8
 1936              		.cfi_offset 14, -4
 1937 0002 82B0     		sub	sp, sp, #8
 1938              	.LCFI41:
 1939              		.cfi_def_cfa_offset 16
 1940 0004 00AF     		add	r7, sp, #0
 1941              	.LCFI42:
 1942              		.cfi_def_cfa_register 7
1677:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** TickType_t xTicks;
1678:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1679:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
1680:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
 1943              		.loc 1 1680 0
 1944 0006 FFF7FEFF 		bl	vPortEnterCritical
1681:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
1682:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		xTicks = xTickCount;
 1945              		.loc 1 1682 0
 1946 000a 40F20003 		movw	r3, #:lower16:xTickCount
 1947 000e C0F20003 		movt	r3, #:upper16:xTickCount
 1948 0012 1B68     		ldr	r3, [r3]
 1949 0014 7B60     		str	r3, [r7, #4]
1683:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
1684:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
 1950              		.loc 1 1684 0
 1951 0016 FFF7FEFF 		bl	vPortExitCritical
1685:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1686:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	return xTicks;
 1952              		.loc 1 1686 0
 1953 001a 7B68     		ldr	r3, [r7, #4]
1687:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** }
 1954              		.loc 1 1687 0
 1955 001c 1846     		mov	r0, r3
 1956 001e 0837     		adds	r7, r7, #8
 1957 0020 BD46     		mov	sp, r7
 1958              		@ sp needed
 1959 0022 80BD     		pop	{r7, pc}
 1960              		.cfi_endproc
 1961              	.LFE15:
 1963              		.section	.text.xTaskGetTickCountFromISR,"ax",%progbits
 1964              		.align	2
 1965              		.global	xTaskGetTickCountFromISR
 1966              		.thumb
 1967              		.thumb_func
 1969              	xTaskGetTickCountFromISR:
 1970              	.LFB16:
1688:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1689:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1690:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** TickType_t xTaskGetTickCountFromISR( void )
1691:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** {
 1971              		.loc 1 1691 0
 1972              		.cfi_startproc
 1973              		@ args = 0, pretend = 0, frame = 8
 1974              		@ frame_needed = 1, uses_anonymous_args = 0
 1975 0000 80B5     		push	{r7, lr}
 1976              	.LCFI43:
 1977              		.cfi_def_cfa_offset 8
 1978              		.cfi_offset 7, -8
 1979              		.cfi_offset 14, -4
 1980 0002 82B0     		sub	sp, sp, #8
 1981              	.LCFI44:
 1982              		.cfi_def_cfa_offset 16
 1983 0004 00AF     		add	r7, sp, #0
 1984              	.LCFI45:
 1985              		.cfi_def_cfa_register 7
1692:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** TickType_t xReturn;
1693:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** UBaseType_t uxSavedInterruptStatus;
1694:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1695:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1696:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1697:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	above the maximum system call priority are kept permanently enabled, even
1698:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1699:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1700:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1701:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1702:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	assigned a priority above the configured maximum system call priority.
1703:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1704:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	that have been assigned a priority at or (logically) below the maximum
1705:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1706:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1707:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	More information (albeit Cortex-M specific) is provided on the following
1708:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1709:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 1986              		.loc 1 1709 0
 1987 0006 FFF7FEFF 		bl	vPortValidateInterruptPriority
1710:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1711:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1988              		.loc 1 1711 0
 1989 000a FFF7FEFF 		bl	ulPortSetInterruptMask
 1990 000e 7860     		str	r0, [r7, #4]
1712:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
1713:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		xReturn = xTickCount;
 1991              		.loc 1 1713 0
 1992 0010 40F20003 		movw	r3, #:lower16:xTickCount
 1993 0014 C0F20003 		movt	r3, #:upper16:xTickCount
 1994 0018 1B68     		ldr	r3, [r3]
 1995 001a 3B60     		str	r3, [r7]
1714:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
1715:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1996              		.loc 1 1715 0
 1997 001c 7868     		ldr	r0, [r7, #4]
 1998 001e FFF7FEFF 		bl	vPortClearInterruptMask
1716:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1717:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	return xReturn;
 1999              		.loc 1 1717 0
 2000 0022 3B68     		ldr	r3, [r7]
1718:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** }
 2001              		.loc 1 1718 0
 2002 0024 1846     		mov	r0, r3
 2003 0026 0837     		adds	r7, r7, #8
 2004 0028 BD46     		mov	sp, r7
 2005              		@ sp needed
 2006 002a 80BD     		pop	{r7, pc}
 2007              		.cfi_endproc
 2008              	.LFE16:
 2010              		.section	.text.uxTaskGetNumberOfTasks,"ax",%progbits
 2011              		.align	2
 2012              		.global	uxTaskGetNumberOfTasks
 2013              		.thumb
 2014              		.thumb_func
 2016              	uxTaskGetNumberOfTasks:
 2017              	.LFB17:
1719:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1720:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1721:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** UBaseType_t uxTaskGetNumberOfTasks( void )
1722:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** {
 2018              		.loc 1 1722 0
 2019              		.cfi_startproc
 2020              		@ args = 0, pretend = 0, frame = 0
 2021              		@ frame_needed = 1, uses_anonymous_args = 0
 2022              		@ link register save eliminated.
 2023 0000 80B4     		push	{r7}
 2024              	.LCFI46:
 2025              		.cfi_def_cfa_offset 4
 2026              		.cfi_offset 7, -4
 2027 0002 00AF     		add	r7, sp, #0
 2028              	.LCFI47:
 2029              		.cfi_def_cfa_register 7
1723:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* A critical section is not required because the variables are of type
1724:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	BaseType_t. */
1725:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	return uxCurrentNumberOfTasks;
 2030              		.loc 1 1725 0
 2031 0004 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 2032 0008 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 2033 000c 1B68     		ldr	r3, [r3]
1726:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** }
 2034              		.loc 1 1726 0
 2035 000e 1846     		mov	r0, r3
 2036 0010 BD46     		mov	sp, r7
 2037              		@ sp needed
 2038 0012 5DF8047B 		ldr	r7, [sp], #4
 2039 0016 7047     		bx	lr
 2040              		.cfi_endproc
 2041              	.LFE17:
 2043              		.section	.text.uxTaskGetSystemState,"ax",%progbits
 2044              		.align	2
 2045              		.global	uxTaskGetSystemState
 2046              		.thumb
 2047              		.thumb_func
 2049              	uxTaskGetSystemState:
 2050              	.LFB18:
1727:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1728:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1729:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_pcTaskGetTaskName == 1 )
1730:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1731:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	char *pcTaskGetTaskName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allow
1732:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
1733:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1734:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1735:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then the name of the calling task is being queried. */
1736:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1737:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		configASSERT( pxTCB );
1738:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		return &( pxTCB->pcTaskName[ 0 ] );
1739:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
1740:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1741:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_pcTaskGetTaskName */
1742:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1743:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1744:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1745:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1746:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArra
1747:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
 2051              		.loc 1 1747 0
 2052              		.cfi_startproc
 2053              		@ args = 0, pretend = 0, frame = 24
 2054              		@ frame_needed = 1, uses_anonymous_args = 0
 2055 0000 80B5     		push	{r7, lr}
 2056              	.LCFI48:
 2057              		.cfi_def_cfa_offset 8
 2058              		.cfi_offset 7, -8
 2059              		.cfi_offset 14, -4
 2060 0002 86B0     		sub	sp, sp, #24
 2061              	.LCFI49:
 2062              		.cfi_def_cfa_offset 32
 2063 0004 00AF     		add	r7, sp, #0
 2064              	.LCFI50:
 2065              		.cfi_def_cfa_register 7
 2066 0006 F860     		str	r0, [r7, #12]
 2067 0008 B960     		str	r1, [r7, #8]
 2068 000a 7A60     		str	r2, [r7, #4]
1748:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
 2069              		.loc 1 1748 0
 2070 000c 0023     		movs	r3, #0
 2071 000e 7B61     		str	r3, [r7, #20]
 2072 0010 0523     		movs	r3, #5
 2073 0012 3B61     		str	r3, [r7, #16]
1749:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1750:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
 2074              		.loc 1 1750 0
 2075 0014 FFF7FEFF 		bl	vTaskSuspendAll
1751:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
1752:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Is there a space in the array for each task in the system? */
1753:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			if( uxArraySize >= uxCurrentNumberOfTasks )
 2076              		.loc 1 1753 0
 2077 0018 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 2078 001c C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 2079 0020 1B68     		ldr	r3, [r3]
 2080 0022 BA68     		ldr	r2, [r7, #8]
 2081 0024 9A42     		cmp	r2, r3
 2082 0026 66D3     		bcc	.L123
 2083              	.L124:
1754:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
1755:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
1756:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				task in the Ready state. */
1757:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				do
1758:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
1759:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					uxQueue--;
 2084              		.loc 1 1759 0 discriminator 1
 2085 0028 3B69     		ldr	r3, [r7, #16]
 2086 002a 013B     		subs	r3, r3, #1
 2087 002c 3B61     		str	r3, [r7, #16]
1760:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[
 2088              		.loc 1 1760 0 discriminator 1
 2089 002e 7B69     		ldr	r3, [r7, #20]
 2090 0030 5B01     		lsls	r3, r3, #5
 2091 0032 FA68     		ldr	r2, [r7, #12]
 2092 0034 D118     		adds	r1, r2, r3
 2093 0036 3A69     		ldr	r2, [r7, #16]
 2094 0038 1346     		mov	r3, r2
 2095 003a 9B00     		lsls	r3, r3, #2
 2096 003c 1344     		add	r3, r3, r2
 2097 003e 9B00     		lsls	r3, r3, #2
 2098 0040 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 2099 0044 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 2100 0048 1344     		add	r3, r3, r2
 2101 004a 0846     		mov	r0, r1
 2102 004c 1946     		mov	r1, r3
 2103 004e 0122     		movs	r2, #1
 2104 0050 FFF7FEFF 		bl	prvListTaskWithinSingleList
 2105 0054 0346     		mov	r3, r0
 2106 0056 7A69     		ldr	r2, [r7, #20]
 2107 0058 1344     		add	r3, r3, r2
 2108 005a 7B61     		str	r3, [r7, #20]
1761:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1762:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the cast
 2109              		.loc 1 1762 0 discriminator 1
 2110 005c 3B69     		ldr	r3, [r7, #16]
 2111 005e 002B     		cmp	r3, #0
 2112 0060 E2D1     		bne	.L124
1763:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1764:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
1765:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				task in the Blocked state. */
1766:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayed
 2113              		.loc 1 1766 0
 2114 0062 7B69     		ldr	r3, [r7, #20]
 2115 0064 5B01     		lsls	r3, r3, #5
 2116 0066 FA68     		ldr	r2, [r7, #12]
 2117 0068 1A44     		add	r2, r2, r3
 2118 006a 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2119 006e C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2120 0072 1B68     		ldr	r3, [r3]
 2121 0074 1046     		mov	r0, r2
 2122 0076 1946     		mov	r1, r3
 2123 0078 0222     		movs	r2, #2
 2124 007a FFF7FEFF 		bl	prvListTaskWithinSingleList
 2125 007e 0346     		mov	r3, r0
 2126 0080 7A69     		ldr	r2, [r7, #20]
 2127 0082 1344     		add	r3, r3, r2
 2128 0084 7B61     		str	r3, [r7, #20]
1767:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflo
 2129              		.loc 1 1767 0
 2130 0086 7B69     		ldr	r3, [r7, #20]
 2131 0088 5B01     		lsls	r3, r3, #5
 2132 008a FA68     		ldr	r2, [r7, #12]
 2133 008c 1A44     		add	r2, r2, r3
 2134 008e 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 2135 0092 C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 2136 0096 1B68     		ldr	r3, [r3]
 2137 0098 1046     		mov	r0, r2
 2138 009a 1946     		mov	r1, r3
 2139 009c 0222     		movs	r2, #2
 2140 009e FFF7FEFF 		bl	prvListTaskWithinSingleList
 2141 00a2 0346     		mov	r3, r0
 2142 00a4 7A69     		ldr	r2, [r7, #20]
 2143 00a6 1344     		add	r3, r3, r2
 2144 00a8 7B61     		str	r3, [r7, #20]
1768:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1769:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				#if( INCLUDE_vTaskDelete == 1 )
1770:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
1771:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
1772:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					each task that has been deleted but not yet cleaned up. */
1773:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermina
 2145              		.loc 1 1773 0
 2146 00aa 7B69     		ldr	r3, [r7, #20]
 2147 00ac 5B01     		lsls	r3, r3, #5
 2148 00ae FA68     		ldr	r2, [r7, #12]
 2149 00b0 1344     		add	r3, r3, r2
 2150 00b2 1846     		mov	r0, r3
 2151 00b4 40F20001 		movw	r1, #:lower16:xTasksWaitingTermination
 2152 00b8 C0F20001 		movt	r1, #:upper16:xTasksWaitingTermination
 2153 00bc 0422     		movs	r2, #4
 2154 00be FFF7FEFF 		bl	prvListTaskWithinSingleList
 2155 00c2 0346     		mov	r3, r0
 2156 00c4 7A69     		ldr	r2, [r7, #20]
 2157 00c6 1344     		add	r3, r3, r2
 2158 00c8 7B61     		str	r3, [r7, #20]
1774:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
1775:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				#endif
1776:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1777:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
1778:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
1779:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
1780:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					each task in the Suspended state. */
1781:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, 
 2159              		.loc 1 1781 0
 2160 00ca 7B69     		ldr	r3, [r7, #20]
 2161 00cc 5B01     		lsls	r3, r3, #5
 2162 00ce FA68     		ldr	r2, [r7, #12]
 2163 00d0 1344     		add	r3, r3, r2
 2164 00d2 1846     		mov	r0, r3
 2165 00d4 40F20001 		movw	r1, #:lower16:xSuspendedTaskList
 2166 00d8 C0F20001 		movt	r1, #:upper16:xSuspendedTaskList
 2167 00dc 0322     		movs	r2, #3
 2168 00de FFF7FEFF 		bl	prvListTaskWithinSingleList
 2169 00e2 0346     		mov	r3, r0
 2170 00e4 7A69     		ldr	r2, [r7, #20]
 2171 00e6 1344     		add	r3, r3, r2
 2172 00e8 7B61     		str	r3, [r7, #20]
1782:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
1783:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				#endif
1784:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1785:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1)
1786:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
1787:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					if( pulTotalRunTime != NULL )
1788:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					{
1789:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1790:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
1791:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						#else
1792:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1793:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						#endif
1794:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					}
1795:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
1796:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				#else
1797:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
1798:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					if( pulTotalRunTime != NULL )
 2173              		.loc 1 1798 0
 2174 00ea 7B68     		ldr	r3, [r7, #4]
 2175 00ec 002B     		cmp	r3, #0
 2176 00ee 02D0     		beq	.L123
1799:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					{
1800:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						*pulTotalRunTime = 0;
 2177              		.loc 1 1800 0
 2178 00f0 7B68     		ldr	r3, [r7, #4]
 2179 00f2 0022     		movs	r2, #0
 2180 00f4 1A60     		str	r2, [r3]
 2181              	.L123:
1801:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					}
1802:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
1803:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				#endif
1804:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
1805:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			else
1806:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
1807:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1808:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
1809:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
1810:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		( void ) xTaskResumeAll();
 2182              		.loc 1 1810 0
 2183 00f6 FFF7FEFF 		bl	xTaskResumeAll
1811:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1812:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		return uxTask;
 2184              		.loc 1 1812 0
 2185 00fa 7B69     		ldr	r3, [r7, #20]
1813:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
 2186              		.loc 1 1813 0
 2187 00fc 1846     		mov	r0, r3
 2188 00fe 1837     		adds	r7, r7, #24
 2189 0100 BD46     		mov	sp, r7
 2190              		@ sp needed
 2191 0102 80BD     		pop	{r7, pc}
 2192              		.cfi_endproc
 2193              	.LFE18:
 2195              		.section	.text.xTaskIncrementTick,"ax",%progbits
 2196              		.align	2
 2197              		.global	xTaskIncrementTick
 2198              		.thumb
 2199              		.thumb_func
 2201              	xTaskIncrementTick:
 2202              	.LFB19:
1814:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1815:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
1816:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1817:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1818:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1819:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1820:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	TaskHandle_t xTaskGetIdleTaskHandle( void )
1821:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
1822:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1823:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
1824:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
1825:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		return xIdleTaskHandle;
1826:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
1827:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1828:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskGetIdleTaskHandle */
1829:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1830:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1831:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
1832:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** This is to ensure vTaskStepTick() is available when user defined low power mode
1833:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** implementations require configUSE_TICKLESS_IDLE to be set to a value other than
1834:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 1. */
1835:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1836:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1837:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	void vTaskStepTick( const TickType_t xTicksToJump )
1838:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
1839:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Correct the tick count value after a period during which the tick
1840:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		was suppressed.  Note this does *not* call the tick hook function for
1841:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		each stepped tick. */
1842:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
1843:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		xTickCount += xTicksToJump;
1844:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		traceINCREASE_TICK_COUNT( xTicksToJump );
1845:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
1846:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1847:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
1848:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1849:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1850:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** BaseType_t xTaskIncrementTick( void )
1851:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** {
 2203              		.loc 1 1851 0
 2204              		.cfi_startproc
 2205              		@ args = 0, pretend = 0, frame = 24
 2206              		@ frame_needed = 1, uses_anonymous_args = 0
 2207 0000 80B5     		push	{r7, lr}
 2208              	.LCFI51:
 2209              		.cfi_def_cfa_offset 8
 2210              		.cfi_offset 7, -8
 2211              		.cfi_offset 14, -4
 2212 0002 86B0     		sub	sp, sp, #24
 2213              	.LCFI52:
 2214              		.cfi_def_cfa_offset 32
 2215 0004 00AF     		add	r7, sp, #0
 2216              	.LCFI53:
 2217              		.cfi_def_cfa_register 7
1852:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** TCB_t * pxTCB;
1853:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** TickType_t xItemValue;
1854:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** BaseType_t xSwitchRequired = pdFALSE;
 2218              		.loc 1 1854 0
 2219 0006 0023     		movs	r3, #0
 2220 0008 7B61     		str	r3, [r7, #20]
1855:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1856:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
1857:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
1858:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	tasks to be unblocked. */
1859:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
1860:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2221              		.loc 1 1860 0
 2222 000a 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 2223 000e C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 2224 0012 1B68     		ldr	r3, [r3]
 2225 0014 002B     		cmp	r3, #0
 2226 0016 40F0CE80 		bne	.L128
1861:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
1862:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Increment the RTOS tick, switching the delayed and overflowed
1863:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		delayed lists if it wraps to 0. */
1864:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		++xTickCount;
 2227              		.loc 1 1864 0
 2228 001a 40F20003 		movw	r3, #:lower16:xTickCount
 2229 001e C0F20003 		movt	r3, #:upper16:xTickCount
 2230 0022 1B68     		ldr	r3, [r3]
 2231 0024 5A1C     		adds	r2, r3, #1
 2232 0026 40F20003 		movw	r3, #:lower16:xTickCount
 2233 002a C0F20003 		movt	r3, #:upper16:xTickCount
 2234 002e 1A60     		str	r2, [r3]
 2235              	.LBB9:
1865:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1866:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
1867:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
1868:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			block. */
1869:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			const TickType_t xConstTickCount = xTickCount;
 2236              		.loc 1 1869 0
 2237 0030 40F20003 		movw	r3, #:lower16:xTickCount
 2238 0034 C0F20003 		movt	r3, #:upper16:xTickCount
 2239 0038 1B68     		ldr	r3, [r3]
 2240 003a 3B61     		str	r3, [r7, #16]
1870:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1871:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			if( xConstTickCount == ( TickType_t ) 0U )
 2241              		.loc 1 1871 0
 2242 003c 3B69     		ldr	r3, [r7, #16]
 2243 003e 002B     		cmp	r3, #0
 2244 0040 2DD1     		bne	.L129
 2245              	.LBB10:
1872:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
1873:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				taskSWITCH_DELAYED_LISTS();
 2246              		.loc 1 1873 0
 2247 0042 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2248 0046 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2249 004a 1B68     		ldr	r3, [r3]
 2250 004c 1B68     		ldr	r3, [r3]
 2251 004e 002B     		cmp	r3, #0
 2252 0050 02D0     		beq	.L130
 2253              		.loc 1 1873 0 is_stmt 0 discriminator 1
 2254 0052 FFF7FEFF 		bl	ulPortSetInterruptMask
 2255              	.L131:
 2256 0056 FEE7     		b	.L131
 2257              	.L130:
 2258              		.loc 1 1873 0 discriminator 2
 2259 0058 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2260 005c C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2261 0060 1B68     		ldr	r3, [r3]
 2262 0062 FB60     		str	r3, [r7, #12]
 2263 0064 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 2264 0068 C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 2265 006c 1A68     		ldr	r2, [r3]
 2266 006e 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2267 0072 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2268 0076 1A60     		str	r2, [r3]
 2269 0078 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 2270 007c C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 2271 0080 FA68     		ldr	r2, [r7, #12]
 2272 0082 1A60     		str	r2, [r3]
 2273 0084 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 2274 0088 C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 2275 008c 1B68     		ldr	r3, [r3]
 2276 008e 5A1C     		adds	r2, r3, #1
 2277 0090 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 2278 0094 C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 2279 0098 1A60     		str	r2, [r3]
 2280 009a FFF7FEFF 		bl	prvResetNextTaskUnblockTime
 2281              	.L129:
 2282              	.LBE10:
1874:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
1875:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			else
1876:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
1877:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1878:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
1879:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1880:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* See if this tick has made a timeout expire.  Tasks are stored in
1881:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			the	queue in the order of their wake time - meaning once one task
1882:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			has been found whose block time has not expired there is no need to
1883:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			look any further	down the list. */
1884:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			if( xConstTickCount >= xNextTaskUnblockTime )
 2283              		.loc 1 1884 0 is_stmt 1
 2284 009e 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 2285 00a2 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 2286 00a6 1B68     		ldr	r3, [r3]
 2287 00a8 3A69     		ldr	r2, [r7, #16]
 2288 00aa 9A42     		cmp	r2, r3
 2289 00ac 65D3     		bcc	.L132
 2290              	.L139:
1885:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
1886:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				for( ;; )
1887:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
1888:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 2291              		.loc 1 1888 0
 2292 00ae 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2293 00b2 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2294 00b6 1B68     		ldr	r3, [r3]
 2295 00b8 1B68     		ldr	r3, [r3]
 2296 00ba 002B     		cmp	r3, #0
 2297 00bc 01D1     		bne	.L133
 2298              		.loc 1 1888 0 is_stmt 0 discriminator 1
 2299 00be 0123     		movs	r3, #1
 2300 00c0 00E0     		b	.L134
 2301              	.L133:
 2302              		.loc 1 1888 0 discriminator 2
 2303 00c2 0023     		movs	r3, #0
 2304              	.L134:
 2305              		.loc 1 1888 0 discriminator 3
 2306 00c4 002B     		cmp	r3, #0
 2307 00c6 07D0     		beq	.L135
1889:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					{
1890:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						/* The delayed list is empty.  Set xNextTaskUnblockTime
1891:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						to the maximum possible value so it is extremely
1892:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						unlikely that the
1893:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						if( xTickCount >= xNextTaskUnblockTime ) test will pass
1894:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						next time through. */
1895:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						xNextTaskUnblockTime = portMAX_DELAY;
 2308              		.loc 1 1895 0 is_stmt 1
 2309 00c8 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 2310 00cc C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 2311 00d0 4FF0FF32 		mov	r2, #-1
 2312 00d4 1A60     		str	r2, [r3]
1896:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						break;
 2313              		.loc 1 1896 0
 2314 00d6 50E0     		b	.L132
 2315              	.L135:
1897:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					}
1898:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					else
1899:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					{
1900:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						/* The delayed list is not empty, get the value of the
1901:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						item at the head of the delayed list.  This is the time
1902:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						at which the task at the head of the delayed list must
1903:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						be removed from the Blocked state. */
1904:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 2316              		.loc 1 1904 0
 2317 00d8 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2318 00dc C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2319 00e0 1B68     		ldr	r3, [r3]
 2320 00e2 DB68     		ldr	r3, [r3, #12]
 2321 00e4 DB68     		ldr	r3, [r3, #12]
 2322 00e6 BB60     		str	r3, [r7, #8]
1905:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 2323              		.loc 1 1905 0
 2324 00e8 BB68     		ldr	r3, [r7, #8]
 2325 00ea 5B68     		ldr	r3, [r3, #4]
 2326 00ec 7B60     		str	r3, [r7, #4]
1906:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1907:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						if( xConstTickCount < xItemValue )
 2327              		.loc 1 1907 0
 2328 00ee 3A69     		ldr	r2, [r7, #16]
 2329 00f0 7B68     		ldr	r3, [r7, #4]
 2330 00f2 9A42     		cmp	r2, r3
 2331 00f4 06D2     		bcs	.L136
1908:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						{
1909:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							/* It is not time to unblock this item yet, but the
1910:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							item value is the time at which the task at the head
1911:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							of the blocked list must be removed from the Blocked
1912:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							state -	so record the item value in
1913:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							xNextTaskUnblockTime. */
1914:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							xNextTaskUnblockTime = xItemValue;
 2332              		.loc 1 1914 0
 2333 00f6 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 2334 00fa C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 2335 00fe 7A68     		ldr	r2, [r7, #4]
 2336 0100 1A60     		str	r2, [r3]
1915:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							break;
 2337              		.loc 1 1915 0
 2338 0102 3AE0     		b	.L132
 2339              	.L136:
1916:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						}
1917:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						else
1918:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						{
1919:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
1920:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						}
1921:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1922:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						/* It is time to remove the item from the Blocked state. */
1923:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 2340              		.loc 1 1923 0
 2341 0104 BB68     		ldr	r3, [r7, #8]
 2342 0106 0433     		adds	r3, r3, #4
 2343 0108 1846     		mov	r0, r3
 2344 010a FFF7FEFF 		bl	uxListRemove
1924:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1925:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						/* Is the task waiting on an event also?  If so remove
1926:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						it from the event list. */
1927:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 2345              		.loc 1 1927 0
 2346 010e BB68     		ldr	r3, [r7, #8]
 2347 0110 9B6A     		ldr	r3, [r3, #40]
 2348 0112 002B     		cmp	r3, #0
 2349 0114 04D0     		beq	.L137
1928:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						{
1929:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 2350              		.loc 1 1929 0
 2351 0116 BB68     		ldr	r3, [r7, #8]
 2352 0118 1833     		adds	r3, r3, #24
 2353 011a 1846     		mov	r0, r3
 2354 011c FFF7FEFF 		bl	uxListRemove
 2355              	.L137:
1930:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						}
1931:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						else
1932:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						{
1933:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
1934:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						}
1935:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1936:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						/* Place the unblocked task into the appropriate ready
1937:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						list. */
1938:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
 2356              		.loc 1 1938 0
 2357 0120 BB68     		ldr	r3, [r7, #8]
 2358 0122 DB6A     		ldr	r3, [r3, #44]
 2359 0124 0122     		movs	r2, #1
 2360 0126 9A40     		lsls	r2, r2, r3
 2361 0128 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2362 012c C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2363 0130 1B68     		ldr	r3, [r3]
 2364 0132 1A43     		orrs	r2, r2, r3
 2365 0134 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2366 0138 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2367 013c 1A60     		str	r2, [r3]
 2368 013e BB68     		ldr	r3, [r7, #8]
 2369 0140 DA6A     		ldr	r2, [r3, #44]
 2370 0142 1346     		mov	r3, r2
 2371 0144 9B00     		lsls	r3, r3, #2
 2372 0146 1344     		add	r3, r3, r2
 2373 0148 9B00     		lsls	r3, r3, #2
 2374 014a 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 2375 014e C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 2376 0152 1A44     		add	r2, r2, r3
 2377 0154 BB68     		ldr	r3, [r7, #8]
 2378 0156 0433     		adds	r3, r3, #4
 2379 0158 1046     		mov	r0, r2
 2380 015a 1946     		mov	r1, r3
 2381 015c FFF7FEFF 		bl	vListInsertEnd
1939:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1940:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						/* A task being unblocked cannot cause an immediate
1941:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						context switch if preemption is turned off. */
1942:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						#if (  configUSE_PREEMPTION == 1 )
1943:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						{
1944:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							/* Preemption is on, but a context switch should
1945:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							only be performed if the unblocked task has a
1946:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							priority that is equal to or higher than the
1947:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							currently executing task. */
1948:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2382              		.loc 1 1948 0
 2383 0160 BB68     		ldr	r3, [r7, #8]
 2384 0162 DA6A     		ldr	r2, [r3, #44]
 2385 0164 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2386 0168 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2387 016c 1B68     		ldr	r3, [r3]
 2388 016e DB6A     		ldr	r3, [r3, #44]
 2389 0170 9A42     		cmp	r2, r3
 2390 0172 01D3     		bcc	.L138
1949:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							{
1950:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 								xSwitchRequired = pdTRUE;
 2391              		.loc 1 1950 0
 2392 0174 0123     		movs	r3, #1
 2393 0176 7B61     		str	r3, [r7, #20]
 2394              	.L138:
1951:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							}
1952:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							else
1953:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							{
1954:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 								mtCOVERAGE_TEST_MARKER();
1955:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							}
1956:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						}
1957:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						#endif /* configUSE_PREEMPTION */
1958:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					}
1959:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
 2395              		.loc 1 1959 0
 2396 0178 99E7     		b	.L139
 2397              	.L132:
 2398              	.LBE9:
1960:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
1961:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
1962:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1963:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Tasks of equal priority to the currently running task will share
1964:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		processing time (time slice) if preemption is on, and the application
1965:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		writer has not explicitly turned time slicing off. */
1966:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
1967:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
1968:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_
 2399              		.loc 1 1968 0
 2400 017a 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2401 017e C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2402 0182 1B68     		ldr	r3, [r3]
 2403 0184 D96A     		ldr	r1, [r3, #44]
 2404 0186 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 2405 018a C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 2406 018e 0B46     		mov	r3, r1
 2407 0190 9B00     		lsls	r3, r3, #2
 2408 0192 0B44     		add	r3, r3, r1
 2409 0194 9B00     		lsls	r3, r3, #2
 2410 0196 1344     		add	r3, r3, r2
 2411 0198 1B68     		ldr	r3, [r3]
 2412 019a 012B     		cmp	r3, #1
 2413 019c 01D9     		bls	.L140
1969:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
1970:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				xSwitchRequired = pdTRUE;
 2414              		.loc 1 1970 0
 2415 019e 0123     		movs	r3, #1
 2416 01a0 7B61     		str	r3, [r7, #20]
 2417              	.L140:
1971:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
1972:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			else
1973:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
1974:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1975:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
1976:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
1977:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
1978:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1979:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
1980:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
1981:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Guard against the tick hook being called when the pended tick
1982:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			count is being unwound (when the scheduler is being unlocked). */
1983:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			if( uxPendedTicks == ( UBaseType_t ) 0U )
 2418              		.loc 1 1983 0
 2419 01a2 40F20003 		movw	r3, #:lower16:uxPendedTicks
 2420 01a6 C0F20003 		movt	r3, #:upper16:uxPendedTicks
 2421 01aa 1B68     		ldr	r3, [r3]
 2422 01ac 002B     		cmp	r3, #0
 2423 01ae 0FD1     		bne	.L141
1984:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
1985:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				vApplicationTickHook();
 2424              		.loc 1 1985 0
 2425 01b0 FFF7FEFF 		bl	vApplicationTickHook
 2426 01b4 0CE0     		b	.L141
 2427              	.L128:
1986:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
1987:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			else
1988:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
1989:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1990:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
1991:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
1992:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_TICK_HOOK */
1993:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
1994:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	else
1995:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
1996:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		++uxPendedTicks;
 2428              		.loc 1 1996 0
 2429 01b6 40F20003 		movw	r3, #:lower16:uxPendedTicks
 2430 01ba C0F20003 		movt	r3, #:upper16:uxPendedTicks
 2431 01be 1B68     		ldr	r3, [r3]
 2432 01c0 5A1C     		adds	r2, r3, #1
 2433 01c2 40F20003 		movw	r3, #:lower16:uxPendedTicks
 2434 01c6 C0F20003 		movt	r3, #:upper16:uxPendedTicks
 2435 01ca 1A60     		str	r2, [r3]
1997:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
1998:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
1999:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		scheduler is locked. */
2000:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2001:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2002:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			vApplicationTickHook();
 2436              		.loc 1 2002 0
 2437 01cc FFF7FEFF 		bl	vApplicationTickHook
 2438              	.L141:
2003:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2004:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#endif
2005:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2006:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2007:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#if ( configUSE_PREEMPTION == 1 )
2008:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2009:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( xYieldPending != pdFALSE )
 2439              		.loc 1 2009 0
 2440 01d0 40F20003 		movw	r3, #:lower16:xYieldPending
 2441 01d4 C0F20003 		movt	r3, #:upper16:xYieldPending
 2442 01d8 1B68     		ldr	r3, [r3]
 2443 01da 002B     		cmp	r3, #0
 2444 01dc 01D0     		beq	.L142
2010:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2011:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			xSwitchRequired = pdTRUE;
 2445              		.loc 1 2011 0
 2446 01de 0123     		movs	r3, #1
 2447 01e0 7B61     		str	r3, [r7, #20]
 2448              	.L142:
2012:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2013:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
2014:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2015:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2016:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2017:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2018:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_PREEMPTION */
2019:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2020:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	return xSwitchRequired;
 2449              		.loc 1 2020 0
 2450 01e2 7B69     		ldr	r3, [r7, #20]
2021:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** }
 2451              		.loc 1 2021 0
 2452 01e4 1846     		mov	r0, r3
 2453 01e6 1837     		adds	r7, r7, #24
 2454 01e8 BD46     		mov	sp, r7
 2455              		@ sp needed
 2456 01ea 80BD     		pop	{r7, pc}
 2457              		.cfi_endproc
 2458              	.LFE19:
 2460              		.section	.text.vTaskSwitchContext,"ax",%progbits
 2461              		.align	2
 2462              		.global	vTaskSwitchContext
 2463              		.thumb
 2464              		.thumb_func
 2466              	vTaskSwitchContext:
 2467              	.LFB20:
2022:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2023:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2024:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2025:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2026:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
2027:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2028:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	TCB_t *xTCB;
2029:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2030:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then it is the task hook of the calling task that is
2031:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		getting set. */
2032:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
2033:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2034:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2035:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2036:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
2037:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2038:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2039:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2040:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2041:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2042:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
2043:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
2044:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
2045:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
2046:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2047:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2048:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2049:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2050:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2051:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2052:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2053:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
2054:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2055:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	TCB_t *xTCB;
2056:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	TaskHookFunction_t xReturn;
2057:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2058:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
2059:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
2060:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2061:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2062:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2063:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
2064:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2065:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2066:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2067:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2068:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2069:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
2070:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
2071:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2072:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag;
2073:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2074:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
2075:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2076:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		return xReturn;
2077:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2078:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2079:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2080:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2081:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2082:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2083:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2084:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
2085:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2086:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	TCB_t *xTCB;
2087:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
2088:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2089:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
2090:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
2091:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2092:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2093:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2094:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
2095:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2096:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2097:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2098:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2099:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
2100:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2101:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
2102:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2103:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
2104:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2105:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			xReturn = pdFAIL;
2106:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2107:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2108:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		return xReturn;
2109:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2110:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2111:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2112:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2113:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2114:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** void vTaskSwitchContext( void )
2115:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** {
 2468              		.loc 1 2115 0
 2469              		.cfi_startproc
 2470              		@ args = 0, pretend = 0, frame = 16
 2471              		@ frame_needed = 1, uses_anonymous_args = 0
 2472 0000 80B5     		push	{r7, lr}
 2473              	.LCFI54:
 2474              		.cfi_def_cfa_offset 8
 2475              		.cfi_offset 7, -8
 2476              		.cfi_offset 14, -4
 2477 0002 84B0     		sub	sp, sp, #16
 2478              	.LCFI55:
 2479              		.cfi_def_cfa_offset 24
 2480 0004 00AF     		add	r7, sp, #0
 2481              	.LCFI56:
 2482              		.cfi_def_cfa_register 7
2116:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 2483              		.loc 1 2116 0
 2484 0006 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 2485 000a C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 2486 000e 1B68     		ldr	r3, [r3]
 2487 0010 002B     		cmp	r3, #0
 2488 0012 06D0     		beq	.L145
2117:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2118:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
2119:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		switch. */
2120:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		xYieldPending = pdTRUE;
 2489              		.loc 1 2120 0
 2490 0014 40F20003 		movw	r3, #:lower16:xYieldPending
 2491 0018 C0F20003 		movt	r3, #:upper16:xYieldPending
 2492 001c 0122     		movs	r2, #1
 2493 001e 1A60     		str	r2, [r3]
 2494 0020 83E0     		b	.L144
 2495              	.L145:
2121:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2122:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	else
2123:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2124:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		xYieldPending = pdFALSE;
 2496              		.loc 1 2124 0
 2497 0022 40F20003 		movw	r3, #:lower16:xYieldPending
 2498 0026 C0F20003 		movt	r3, #:upper16:xYieldPending
 2499 002a 0022     		movs	r2, #0
 2500 002c 1A60     		str	r2, [r3]
2125:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
2126:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2127:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
2128:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2129:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2130:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
2131:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				#else
2132:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2133:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				#endif
2134:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2135:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* Add the amount of time the task has been running to the
2136:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				accumulated	time so far.  The time the task started running was
2137:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				stored in ulTaskSwitchedInTime.  Note that there is no overflow
2138:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				protection here	so count values are only valid until the timer
2139:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				overflows.  The guard against negative values is to protect
2140:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				against suspect run time stat counter implementations - which
2141:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				are provided by the application, not the kernel. */
2142:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				if( ulTotalRunTime > ulTaskSwitchedInTime )
2143:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
2144:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
2145:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
2146:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				else
2147:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
2148:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2149:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
2150:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				ulTaskSwitchedInTime = ulTotalRunTime;
2151:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2152:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#endif /* configGENERATE_RUN_TIME_STATS */
2153:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2154:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Check for stack overflow, if configured. */
2155:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
 2501              		.loc 1 2155 0
 2502 002e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2503 0032 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2504 0036 1B68     		ldr	r3, [r3]
 2505 0038 1A68     		ldr	r2, [r3]
 2506 003a 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2507 003e C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2508 0042 1B68     		ldr	r3, [r3]
 2509 0044 1B6B     		ldr	r3, [r3, #48]
 2510 0046 9A42     		cmp	r2, r3
 2511 0048 0ED8     		bhi	.L147
 2512              		.loc 1 2155 0 is_stmt 0 discriminator 1
 2513 004a 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2514 004e C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2515 0052 1A68     		ldr	r2, [r3]
 2516 0054 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2517 0058 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2518 005c 1B68     		ldr	r3, [r3]
 2519 005e 3433     		adds	r3, r3, #52
 2520 0060 1046     		mov	r0, r2
 2521 0062 1946     		mov	r1, r3
 2522 0064 FFF7FEFF 		bl	vApplicationStackOverflowHook
 2523              	.L147:
 2524              	.LBB11:
2156:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
 2525              		.loc 1 2156 0 is_stmt 1
 2526 0068 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2527 006c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2528 0070 1B68     		ldr	r3, [r3]
 2529 0072 1B6B     		ldr	r3, [r3, #48]
 2530 0074 1846     		mov	r0, r3
 2531 0076 40F20001 		movw	r1, #:lower16:ucExpectedStackBytes.5311
 2532 007a C0F20001 		movt	r1, #:upper16:ucExpectedStackBytes.5311
 2533 007e 1422     		movs	r2, #20
 2534 0080 FFF7FEFF 		bl	memcmp
 2535 0084 0346     		mov	r3, r0
 2536 0086 002B     		cmp	r3, #0
 2537 0088 0ED0     		beq	.L148
 2538              		.loc 1 2156 0 is_stmt 0 discriminator 1
 2539 008a 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2540 008e C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2541 0092 1A68     		ldr	r2, [r3]
 2542 0094 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2543 0098 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2544 009c 1B68     		ldr	r3, [r3]
 2545 009e 3433     		adds	r3, r3, #52
 2546 00a0 1046     		mov	r0, r2
 2547 00a2 1946     		mov	r1, r3
 2548 00a4 FFF7FEFF 		bl	vApplicationStackOverflowHook
 2549              	.L148:
 2550              	.LBE11:
 2551              	.LBB12:
2157:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2158:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Select a new task to run using either the generic C or port
2159:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		optimised asm code. */
2160:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 2552              		.loc 1 2160 0 is_stmt 1
 2553 00a8 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2554 00ac C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2555 00b0 1B68     		ldr	r3, [r3]
 2556 00b2 7B60     		str	r3, [r7, #4]
 2557              	.LBB13:
 2558              	.LBB14:
 2559              		.file 2 "lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h"
   1:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** /*
   2:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****     FreeRTOS V8.1.2 - Copyright (C) 2014 Real Time Engineers Ltd.
   3:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****     All rights reserved
   4:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 
   5:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 
   7:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****     ***************************************************************************
   8:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****      *                                                                       *
   9:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****      *    FreeRTOS provides completely free yet professionally developed,    *
  10:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****      *    robust, strictly quality controlled, supported, and cross          *
  11:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****      *    platform software that has become a de facto standard.             *
  12:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****      *                                                                       *
  13:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****      *    Help yourself get started quickly and support the FreeRTOS         *
  14:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  15:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  16:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****      *                                                                       *
  17:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****      *    Thank you!                                                         *
  18:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****      *                                                                       *
  19:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****     ***************************************************************************
  20:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 
  21:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****     This file is part of the FreeRTOS distribution.
  22:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 
  23:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  24:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****     the terms of the GNU General Public License (version 2) as published by the
  25:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  26:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 
  27:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****     >>!   NOTE: The modification to the GPL is included to allow you to     !<<
  28:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****     >>!   distribute a combined work that includes FreeRTOS without being   !<<
  29:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****     >>!   obliged to provide the source code for proprietary components     !<<
  30:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****     >>!   outside of the FreeRTOS kernel.                                   !<<
  31:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 
  32:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  33:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  34:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  35:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****     link: http://www.freertos.org/a00114.html
  36:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 
  37:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****     1 tab == 4 spaces!
  38:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 
  39:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****     ***************************************************************************
  40:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****      *                                                                       *
  41:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  42:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****      *    not run, what could be wrong?"                                     *
  43:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****      *                                                                       *
  44:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  45:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****      *                                                                       *
  46:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****     ***************************************************************************
  47:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 
  48:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  49:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****     license and Real Time Engineers Ltd. contact details.
  50:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 
  51:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  52:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  53:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  54:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 
  55:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  56:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  57:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****     licenses offer ticketed support, indemnification and middleware.
  58:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 
  59:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  60:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****     engineered and independently SIL3 certified version for use in safety and
  61:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****     mission critical applications that require provable dependability.
  62:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 
  63:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****     1 tab == 4 spaces!
  64:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** */
  65:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 
  66:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 
  67:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #ifndef PORTMACRO_H
  68:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #define PORTMACRO_H
  69:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 
  70:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #ifdef __cplusplus
  71:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** extern "C" {
  72:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #endif
  73:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 
  74:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** /*-----------------------------------------------------------
  75:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****  * Port specific definitions.
  76:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****  *
  77:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****  * The settings in this file configure FreeRTOS correctly for the
  78:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****  * given hardware and compiler.
  79:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****  *
  80:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****  * These settings should not be altered.
  81:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****  *-----------------------------------------------------------
  82:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h ****  */
  83:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 
  84:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** /* Type definitions. */
  85:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #define portCHAR		char
  86:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #define portFLOAT		float
  87:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #define portDOUBLE		double
  88:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #define portLONG		long
  89:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #define portSHORT		short
  90:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #define portSTACK_TYPE	uint32_t
  91:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #define portBASE_TYPE	long
  92:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 
  93:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** typedef portSTACK_TYPE StackType_t;
  94:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** typedef long BaseType_t;
  95:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** typedef unsigned long UBaseType_t;
  96:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 
  97:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #if( configUSE_16_BIT_TICKS == 1 )
  98:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 	typedef uint16_t TickType_t;
  99:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffff
 100:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #else
 101:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 	typedef uint32_t TickType_t;
 102:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
 103:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #endif
 104:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** /*-----------------------------------------------------------*/
 105:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 
 106:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** /* Architecture specifics. */
 107:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #define portSTACK_GROWTH			( -1 )
 108:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
 109:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #define portBYTE_ALIGNMENT			8
 110:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** /*-----------------------------------------------------------*/
 111:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 
 112:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 
 113:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** /* Scheduler utilities. */
 114:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** extern void vPortYield( void );
 115:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
 116:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
 117:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #define portYIELD()					vPortYield()
 118:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired ) portNVIC_INT_CTRL_REG = port
 119:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
 120:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** /*-----------------------------------------------------------*/
 121:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 
 122:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** /* Critical section management. */
 123:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** extern void vPortEnterCritical( void );
 124:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** extern void vPortExitCritical( void );
 125:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** extern uint32_t ulPortSetInterruptMask( void );
 126:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** extern void vPortClearInterruptMask( uint32_t ulNewMaskValue );
 127:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortSetInterruptMask()
 128:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortClearInterruptMask(x)
 129:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #define portDISABLE_INTERRUPTS()				ulPortSetInterruptMask()
 130:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #define portENABLE_INTERRUPTS()					vPortClearInterruptMask(0)
 131:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #define portENTER_CRITICAL()					vPortEnterCritical()
 132:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #define portEXIT_CRITICAL()						vPortExitCritical()
 133:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 
 134:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** /*-----------------------------------------------------------*/
 135:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 
 136:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** /* Task function macros as described on the FreeRTOS.org WEB site.  These are
 137:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** not necessary for to use this port.  They are defined so the common demo files
 138:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** (which build with all the ports) will build. */
 139:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
 140:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
 141:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** /*-----------------------------------------------------------*/
 142:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 
 143:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** /* Tickless idle/low power functionality. */
 144:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #ifndef portSUPPRESS_TICKS_AND_SLEEP
 145:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
 146:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdl
 147:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #endif
 148:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** /*-----------------------------------------------------------*/
 149:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 
 150:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** /* Architecture specific optimisations. */
 151:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
 152:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
 153:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #endif
 154:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 
 155:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
 156:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 
 157:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 	/* Generic helper function. */
 158:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitma
 159:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 	{
 160:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 	uint8_t ucReturn;
 161:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 
 162:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
 2560              		.loc 2 162 0
 2561 00b4 7B68     		ldr	r3, [r7, #4]
 2562              	@ 162 "lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h" 1
 2563 00b6 B3FA83F3 		clz r3, r3
 2564              	@ 0 "" 2
 2565              		.thumb
 2566 00ba FB70     		strb	r3, [r7, #3]
 163:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h **** 		return ucReturn;
 2567              		.loc 2 163 0
 2568 00bc FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2569              	.LBE14:
 2570              	.LBE13:
 2571              		.loc 1 2160 0
 2572 00be C3F11F03 		rsb	r3, r3, #31
 2573 00c2 FB60     		str	r3, [r7, #12]
 2574 00c4 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 2575 00c8 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 2576 00cc F968     		ldr	r1, [r7, #12]
 2577 00ce 0B46     		mov	r3, r1
 2578 00d0 9B00     		lsls	r3, r3, #2
 2579 00d2 0B44     		add	r3, r3, r1
 2580 00d4 9B00     		lsls	r3, r3, #2
 2581 00d6 1344     		add	r3, r3, r2
 2582 00d8 1B68     		ldr	r3, [r3]
 2583 00da 002B     		cmp	r3, #0
 2584 00dc 02D1     		bne	.L150
 2585              		.loc 1 2160 0 is_stmt 0 discriminator 1
 2586 00de FFF7FEFF 		bl	ulPortSetInterruptMask
 2587              	.L151:
 2588 00e2 FEE7     		b	.L151
 2589              	.L150:
 2590              	.LBB15:
 2591              		.loc 1 2160 0 discriminator 2
 2592 00e4 FA68     		ldr	r2, [r7, #12]
 2593 00e6 1346     		mov	r3, r2
 2594 00e8 9B00     		lsls	r3, r3, #2
 2595 00ea 1344     		add	r3, r3, r2
 2596 00ec 9B00     		lsls	r3, r3, #2
 2597 00ee 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 2598 00f2 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 2599 00f6 1344     		add	r3, r3, r2
 2600 00f8 BB60     		str	r3, [r7, #8]
 2601 00fa BB68     		ldr	r3, [r7, #8]
 2602 00fc 5B68     		ldr	r3, [r3, #4]
 2603 00fe 5A68     		ldr	r2, [r3, #4]
 2604 0100 BB68     		ldr	r3, [r7, #8]
 2605 0102 5A60     		str	r2, [r3, #4]
 2606 0104 BB68     		ldr	r3, [r7, #8]
 2607 0106 5A68     		ldr	r2, [r3, #4]
 2608 0108 BB68     		ldr	r3, [r7, #8]
 2609 010a 0833     		adds	r3, r3, #8
 2610 010c 9A42     		cmp	r2, r3
 2611 010e 04D1     		bne	.L152
 2612              		.loc 1 2160 0 discriminator 1
 2613 0110 BB68     		ldr	r3, [r7, #8]
 2614 0112 5B68     		ldr	r3, [r3, #4]
 2615 0114 5A68     		ldr	r2, [r3, #4]
 2616 0116 BB68     		ldr	r3, [r7, #8]
 2617 0118 5A60     		str	r2, [r3, #4]
 2618              	.L152:
 2619              		.loc 1 2160 0 discriminator 2
 2620 011a BB68     		ldr	r3, [r7, #8]
 2621 011c 5B68     		ldr	r3, [r3, #4]
 2622 011e DA68     		ldr	r2, [r3, #12]
 2623 0120 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2624 0124 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2625 0128 1A60     		str	r2, [r3]
 2626              	.L144:
 2627              	.LBE15:
 2628              	.LBE12:
2161:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
2162:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2163:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2164:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2165:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
2166:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			structure specific to this task. */
2167:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2168:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2169:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
2170:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2171:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** }
 2629              		.loc 1 2171 0 is_stmt 1
 2630 012a 1037     		adds	r7, r7, #16
 2631 012c BD46     		mov	sp, r7
 2632              		@ sp needed
 2633 012e 80BD     		pop	{r7, pc}
 2634              		.cfi_endproc
 2635              	.LFE20:
 2637              		.section	.text.vTaskPlaceOnEventList,"ax",%progbits
 2638              		.align	2
 2639              		.global	vTaskPlaceOnEventList
 2640              		.thumb
 2641              		.thumb_func
 2643              	vTaskPlaceOnEventList:
 2644              	.LFB21:
2172:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2173:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2174:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
2175:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** {
 2645              		.loc 1 2175 0
 2646              		.cfi_startproc
 2647              		@ args = 0, pretend = 0, frame = 16
 2648              		@ frame_needed = 1, uses_anonymous_args = 0
 2649 0000 80B5     		push	{r7, lr}
 2650              	.LCFI57:
 2651              		.cfi_def_cfa_offset 8
 2652              		.cfi_offset 7, -8
 2653              		.cfi_offset 14, -4
 2654 0002 84B0     		sub	sp, sp, #16
 2655              	.LCFI58:
 2656              		.cfi_def_cfa_offset 24
 2657 0004 00AF     		add	r7, sp, #0
 2658              	.LCFI59:
 2659              		.cfi_def_cfa_register 7
 2660 0006 7860     		str	r0, [r7, #4]
 2661 0008 3960     		str	r1, [r7]
2176:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** TickType_t xTimeToWake;
2177:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2178:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
 2662              		.loc 1 2178 0
 2663 000a 7B68     		ldr	r3, [r7, #4]
 2664 000c 002B     		cmp	r3, #0
 2665 000e 02D1     		bne	.L154
 2666              		.loc 1 2178 0 is_stmt 0 discriminator 1
 2667 0010 FFF7FEFF 		bl	ulPortSetInterruptMask
 2668              	.L155:
 2669 0014 FEE7     		b	.L155
 2670              	.L154:
2179:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2180:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
2181:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
2182:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2183:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
2184:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
2185:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	is the first to be woken by the event.  The queue that contains the event
2186:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	list is locked, preventing simultaneous access from interrupts. */
2187:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 2671              		.loc 1 2187 0 is_stmt 1
 2672 0016 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2673 001a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2674 001e 1B68     		ldr	r3, [r3]
 2675 0020 1833     		adds	r3, r3, #24
 2676 0022 7868     		ldr	r0, [r7, #4]
 2677 0024 1946     		mov	r1, r3
 2678 0026 FFF7FEFF 		bl	vListInsert
2188:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2189:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* The task must be removed from from the ready list before it is added to
2190:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	the blocked list as the same list item is used for both lists.  Exclusive
2191:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	access to the ready lists guaranteed because the scheduler is locked. */
2192:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 2679              		.loc 1 2192 0
 2680 002a 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2681 002e C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2682 0032 1B68     		ldr	r3, [r3]
 2683 0034 0433     		adds	r3, r3, #4
 2684 0036 1846     		mov	r0, r3
 2685 0038 FFF7FEFF 		bl	uxListRemove
 2686 003c 0346     		mov	r3, r0
 2687 003e 002B     		cmp	r3, #0
 2688 0040 14D1     		bne	.L156
2193:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2194:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
2195:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		check, and the port reset macro can be called directly. */
2196:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 2689              		.loc 1 2196 0
 2690 0042 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2691 0046 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2692 004a 1B68     		ldr	r3, [r3]
 2693 004c DB6A     		ldr	r3, [r3, #44]
 2694 004e 0122     		movs	r2, #1
 2695 0050 02FA03F3 		lsl	r3, r2, r3
 2696 0054 DA43     		mvns	r2, r3
 2697 0056 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2698 005a C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2699 005e 1B68     		ldr	r3, [r3]
 2700 0060 1A40     		ands	r2, r2, r3
 2701 0062 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2702 0066 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2703 006a 1A60     		str	r2, [r3]
 2704              	.L156:
2197:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2198:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	else
2199:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2200:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
2201:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2202:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2203:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2204:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2205:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
 2705              		.loc 1 2205 0
 2706 006c 3B68     		ldr	r3, [r7]
 2707 006e B3F1FF3F 		cmp	r3, #-1
 2708 0072 0DD1     		bne	.L157
2206:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2207:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Add the task to the suspended task list instead of a delayed task
2208:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			list to ensure the task is not woken by a timing event.  It will
2209:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			block indefinitely. */
2210:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 2709              		.loc 1 2210 0
 2710 0074 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2711 0078 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2712 007c 1B68     		ldr	r3, [r3]
 2713 007e 0433     		adds	r3, r3, #4
 2714 0080 40F20000 		movw	r0, #:lower16:xSuspendedTaskList
 2715 0084 C0F20000 		movt	r0, #:upper16:xSuspendedTaskList
 2716 0088 1946     		mov	r1, r3
 2717 008a FFF7FEFF 		bl	vListInsertEnd
 2718 008e 0AE0     		b	.L153
 2719              	.L157:
2211:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2212:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
2213:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2214:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event
2215:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			does not occur.  This may overflow but this doesn't matter, the
2216:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			scheduler will handle it. */
2217:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
 2720              		.loc 1 2217 0
 2721 0090 40F20003 		movw	r3, #:lower16:xTickCount
 2722 0094 C0F20003 		movt	r3, #:upper16:xTickCount
 2723 0098 1A68     		ldr	r2, [r3]
 2724 009a 3B68     		ldr	r3, [r7]
 2725 009c 1344     		add	r3, r3, r2
 2726 009e FB60     		str	r3, [r7, #12]
2218:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 2727              		.loc 1 2218 0
 2728 00a0 F868     		ldr	r0, [r7, #12]
 2729 00a2 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 2730              	.L153:
2219:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2220:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2221:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#else /* INCLUDE_vTaskSuspend */
2222:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2223:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
2224:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter, the scheduler
2225:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			will handle it. */
2226:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
2227:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
2228:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2229:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
2230:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** }
 2731              		.loc 1 2230 0
 2732 00a6 1037     		adds	r7, r7, #16
 2733 00a8 BD46     		mov	sp, r7
 2734              		@ sp needed
 2735 00aa 80BD     		pop	{r7, pc}
 2736              		.cfi_endproc
 2737              	.LFE21:
 2739              		.section	.text.vTaskPlaceOnUnorderedEventList,"ax",%progbits
 2740              		.align	2
 2741              		.global	vTaskPlaceOnUnorderedEventList
 2742              		.thumb
 2743              		.thumb_func
 2745              	vTaskPlaceOnUnorderedEventList:
 2746              	.LFB22:
2231:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2232:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2233:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickT
2234:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** {
 2747              		.loc 1 2234 0
 2748              		.cfi_startproc
 2749              		@ args = 0, pretend = 0, frame = 24
 2750              		@ frame_needed = 1, uses_anonymous_args = 0
 2751 0000 80B5     		push	{r7, lr}
 2752              	.LCFI60:
 2753              		.cfi_def_cfa_offset 8
 2754              		.cfi_offset 7, -8
 2755              		.cfi_offset 14, -4
 2756 0002 86B0     		sub	sp, sp, #24
 2757              	.LCFI61:
 2758              		.cfi_def_cfa_offset 32
 2759 0004 00AF     		add	r7, sp, #0
 2760              	.LCFI62:
 2761              		.cfi_def_cfa_register 7
 2762 0006 F860     		str	r0, [r7, #12]
 2763 0008 B960     		str	r1, [r7, #8]
 2764 000a 7A60     		str	r2, [r7, #4]
2235:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** TickType_t xTimeToWake;
2236:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2237:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
 2765              		.loc 1 2237 0
 2766 000c FB68     		ldr	r3, [r7, #12]
 2767 000e 002B     		cmp	r3, #0
 2768 0010 02D1     		bne	.L160
 2769              		.loc 1 2237 0 is_stmt 0 discriminator 1
 2770 0012 FFF7FEFF 		bl	ulPortSetInterruptMask
 2771              	.L161:
 2772 0016 FEE7     		b	.L161
 2773              	.L160:
2238:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2239:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2240:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	the event groups implementation. */
2241:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended != 0 );
 2774              		.loc 1 2241 0 is_stmt 1
 2775 0018 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 2776 001c C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 2777 0020 1B68     		ldr	r3, [r3]
 2778 0022 002B     		cmp	r3, #0
 2779 0024 02D1     		bne	.L162
 2780              		.loc 1 2241 0 is_stmt 0 discriminator 1
 2781 0026 FFF7FEFF 		bl	ulPortSetInterruptMask
 2782              	.L163:
 2783 002a FEE7     		b	.L163
 2784              	.L162:
2242:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2243:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* Store the item value in the event list item.  It is safe to access the
2244:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	event list item here as interrupts won't access the event list item of a
2245:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	task that is not in the Blocked state. */
2246:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE
 2785              		.loc 1 2246 0 is_stmt 1
 2786 002c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2787 0030 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2788 0034 1B68     		ldr	r3, [r3]
 2789 0036 BA68     		ldr	r2, [r7, #8]
 2790 0038 42F00042 		orr	r2, r2, #-2147483648
 2791 003c 9A61     		str	r2, [r3, #24]
2247:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2248:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* Place the event list item of the TCB at the end of the appropriate event
2249:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	list.  It is safe to access the event list here because it is part of an
2250:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	event group implementation - and interrupts don't access event groups
2251:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	directly (instead they access them indirectly by pending function calls to
2252:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	the task level). */
2253:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 2792              		.loc 1 2253 0
 2793 003e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2794 0042 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2795 0046 1B68     		ldr	r3, [r3]
 2796 0048 1833     		adds	r3, r3, #24
 2797 004a F868     		ldr	r0, [r7, #12]
 2798 004c 1946     		mov	r1, r3
 2799 004e FFF7FEFF 		bl	vListInsertEnd
2254:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2255:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* The task must be removed from the ready list before it is added to the
2256:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	blocked list.  Exclusive access can be assured to the ready list as the
2257:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	scheduler is locked. */
2258:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 2800              		.loc 1 2258 0
 2801 0052 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2802 0056 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2803 005a 1B68     		ldr	r3, [r3]
 2804 005c 0433     		adds	r3, r3, #4
 2805 005e 1846     		mov	r0, r3
 2806 0060 FFF7FEFF 		bl	uxListRemove
 2807 0064 0346     		mov	r3, r0
 2808 0066 002B     		cmp	r3, #0
 2809 0068 14D1     		bne	.L164
2259:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2260:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
2261:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		check, and the port reset macro can be called directly. */
2262:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 2810              		.loc 1 2262 0
 2811 006a 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2812 006e C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2813 0072 1B68     		ldr	r3, [r3]
 2814 0074 DB6A     		ldr	r3, [r3, #44]
 2815 0076 0122     		movs	r2, #1
 2816 0078 02FA03F3 		lsl	r3, r2, r3
 2817 007c DA43     		mvns	r2, r3
 2818 007e 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2819 0082 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2820 0086 1B68     		ldr	r3, [r3]
 2821 0088 1A40     		ands	r2, r2, r3
 2822 008a 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2823 008e C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2824 0092 1A60     		str	r2, [r3]
 2825              	.L164:
2263:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2264:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	else
2265:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2266:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
2267:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2268:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2269:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2270:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2271:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
 2826              		.loc 1 2271 0
 2827 0094 7B68     		ldr	r3, [r7, #4]
 2828 0096 B3F1FF3F 		cmp	r3, #-1
 2829 009a 0DD1     		bne	.L165
2272:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2273:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Add the task to the suspended task list instead of a delayed task
2274:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			list to ensure it is not woken by a timing event.  It will block
2275:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			indefinitely. */
2276:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 2830              		.loc 1 2276 0
 2831 009c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2832 00a0 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2833 00a4 1B68     		ldr	r3, [r3]
 2834 00a6 0433     		adds	r3, r3, #4
 2835 00a8 40F20000 		movw	r0, #:lower16:xSuspendedTaskList
 2836 00ac C0F20000 		movt	r0, #:upper16:xSuspendedTaskList
 2837 00b0 1946     		mov	r1, r3
 2838 00b2 FFF7FEFF 		bl	vListInsertEnd
 2839 00b6 0AE0     		b	.L159
 2840              	.L165:
2277:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2278:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
2279:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2280:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event
2281:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			does not occur.  This may overflow but this doesn't matter, the
2282:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			kernel will manage it correctly. */
2283:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
 2841              		.loc 1 2283 0
 2842 00b8 40F20003 		movw	r3, #:lower16:xTickCount
 2843 00bc C0F20003 		movt	r3, #:upper16:xTickCount
 2844 00c0 1A68     		ldr	r2, [r3]
 2845 00c2 7B68     		ldr	r3, [r7, #4]
 2846 00c4 1344     		add	r3, r3, r2
 2847 00c6 7B61     		str	r3, [r7, #20]
2284:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 2848              		.loc 1 2284 0
 2849 00c8 7869     		ldr	r0, [r7, #20]
 2850 00ca FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 2851              	.L159:
2285:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2286:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2287:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#else /* INCLUDE_vTaskSuspend */
2288:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2289:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
2290:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter, the kernel
2291:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			will manage it correctly. */
2292:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
2293:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
2294:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2295:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
2296:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** }
 2852              		.loc 1 2296 0
 2853 00ce 1837     		adds	r7, r7, #24
 2854 00d0 BD46     		mov	sp, r7
 2855              		@ sp needed
 2856 00d2 80BD     		pop	{r7, pc}
 2857              		.cfi_endproc
 2858              	.LFE22:
 2860              		.section	.text.vTaskPlaceOnEventListRestricted,"ax",%progbits
 2861              		.align	2
 2862              		.global	vTaskPlaceOnEventListRestricted
 2863              		.thumb
 2864              		.thumb_func
 2866              	vTaskPlaceOnEventListRestricted:
 2867              	.LFB23:
2297:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2298:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2299:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if configUSE_TIMERS == 1
2300:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2301:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait )
2302:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
 2868              		.loc 1 2302 0
 2869              		.cfi_startproc
 2870              		@ args = 0, pretend = 0, frame = 16
 2871              		@ frame_needed = 1, uses_anonymous_args = 0
 2872 0000 80B5     		push	{r7, lr}
 2873              	.LCFI63:
 2874              		.cfi_def_cfa_offset 8
 2875              		.cfi_offset 7, -8
 2876              		.cfi_offset 14, -4
 2877 0002 84B0     		sub	sp, sp, #16
 2878              	.LCFI64:
 2879              		.cfi_def_cfa_offset 24
 2880 0004 00AF     		add	r7, sp, #0
 2881              	.LCFI65:
 2882              		.cfi_def_cfa_register 7
 2883 0006 7860     		str	r0, [r7, #4]
 2884 0008 3960     		str	r1, [r7]
2303:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
2304:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2305:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		configASSERT( pxEventList );
 2885              		.loc 1 2305 0
 2886 000a 7B68     		ldr	r3, [r7, #4]
 2887 000c 002B     		cmp	r3, #0
 2888 000e 02D1     		bne	.L168
 2889              		.loc 1 2305 0 is_stmt 0 discriminator 1
 2890 0010 FFF7FEFF 		bl	ulPortSetInterruptMask
 2891              	.L169:
 2892 0014 FEE7     		b	.L169
 2893              	.L168:
2306:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2307:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* This function should not be called by application code hence the
2308:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
2309:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
2310:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		it should be called from a critical section. */
2311:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2312:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2313:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
2314:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		In this case it is assume that this is the only task that is going to
2315:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
2316:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		can be used in place of vListInsert. */
2317:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 2894              		.loc 1 2317 0 is_stmt 1
 2895 0016 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2896 001a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2897 001e 1B68     		ldr	r3, [r3]
 2898 0020 1833     		adds	r3, r3, #24
 2899 0022 7868     		ldr	r0, [r7, #4]
 2900 0024 1946     		mov	r1, r3
 2901 0026 FFF7FEFF 		bl	vListInsertEnd
2318:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2319:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* We must remove this task from the ready list before adding it to the
2320:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		blocked list as the same list item is used for both lists.  This
2321:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		function is called form a critical section. */
2322:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 2902              		.loc 1 2322 0
 2903 002a 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2904 002e C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2905 0032 1B68     		ldr	r3, [r3]
 2906 0034 0433     		adds	r3, r3, #4
 2907 0036 1846     		mov	r0, r3
 2908 0038 FFF7FEFF 		bl	uxListRemove
 2909 003c 0346     		mov	r3, r0
 2910 003e 002B     		cmp	r3, #0
 2911 0040 14D1     		bne	.L170
2323:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2324:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* The current task must be in a ready list, so there is no need to
2325:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			check, and the port reset macro can be called directly. */
2326:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 2912              		.loc 1 2326 0
 2913 0042 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2914 0046 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2915 004a 1B68     		ldr	r3, [r3]
 2916 004c DB6A     		ldr	r3, [r3, #44]
 2917 004e 0122     		movs	r2, #1
 2918 0050 02FA03F3 		lsl	r3, r2, r3
 2919 0054 DA43     		mvns	r2, r3
 2920 0056 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2921 005a C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2922 005e 1B68     		ldr	r3, [r3]
 2923 0060 1A40     		ands	r2, r2, r3
 2924 0062 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2925 0066 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2926 006a 1A60     		str	r2, [r3]
 2927              	.L170:
2327:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2328:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
2329:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2330:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2331:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2332:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2333:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Calculate the time at which the task should be woken if the event does
2334:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		not occur.  This may overflow but this doesn't matter. */
2335:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		xTimeToWake = xTickCount + xTicksToWait;
 2928              		.loc 1 2335 0
 2929 006c 40F20003 		movw	r3, #:lower16:xTickCount
 2930 0070 C0F20003 		movt	r3, #:upper16:xTickCount
 2931 0074 1A68     		ldr	r2, [r3]
 2932 0076 3B68     		ldr	r3, [r7]
 2933 0078 1344     		add	r3, r3, r2
 2934 007a FB60     		str	r3, [r7, #12]
2336:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2337:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		traceTASK_DELAY_UNTIL();
2338:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTimeToWake );
 2935              		.loc 1 2338 0
 2936 007c F868     		ldr	r0, [r7, #12]
 2937 007e FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
2339:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
 2938              		.loc 1 2339 0
 2939 0082 1037     		adds	r7, r7, #16
 2940 0084 BD46     		mov	sp, r7
 2941              		@ sp needed
 2942 0086 80BD     		pop	{r7, pc}
 2943              		.cfi_endproc
 2944              	.LFE23:
 2946              		.section	.text.xTaskRemoveFromEventList,"ax",%progbits
 2947              		.align	2
 2948              		.global	xTaskRemoveFromEventList
 2949              		.thumb
 2950              		.thumb_func
 2952              	xTaskRemoveFromEventList:
 2953              	.LFB24:
2340:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2341:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TIMERS */
2342:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2343:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2344:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
2345:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** {
 2954              		.loc 1 2345 0
 2955              		.cfi_startproc
 2956              		@ args = 0, pretend = 0, frame = 16
 2957              		@ frame_needed = 1, uses_anonymous_args = 0
 2958 0000 80B5     		push	{r7, lr}
 2959              	.LCFI66:
 2960              		.cfi_def_cfa_offset 8
 2961              		.cfi_offset 7, -8
 2962              		.cfi_offset 14, -4
 2963 0002 84B0     		sub	sp, sp, #16
 2964              	.LCFI67:
 2965              		.cfi_def_cfa_offset 24
 2966 0004 00AF     		add	r7, sp, #0
 2967              	.LCFI68:
 2968              		.cfi_def_cfa_register 7
 2969 0006 7860     		str	r0, [r7, #4]
2346:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
2347:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
2348:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2349:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
2350:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	called from a critical section within an ISR. */
2351:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2352:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* The event list is sorted in priority order, so the first in the list can
2353:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	be removed as it is known to be the highest priority.  Remove the TCB from
2354:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	the delayed list, and add it to the ready list.
2355:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2356:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
2357:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
2358:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	means exclusive access to the event list is guaranteed here.
2359:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2360:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	This function assumes that a check has already been made to ensure that
2361:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	pxEventList is not empty. */
2362:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 2970              		.loc 1 2362 0
 2971 0008 7B68     		ldr	r3, [r7, #4]
 2972 000a DB68     		ldr	r3, [r3, #12]
 2973 000c DB68     		ldr	r3, [r3, #12]
 2974 000e BB60     		str	r3, [r7, #8]
2363:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
 2975              		.loc 1 2363 0
 2976 0010 BB68     		ldr	r3, [r7, #8]
 2977 0012 002B     		cmp	r3, #0
 2978 0014 02D1     		bne	.L172
 2979              		.loc 1 2363 0 is_stmt 0 discriminator 1
 2980 0016 FFF7FEFF 		bl	ulPortSetInterruptMask
 2981              	.L173:
 2982 001a FEE7     		b	.L173
 2983              	.L172:
2364:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 2984              		.loc 1 2364 0 is_stmt 1
 2985 001c BB68     		ldr	r3, [r7, #8]
 2986 001e 1833     		adds	r3, r3, #24
 2987 0020 1846     		mov	r0, r3
 2988 0022 FFF7FEFF 		bl	uxListRemove
2365:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2366:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2989              		.loc 1 2366 0
 2990 0026 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 2991 002a C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 2992 002e 1B68     		ldr	r3, [r3]
 2993 0030 002B     		cmp	r3, #0
 2994 0032 25D1     		bne	.L174
2367:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2368:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 2995              		.loc 1 2368 0
 2996 0034 BB68     		ldr	r3, [r7, #8]
 2997 0036 0433     		adds	r3, r3, #4
 2998 0038 1846     		mov	r0, r3
 2999 003a FFF7FEFF 		bl	uxListRemove
2369:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
 3000              		.loc 1 2369 0
 3001 003e BB68     		ldr	r3, [r7, #8]
 3002 0040 DB6A     		ldr	r3, [r3, #44]
 3003 0042 0122     		movs	r2, #1
 3004 0044 9A40     		lsls	r2, r2, r3
 3005 0046 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 3006 004a C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 3007 004e 1B68     		ldr	r3, [r3]
 3008 0050 1A43     		orrs	r2, r2, r3
 3009 0052 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 3010 0056 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 3011 005a 1A60     		str	r2, [r3]
 3012 005c BB68     		ldr	r3, [r7, #8]
 3013 005e DA6A     		ldr	r2, [r3, #44]
 3014 0060 1346     		mov	r3, r2
 3015 0062 9B00     		lsls	r3, r3, #2
 3016 0064 1344     		add	r3, r3, r2
 3017 0066 9B00     		lsls	r3, r3, #2
 3018 0068 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 3019 006c C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 3020 0070 1A44     		add	r2, r2, r3
 3021 0072 BB68     		ldr	r3, [r7, #8]
 3022 0074 0433     		adds	r3, r3, #4
 3023 0076 1046     		mov	r0, r2
 3024 0078 1946     		mov	r1, r3
 3025 007a FFF7FEFF 		bl	vListInsertEnd
 3026 007e 08E0     		b	.L175
 3027              	.L174:
2370:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2371:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	else
2372:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2373:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* The delayed and ready lists cannot be accessed, so hold this task
2374:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		pending until the scheduler is resumed. */
2375:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 3028              		.loc 1 2375 0
 3029 0080 BB68     		ldr	r3, [r7, #8]
 3030 0082 1833     		adds	r3, r3, #24
 3031 0084 40F20000 		movw	r0, #:lower16:xPendingReadyList
 3032 0088 C0F20000 		movt	r0, #:upper16:xPendingReadyList
 3033 008c 1946     		mov	r1, r3
 3034 008e FFF7FEFF 		bl	vListInsertEnd
 3035              	.L175:
2376:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2377:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2378:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 3036              		.loc 1 2378 0
 3037 0092 BB68     		ldr	r3, [r7, #8]
 3038 0094 DA6A     		ldr	r2, [r3, #44]
 3039 0096 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3040 009a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3041 009e 1B68     		ldr	r3, [r3]
 3042 00a0 DB6A     		ldr	r3, [r3, #44]
 3043 00a2 9A42     		cmp	r2, r3
 3044 00a4 08D9     		bls	.L176
2379:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2380:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Return true if the task removed from the event list has a higher
2381:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		priority than the calling task.  This allows the calling task to know if
2382:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		it should force a context switch now. */
2383:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		xReturn = pdTRUE;
 3045              		.loc 1 2383 0
 3046 00a6 0123     		movs	r3, #1
 3047 00a8 FB60     		str	r3, [r7, #12]
2384:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2385:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
2386:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2387:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		xYieldPending = pdTRUE;
 3048              		.loc 1 2387 0
 3049 00aa 40F20003 		movw	r3, #:lower16:xYieldPending
 3050 00ae C0F20003 		movt	r3, #:upper16:xYieldPending
 3051 00b2 0122     		movs	r2, #1
 3052 00b4 1A60     		str	r2, [r3]
 3053 00b6 01E0     		b	.L177
 3054              	.L176:
2388:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2389:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	else
2390:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2391:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		xReturn = pdFALSE;
 3055              		.loc 1 2391 0
 3056 00b8 0023     		movs	r3, #0
 3057 00ba FB60     		str	r3, [r7, #12]
 3058              	.L177:
2392:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2393:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2394:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	return xReturn;
 3059              		.loc 1 2394 0
 3060 00bc FB68     		ldr	r3, [r7, #12]
2395:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** }
 3061              		.loc 1 2395 0
 3062 00be 1846     		mov	r0, r3
 3063 00c0 1037     		adds	r7, r7, #16
 3064 00c2 BD46     		mov	sp, r7
 3065              		@ sp needed
 3066 00c4 80BD     		pop	{r7, pc}
 3067              		.cfi_endproc
 3068              	.LFE24:
 3070 00c6 00BF     		.section	.text.xTaskRemoveFromUnorderedEventList,"ax",%progbits
 3071              		.align	2
 3072              		.global	xTaskRemoveFromUnorderedEventList
 3073              		.thumb
 3074              		.thumb_func
 3076              	xTaskRemoveFromUnorderedEventList:
 3077              	.LFB25:
2396:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2397:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2398:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemV
2399:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** {
 3078              		.loc 1 2399 0
 3079              		.cfi_startproc
 3080              		@ args = 0, pretend = 0, frame = 16
 3081              		@ frame_needed = 1, uses_anonymous_args = 0
 3082 0000 80B5     		push	{r7, lr}
 3083              	.LCFI69:
 3084              		.cfi_def_cfa_offset 8
 3085              		.cfi_offset 7, -8
 3086              		.cfi_offset 14, -4
 3087 0002 84B0     		sub	sp, sp, #16
 3088              	.LCFI70:
 3089              		.cfi_def_cfa_offset 24
 3090 0004 00AF     		add	r7, sp, #0
 3091              	.LCFI71:
 3092              		.cfi_def_cfa_register 7
 3093 0006 7860     		str	r0, [r7, #4]
 3094 0008 3960     		str	r1, [r7]
2400:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
2401:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
2402:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2403:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2404:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	the event flags implementation. */
2405:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended != pdFALSE );
 3095              		.loc 1 2405 0
 3096 000a 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 3097 000e C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 3098 0012 1B68     		ldr	r3, [r3]
 3099 0014 002B     		cmp	r3, #0
 3100 0016 02D1     		bne	.L180
 3101              		.loc 1 2405 0 is_stmt 0 discriminator 1
 3102 0018 FFF7FEFF 		bl	ulPortSetInterruptMask
 3103              	.L181:
 3104 001c FEE7     		b	.L181
 3105              	.L180:
2406:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2407:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* Store the new item value in the event list. */
2408:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 3106              		.loc 1 2408 0 is_stmt 1
 3107 001e 3B68     		ldr	r3, [r7]
 3108 0020 43F00042 		orr	r2, r3, #-2147483648
 3109 0024 7B68     		ldr	r3, [r7, #4]
 3110 0026 1A60     		str	r2, [r3]
2409:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2410:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* Remove the event list form the event flag.  Interrupts do not access
2411:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	event flags. */
2412:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
 3111              		.loc 1 2412 0
 3112 0028 7B68     		ldr	r3, [r7, #4]
 3113 002a DB68     		ldr	r3, [r3, #12]
 3114 002c BB60     		str	r3, [r7, #8]
2413:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
 3115              		.loc 1 2413 0
 3116 002e BB68     		ldr	r3, [r7, #8]
 3117 0030 002B     		cmp	r3, #0
 3118 0032 02D1     		bne	.L182
 3119              		.loc 1 2413 0 is_stmt 0 discriminator 1
 3120 0034 FFF7FEFF 		bl	ulPortSetInterruptMask
 3121              	.L183:
 3122 0038 FEE7     		b	.L183
 3123              	.L182:
2414:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( pxEventListItem );
 3124              		.loc 1 2414 0 is_stmt 1
 3125 003a 7868     		ldr	r0, [r7, #4]
 3126 003c FFF7FEFF 		bl	uxListRemove
2415:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2416:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* Remove the task from the delayed list and add it to the ready list.  The
2417:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	scheduler is suspended so interrupts will not be accessing the ready
2418:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	lists. */
2419:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 3127              		.loc 1 2419 0
 3128 0040 BB68     		ldr	r3, [r7, #8]
 3129 0042 0433     		adds	r3, r3, #4
 3130 0044 1846     		mov	r0, r3
 3131 0046 FFF7FEFF 		bl	uxListRemove
2420:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
 3132              		.loc 1 2420 0
 3133 004a BB68     		ldr	r3, [r7, #8]
 3134 004c DB6A     		ldr	r3, [r3, #44]
 3135 004e 0122     		movs	r2, #1
 3136 0050 9A40     		lsls	r2, r2, r3
 3137 0052 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 3138 0056 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 3139 005a 1B68     		ldr	r3, [r3]
 3140 005c 1A43     		orrs	r2, r2, r3
 3141 005e 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 3142 0062 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 3143 0066 1A60     		str	r2, [r3]
 3144 0068 BB68     		ldr	r3, [r7, #8]
 3145 006a DA6A     		ldr	r2, [r3, #44]
 3146 006c 1346     		mov	r3, r2
 3147 006e 9B00     		lsls	r3, r3, #2
 3148 0070 1344     		add	r3, r3, r2
 3149 0072 9B00     		lsls	r3, r3, #2
 3150 0074 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 3151 0078 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 3152 007c 1A44     		add	r2, r2, r3
 3153 007e BB68     		ldr	r3, [r7, #8]
 3154 0080 0433     		adds	r3, r3, #4
 3155 0082 1046     		mov	r0, r2
 3156 0084 1946     		mov	r1, r3
 3157 0086 FFF7FEFF 		bl	vListInsertEnd
2421:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2422:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 3158              		.loc 1 2422 0
 3159 008a BB68     		ldr	r3, [r7, #8]
 3160 008c DA6A     		ldr	r2, [r3, #44]
 3161 008e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3162 0092 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3163 0096 1B68     		ldr	r3, [r3]
 3164 0098 DB6A     		ldr	r3, [r3, #44]
 3165 009a 9A42     		cmp	r2, r3
 3166 009c 08D9     		bls	.L184
2423:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2424:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Return true if the task removed from the event list has
2425:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		a higher priority than the calling task.  This allows
2426:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		the calling task to know if it should force a context
2427:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		switch now. */
2428:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		xReturn = pdTRUE;
 3167              		.loc 1 2428 0
 3168 009e 0123     		movs	r3, #1
 3169 00a0 FB60     		str	r3, [r7, #12]
2429:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2430:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
2431:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2432:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		xYieldPending = pdTRUE;
 3170              		.loc 1 2432 0
 3171 00a2 40F20003 		movw	r3, #:lower16:xYieldPending
 3172 00a6 C0F20003 		movt	r3, #:upper16:xYieldPending
 3173 00aa 0122     		movs	r2, #1
 3174 00ac 1A60     		str	r2, [r3]
 3175 00ae 01E0     		b	.L185
 3176              	.L184:
2433:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2434:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	else
2435:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2436:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		xReturn = pdFALSE;
 3177              		.loc 1 2436 0
 3178 00b0 0023     		movs	r3, #0
 3179 00b2 FB60     		str	r3, [r7, #12]
 3180              	.L185:
2437:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2438:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2439:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	return xReturn;
 3181              		.loc 1 2439 0
 3182 00b4 FB68     		ldr	r3, [r7, #12]
2440:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** }
 3183              		.loc 1 2440 0
 3184 00b6 1846     		mov	r0, r3
 3185 00b8 1037     		adds	r7, r7, #16
 3186 00ba BD46     		mov	sp, r7
 3187              		@ sp needed
 3188 00bc 80BD     		pop	{r7, pc}
 3189              		.cfi_endproc
 3190              	.LFE25:
 3192 00be 00BF     		.section	.text.vTaskSetTimeOutState,"ax",%progbits
 3193              		.align	2
 3194              		.global	vTaskSetTimeOutState
 3195              		.thumb
 3196              		.thumb_func
 3198              	vTaskSetTimeOutState:
 3199              	.LFB26:
2441:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2442:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2443:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
2444:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** {
 3200              		.loc 1 2444 0
 3201              		.cfi_startproc
 3202              		@ args = 0, pretend = 0, frame = 8
 3203              		@ frame_needed = 1, uses_anonymous_args = 0
 3204 0000 80B5     		push	{r7, lr}
 3205              	.LCFI72:
 3206              		.cfi_def_cfa_offset 8
 3207              		.cfi_offset 7, -8
 3208              		.cfi_offset 14, -4
 3209 0002 82B0     		sub	sp, sp, #8
 3210              	.LCFI73:
 3211              		.cfi_def_cfa_offset 16
 3212 0004 00AF     		add	r7, sp, #0
 3213              	.LCFI74:
 3214              		.cfi_def_cfa_register 7
 3215 0006 7860     		str	r0, [r7, #4]
2445:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
 3216              		.loc 1 2445 0
 3217 0008 7B68     		ldr	r3, [r7, #4]
 3218 000a 002B     		cmp	r3, #0
 3219 000c 02D1     		bne	.L188
 3220              		.loc 1 2445 0 is_stmt 0 discriminator 1
 3221 000e FFF7FEFF 		bl	ulPortSetInterruptMask
 3222              	.L189:
 3223 0012 FEE7     		b	.L189
 3224              	.L188:
2446:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 3225              		.loc 1 2446 0 is_stmt 1
 3226 0014 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 3227 0018 C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 3228 001c 1A68     		ldr	r2, [r3]
 3229 001e 7B68     		ldr	r3, [r7, #4]
 3230 0020 1A60     		str	r2, [r3]
2447:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 3231              		.loc 1 2447 0
 3232 0022 40F20003 		movw	r3, #:lower16:xTickCount
 3233 0026 C0F20003 		movt	r3, #:upper16:xTickCount
 3234 002a 1A68     		ldr	r2, [r3]
 3235 002c 7B68     		ldr	r3, [r7, #4]
 3236 002e 5A60     		str	r2, [r3, #4]
2448:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** }
 3237              		.loc 1 2448 0
 3238 0030 0837     		adds	r7, r7, #8
 3239 0032 BD46     		mov	sp, r7
 3240              		@ sp needed
 3241 0034 80BD     		pop	{r7, pc}
 3242              		.cfi_endproc
 3243              	.LFE26:
 3245 0036 00BF     		.section	.text.xTaskCheckForTimeOut,"ax",%progbits
 3246              		.align	2
 3247              		.global	xTaskCheckForTimeOut
 3248              		.thumb
 3249              		.thumb_func
 3251              	xTaskCheckForTimeOut:
 3252              	.LFB27:
2449:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2450:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2451:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
2452:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** {
 3253              		.loc 1 2452 0
 3254              		.cfi_startproc
 3255              		@ args = 0, pretend = 0, frame = 16
 3256              		@ frame_needed = 1, uses_anonymous_args = 0
 3257 0000 80B5     		push	{r7, lr}
 3258              	.LCFI75:
 3259              		.cfi_def_cfa_offset 8
 3260              		.cfi_offset 7, -8
 3261              		.cfi_offset 14, -4
 3262 0002 84B0     		sub	sp, sp, #16
 3263              	.LCFI76:
 3264              		.cfi_def_cfa_offset 24
 3265 0004 00AF     		add	r7, sp, #0
 3266              	.LCFI77:
 3267              		.cfi_def_cfa_register 7
 3268 0006 7860     		str	r0, [r7, #4]
 3269 0008 3960     		str	r1, [r7]
2453:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
2454:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2455:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
 3270              		.loc 1 2455 0
 3271 000a 7B68     		ldr	r3, [r7, #4]
 3272 000c 002B     		cmp	r3, #0
 3273 000e 02D1     		bne	.L191
 3274              		.loc 1 2455 0 is_stmt 0 discriminator 1
 3275 0010 FFF7FEFF 		bl	ulPortSetInterruptMask
 3276              	.L192:
 3277 0014 FEE7     		b	.L192
 3278              	.L191:
2456:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	configASSERT( pxTicksToWait );
 3279              		.loc 1 2456 0 is_stmt 1
 3280 0016 3B68     		ldr	r3, [r7]
 3281 0018 002B     		cmp	r3, #0
 3282 001a 02D1     		bne	.L193
 3283              		.loc 1 2456 0 is_stmt 0 discriminator 1
 3284 001c FFF7FEFF 		bl	ulPortSetInterruptMask
 3285              	.L194:
 3286 0020 FEE7     		b	.L194
 3287              	.L193:
2457:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2458:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
 3288              		.loc 1 2458 0 is_stmt 1
 3289 0022 FFF7FEFF 		bl	vPortEnterCritical
 3290              	.LBB16:
2459:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2460:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this block. */
2461:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		const TickType_t xConstTickCount = xTickCount;
 3291              		.loc 1 2461 0
 3292 0026 40F20003 		movw	r3, #:lower16:xTickCount
 3293 002a C0F20003 		movt	r3, #:upper16:xTickCount
 3294 002e 1B68     		ldr	r3, [r3]
 3295 0030 BB60     		str	r3, [r7, #8]
2462:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2463:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
2464:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
2465:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			the maximum block time then the task should block indefinitely, and
2466:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			therefore never time out. */
2467:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
 3296              		.loc 1 2467 0
 3297 0032 3B68     		ldr	r3, [r7]
 3298 0034 1B68     		ldr	r3, [r3]
 3299 0036 B3F1FF3F 		cmp	r3, #-1
 3300 003a 02D1     		bne	.L195
2468:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
2469:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				xReturn = pdFALSE;
 3301              		.loc 1 2469 0
 3302 003c 0023     		movs	r3, #0
 3303 003e FB60     		str	r3, [r7, #12]
 3304 0040 29E0     		b	.L196
 3305              	.L195:
2470:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
2471:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			else /* We are not blocking indefinitely, perform the checks below. */
2472:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#endif
2473:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2474:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEn
 3306              		.loc 1 2474 0
 3307 0042 7B68     		ldr	r3, [r7, #4]
 3308 0044 1A68     		ldr	r2, [r3]
 3309 0046 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 3310 004a C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 3311 004e 1B68     		ldr	r3, [r3]
 3312 0050 9A42     		cmp	r2, r3
 3313 0052 07D0     		beq	.L197
 3314              		.loc 1 2474 0 is_stmt 0 discriminator 1
 3315 0054 7B68     		ldr	r3, [r7, #4]
 3316 0056 5A68     		ldr	r2, [r3, #4]
 3317 0058 BB68     		ldr	r3, [r7, #8]
 3318 005a 9A42     		cmp	r2, r3
 3319 005c 02D8     		bhi	.L197
2475:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2476:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
2477:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
2478:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			It must have wrapped all the way around and gone past us again. This
2479:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			passed since vTaskSetTimeout() was called. */
2480:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
 3320              		.loc 1 2480 0 is_stmt 1
 3321 005e 0123     		movs	r3, #1
 3322 0060 FB60     		str	r3, [r7, #12]
 3323 0062 18E0     		b	.L196
 3324              	.L197:
2481:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2482:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
 3325              		.loc 1 2482 0
 3326 0064 7B68     		ldr	r3, [r7, #4]
 3327 0066 5B68     		ldr	r3, [r3, #4]
 3328 0068 BA68     		ldr	r2, [r7, #8]
 3329 006a D21A     		subs	r2, r2, r3
 3330 006c 3B68     		ldr	r3, [r7]
 3331 006e 1B68     		ldr	r3, [r3]
 3332 0070 9A42     		cmp	r2, r3
 3333 0072 0ED2     		bcs	.L198
2483:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2484:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
2485:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
 3334              		.loc 1 2485 0
 3335 0074 3B68     		ldr	r3, [r7]
 3336 0076 1A68     		ldr	r2, [r3]
 3337 0078 7B68     		ldr	r3, [r7, #4]
 3338 007a 5968     		ldr	r1, [r3, #4]
 3339 007c BB68     		ldr	r3, [r7, #8]
 3340 007e CB1A     		subs	r3, r1, r3
 3341 0080 1A44     		add	r2, r2, r3
 3342 0082 3B68     		ldr	r3, [r7]
 3343 0084 1A60     		str	r2, [r3]
2486:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 3344              		.loc 1 2486 0
 3345 0086 7868     		ldr	r0, [r7, #4]
 3346 0088 FFF7FEFF 		bl	vTaskSetTimeOutState
2487:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			xReturn = pdFALSE;
 3347              		.loc 1 2487 0
 3348 008c 0023     		movs	r3, #0
 3349 008e FB60     		str	r3, [r7, #12]
 3350 0090 01E0     		b	.L196
 3351              	.L198:
2488:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2489:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
2490:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2491:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
 3352              		.loc 1 2491 0
 3353 0092 0123     		movs	r3, #1
 3354 0094 FB60     		str	r3, [r7, #12]
 3355              	.L196:
 3356              	.LBE16:
2492:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2493:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2494:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
 3357              		.loc 1 2494 0
 3358 0096 FFF7FEFF 		bl	vPortExitCritical
2495:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2496:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	return xReturn;
 3359              		.loc 1 2496 0
 3360 009a FB68     		ldr	r3, [r7, #12]
2497:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** }
 3361              		.loc 1 2497 0
 3362 009c 1846     		mov	r0, r3
 3363 009e 1037     		adds	r7, r7, #16
 3364 00a0 BD46     		mov	sp, r7
 3365              		@ sp needed
 3366 00a2 80BD     		pop	{r7, pc}
 3367              		.cfi_endproc
 3368              	.LFE27:
 3370              		.section	.text.vTaskMissedYield,"ax",%progbits
 3371              		.align	2
 3372              		.global	vTaskMissedYield
 3373              		.thumb
 3374              		.thumb_func
 3376              	vTaskMissedYield:
 3377              	.LFB28:
2498:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2499:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2500:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** void vTaskMissedYield( void )
2501:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** {
 3378              		.loc 1 2501 0
 3379              		.cfi_startproc
 3380              		@ args = 0, pretend = 0, frame = 0
 3381              		@ frame_needed = 1, uses_anonymous_args = 0
 3382              		@ link register save eliminated.
 3383 0000 80B4     		push	{r7}
 3384              	.LCFI78:
 3385              		.cfi_def_cfa_offset 4
 3386              		.cfi_offset 7, -4
 3387 0002 00AF     		add	r7, sp, #0
 3388              	.LCFI79:
 3389              		.cfi_def_cfa_register 7
2502:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	xYieldPending = pdTRUE;
 3390              		.loc 1 2502 0
 3391 0004 40F20003 		movw	r3, #:lower16:xYieldPending
 3392 0008 C0F20003 		movt	r3, #:upper16:xYieldPending
 3393 000c 0122     		movs	r2, #1
 3394 000e 1A60     		str	r2, [r3]
2503:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** }
 3395              		.loc 1 2503 0
 3396 0010 BD46     		mov	sp, r7
 3397              		@ sp needed
 3398 0012 5DF8047B 		ldr	r7, [sp], #4
 3399 0016 7047     		bx	lr
 3400              		.cfi_endproc
 3401              	.LFE28:
 3403              		.section	.text.uxTaskGetTaskNumber,"ax",%progbits
 3404              		.align	2
 3405              		.global	uxTaskGetTaskNumber
 3406              		.thumb
 3407              		.thumb_func
 3409              	uxTaskGetTaskNumber:
 3410              	.LFB29:
2504:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2505:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2506:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2507:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2508:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
2509:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
 3411              		.loc 1 2509 0
 3412              		.cfi_startproc
 3413              		@ args = 0, pretend = 0, frame = 16
 3414              		@ frame_needed = 1, uses_anonymous_args = 0
 3415              		@ link register save eliminated.
 3416 0000 80B4     		push	{r7}
 3417              	.LCFI80:
 3418              		.cfi_def_cfa_offset 4
 3419              		.cfi_offset 7, -4
 3420 0002 85B0     		sub	sp, sp, #20
 3421              	.LCFI81:
 3422              		.cfi_def_cfa_offset 24
 3423 0004 00AF     		add	r7, sp, #0
 3424              	.LCFI82:
 3425              		.cfi_def_cfa_register 7
 3426 0006 7860     		str	r0, [r7, #4]
2510:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn;
2511:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
2512:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2513:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( xTask != NULL )
 3427              		.loc 1 2513 0
 3428 0008 7B68     		ldr	r3, [r7, #4]
 3429 000a 002B     		cmp	r3, #0
 3430 000c 05D0     		beq	.L202
2514:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2515:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			pxTCB = ( TCB_t * ) xTask;
 3431              		.loc 1 2515 0
 3432 000e 7B68     		ldr	r3, [r7, #4]
 3433 0010 BB60     		str	r3, [r7, #8]
2516:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
 3434              		.loc 1 2516 0
 3435 0012 BB68     		ldr	r3, [r7, #8]
 3436 0014 5B6C     		ldr	r3, [r3, #68]
 3437 0016 FB60     		str	r3, [r7, #12]
 3438 0018 01E0     		b	.L203
 3439              	.L202:
2517:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2518:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
2519:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2520:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			uxReturn = 0U;
 3440              		.loc 1 2520 0
 3441 001a 0023     		movs	r3, #0
 3442 001c FB60     		str	r3, [r7, #12]
 3443              	.L203:
2521:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2522:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2523:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		return uxReturn;
 3444              		.loc 1 2523 0
 3445 001e FB68     		ldr	r3, [r7, #12]
2524:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
 3446              		.loc 1 2524 0
 3447 0020 1846     		mov	r0, r3
 3448 0022 1437     		adds	r7, r7, #20
 3449 0024 BD46     		mov	sp, r7
 3450              		@ sp needed
 3451 0026 5DF8047B 		ldr	r7, [sp], #4
 3452 002a 7047     		bx	lr
 3453              		.cfi_endproc
 3454              	.LFE29:
 3456              		.section	.text.vTaskSetTaskNumber,"ax",%progbits
 3457              		.align	2
 3458              		.global	vTaskSetTaskNumber
 3459              		.thumb
 3460              		.thumb_func
 3462              	vTaskSetTaskNumber:
 3463              	.LFB30:
2525:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2526:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2527:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2528:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2529:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2530:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2531:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
2532:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
 3464              		.loc 1 2532 0
 3465              		.cfi_startproc
 3466              		@ args = 0, pretend = 0, frame = 16
 3467              		@ frame_needed = 1, uses_anonymous_args = 0
 3468              		@ link register save eliminated.
 3469 0000 80B4     		push	{r7}
 3470              	.LCFI83:
 3471              		.cfi_def_cfa_offset 4
 3472              		.cfi_offset 7, -4
 3473 0002 85B0     		sub	sp, sp, #20
 3474              	.LCFI84:
 3475              		.cfi_def_cfa_offset 24
 3476 0004 00AF     		add	r7, sp, #0
 3477              	.LCFI85:
 3478              		.cfi_def_cfa_register 7
 3479 0006 7860     		str	r0, [r7, #4]
 3480 0008 3960     		str	r1, [r7]
2533:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
2534:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2535:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( xTask != NULL )
 3481              		.loc 1 2535 0
 3482 000a 7B68     		ldr	r3, [r7, #4]
 3483 000c 002B     		cmp	r3, #0
 3484 000e 04D0     		beq	.L205
2536:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2537:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			pxTCB = ( TCB_t * ) xTask;
 3485              		.loc 1 2537 0
 3486 0010 7B68     		ldr	r3, [r7, #4]
 3487 0012 FB60     		str	r3, [r7, #12]
2538:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
 3488              		.loc 1 2538 0
 3489 0014 FB68     		ldr	r3, [r7, #12]
 3490 0016 3A68     		ldr	r2, [r7]
 3491 0018 5A64     		str	r2, [r3, #68]
 3492              	.L205:
2539:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2540:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
 3493              		.loc 1 2540 0
 3494 001a 1437     		adds	r7, r7, #20
 3495 001c BD46     		mov	sp, r7
 3496              		@ sp needed
 3497 001e 5DF8047B 		ldr	r7, [sp], #4
 3498 0022 7047     		bx	lr
 3499              		.cfi_endproc
 3500              	.LFE30:
 3502              		.section	.text.prvIdleTask,"ax",%progbits
 3503              		.align	2
 3504              		.thumb
 3505              		.thumb_func
 3507              	prvIdleTask:
 3508              	.LFB31:
2541:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2542:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2543:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2544:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*
2545:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * -----------------------------------------------------------
2546:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * The Idle task.
2547:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * ----------------------------------------------------------
2548:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  *
2549:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
2550:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
2551:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  *
2552:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
2553:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  *
2554:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****  */
2555:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
2556:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** {
 3509              		.loc 1 2556 0
 3510              		.cfi_startproc
 3511              		@ args = 0, pretend = 0, frame = 8
 3512              		@ frame_needed = 1, uses_anonymous_args = 0
 3513 0000 80B5     		push	{r7, lr}
 3514              	.LCFI86:
 3515              		.cfi_def_cfa_offset 8
 3516              		.cfi_offset 7, -8
 3517              		.cfi_offset 14, -4
 3518 0002 82B0     		sub	sp, sp, #8
 3519              	.LCFI87:
 3520              		.cfi_def_cfa_offset 16
 3521 0004 00AF     		add	r7, sp, #0
 3522              	.LCFI88:
 3523              		.cfi_def_cfa_register 7
 3524 0006 7860     		str	r0, [r7, #4]
 3525              	.L209:
2557:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* Stop warnings. */
2558:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	( void ) pvParameters;
2559:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2560:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	for( ;; )
2561:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2562:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* See if any tasks have been deleted. */
2563:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		prvCheckTasksWaitingTermination();
 3526              		.loc 1 2563 0
 3527 0008 FFF7FEFF 		bl	prvCheckTasksWaitingTermination
2564:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2565:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
2566:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2567:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
2568:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			see if any other task has become available.  If we are using
2569:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
2570:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			will automatically get the processor anyway. */
2571:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			taskYIELD();
2572:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2573:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_PREEMPTION */
2574:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2575:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
2576:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2577:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
2578:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
2579:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			to run then the idle task should yield before the end of the
2580:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			timeslice.
2581:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2582:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			A critical region is not required here as we are just reading from
2583:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
2584:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			the ready list at the idle priority contains more than one task
2585:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
2586:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 3528              		.loc 1 2586 0
 3529 000c 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 3530 0010 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 3531 0014 1B68     		ldr	r3, [r3]
 3532 0016 012B     		cmp	r3, #1
 3533 0018 01D9     		bls	.L208
2587:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
2588:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				taskYIELD();
 3534              		.loc 1 2588 0
 3535 001a FFF7FEFF 		bl	vPortYield
 3536              	.L208:
 3537              	.LBB17:
2589:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
2590:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			else
2591:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
2592:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2593:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
2594:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2595:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
2596:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2597:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
2598:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2599:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			extern void vApplicationIdleHook( void );
2600:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2601:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
2602:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			allows the application designer to add background functionality
2603:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			without the overhead of a separate task.
2604:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
2605:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
2606:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			vApplicationIdleHook();
 3538              		.loc 1 2606 0
 3539 001e FFF7FEFF 		bl	vApplicationIdleHook
 3540              	.LBE17:
2607:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2608:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_IDLE_HOOK */
2609:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2610:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* This conditional compilation should use inequality to 0, not equality
2611:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
2612:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		user defined low power mode	implementations require
2613:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
2614:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICKLESS_IDLE != 0 )
2615:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2616:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		TickType_t xExpectedIdleTime;
2617:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2618:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* It is not desirable to suspend then resume the scheduler on
2619:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			each iteration of the idle task.  Therefore, a preliminary
2620:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			test of the expected idle time is performed without the
2621:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			scheduler suspended.  The result here is not necessarily
2622:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			valid. */
2623:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			xExpectedIdleTime = prvGetExpectedIdleTime();
2624:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2625:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
2626:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
2627:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				vTaskSuspendAll();
2628:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
2629:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					/* Now the scheduler is suspended, the expected idle
2630:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					time can be sampled again, and this time its value can
2631:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					be used. */
2632:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					configASSERT( xNextTaskUnblockTime >= xTickCount );
2633:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					xExpectedIdleTime = prvGetExpectedIdleTime();
2634:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2635:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
2636:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					{
2637:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						traceLOW_POWER_IDLE_BEGIN();
2638:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
2639:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						traceLOW_POWER_IDLE_END();
2640:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					}
2641:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					else
2642:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					{
2643:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2644:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					}
2645:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
2646:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				( void ) xTaskResumeAll();
2647:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
2648:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			else
2649:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
2650:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2651:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
2652:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2653:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_TICKLESS_IDLE */
2654:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
 3541              		.loc 1 2654 0
 3542 0022 F1E7     		b	.L209
 3543              		.cfi_endproc
 3544              	.LFE31:
 3546              		.section	.text.prvInitialiseTCBVariables,"ax",%progbits
 3547              		.align	2
 3548              		.thumb
 3549              		.thumb_func
 3551              	prvInitialiseTCBVariables:
 3552              	.LFB32:
2655:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** }
2656:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2657:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2658:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if configUSE_TICKLESS_IDLE != 0
2659:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2660:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
2661:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2662:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	eSleepModeStatus eReturn = eStandardSleep;
2663:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2664:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
2665:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2666:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* A task was made ready while the scheduler was suspended. */
2667:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			eReturn = eAbortSleep;
2668:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2669:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else if( xYieldPending != pdFALSE )
2670:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2671:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* A yield was pended while the scheduler was suspended. */
2672:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			eReturn = eAbortSleep;
2673:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2674:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
2675:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2676:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			#if configUSE_TIMERS == 0
2677:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
2678:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* The idle task exists in addition to the application tasks. */
2679:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				const UBaseType_t uxNonApplicationTasks = 1;
2680:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2681:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* If timers are not being used and all the tasks are in the
2682:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				suspended list (which might mean they have an infinite block
2683:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				time rather than actually being suspended) then it is safe to
2684:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				turn all clocks off and just wait for external interrupts. */
2685:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicati
2686:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
2687:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					eReturn = eNoTasksWaitingTimeout;
2688:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
2689:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				else
2690:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
2691:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2692:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
2693:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
2694:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			#endif /* configUSE_TIMERS */
2695:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2696:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2697:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		return eReturn;
2698:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2699:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2700:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2701:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2702:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t 
2703:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** {
 3553              		.loc 1 2703 0
 3554              		.cfi_startproc
 3555              		@ args = 4, pretend = 0, frame = 24
 3556              		@ frame_needed = 1, uses_anonymous_args = 0
 3557 0000 80B5     		push	{r7, lr}
 3558              	.LCFI89:
 3559              		.cfi_def_cfa_offset 8
 3560              		.cfi_offset 7, -8
 3561              		.cfi_offset 14, -4
 3562 0002 86B0     		sub	sp, sp, #24
 3563              	.LCFI90:
 3564              		.cfi_def_cfa_offset 32
 3565 0004 00AF     		add	r7, sp, #0
 3566              	.LCFI91:
 3567              		.cfi_def_cfa_register 7
 3568 0006 F860     		str	r0, [r7, #12]
 3569 0008 B960     		str	r1, [r7, #8]
 3570 000a 7A60     		str	r2, [r7, #4]
 3571 000c 3B60     		str	r3, [r7]
2704:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** UBaseType_t x;
2705:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2706:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* Store the task name in the TCB. */
2707:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 3572              		.loc 1 2707 0
 3573 000e 0023     		movs	r3, #0
 3574 0010 7B61     		str	r3, [r7, #20]
 3575 0012 12E0     		b	.L211
 3576              	.L214:
2708:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2709:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		pxTCB->pcTaskName[ x ] = pcName[ x ];
 3577              		.loc 1 2709 0
 3578 0014 BA68     		ldr	r2, [r7, #8]
 3579 0016 7B69     		ldr	r3, [r7, #20]
 3580 0018 1344     		add	r3, r3, r2
 3581 001a 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 3582 001c F968     		ldr	r1, [r7, #12]
 3583 001e 7B69     		ldr	r3, [r7, #20]
 3584 0020 0B44     		add	r3, r3, r1
 3585 0022 3033     		adds	r3, r3, #48
 3586 0024 1A71     		strb	r2, [r3, #4]
2710:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2711:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
2712:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		configMAX_TASK_NAME_LEN characters just in case the memory after the
2713:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		string is not accessible (extremely unlikely). */
2714:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( pcName[ x ] == 0x00 )
 3587              		.loc 1 2714 0
 3588 0026 BA68     		ldr	r2, [r7, #8]
 3589 0028 7B69     		ldr	r3, [r7, #20]
 3590 002a 1344     		add	r3, r3, r2
 3591 002c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 3592 002e 002B     		cmp	r3, #0
 3593 0030 00D1     		bne	.L212
2715:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2716:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			break;
 3594              		.loc 1 2716 0
 3595 0032 05E0     		b	.L213
 3596              	.L212:
2707:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
 3597              		.loc 1 2707 0
 3598 0034 7B69     		ldr	r3, [r7, #20]
 3599 0036 0133     		adds	r3, r3, #1
 3600 0038 7B61     		str	r3, [r7, #20]
 3601              	.L211:
2707:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
 3602              		.loc 1 2707 0 is_stmt 0 discriminator 1
 3603 003a 7B69     		ldr	r3, [r7, #20]
 3604 003c 092B     		cmp	r3, #9
 3605 003e E9D9     		bls	.L214
 3606              	.L213:
2717:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2718:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
2719:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2720:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2721:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2722:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2723:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2724:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* Ensure the name string is terminated in the case that the string length
2725:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	was greater or equal to configMAX_TASK_NAME_LEN. */
2726:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 3607              		.loc 1 2726 0 is_stmt 1
 3608 0040 FB68     		ldr	r3, [r7, #12]
 3609 0042 0022     		movs	r2, #0
 3610 0044 83F83D20 		strb	r2, [r3, #61]
2727:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2728:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
2729:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	remove the privilege bit if one is present. */
2730:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 3611              		.loc 1 2730 0
 3612 0048 7B68     		ldr	r3, [r7, #4]
 3613 004a 042B     		cmp	r3, #4
 3614 004c 01D9     		bls	.L215
2731:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2732:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 3615              		.loc 1 2732 0
 3616 004e 0423     		movs	r3, #4
 3617 0050 7B60     		str	r3, [r7, #4]
 3618              	.L215:
2733:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2734:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	else
2735:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2736:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
2737:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2738:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2739:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	pxTCB->uxPriority = uxPriority;
 3619              		.loc 1 2739 0
 3620 0052 FB68     		ldr	r3, [r7, #12]
 3621 0054 7A68     		ldr	r2, [r7, #4]
 3622 0056 DA62     		str	r2, [r3, #44]
2740:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
2741:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2742:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
 3623              		.loc 1 2742 0
 3624 0058 FB68     		ldr	r3, [r7, #12]
 3625 005a 7A68     		ldr	r2, [r7, #4]
 3626 005c 9A64     		str	r2, [r3, #72]
2743:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		pxTCB->uxMutexesHeld = 0;
 3627              		.loc 1 2743 0
 3628 005e FB68     		ldr	r3, [r7, #12]
 3629 0060 0022     		movs	r2, #0
 3630 0062 DA64     		str	r2, [r3, #76]
2744:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2745:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_MUTEXES */
2746:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2747:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 3631              		.loc 1 2747 0
 3632 0064 FB68     		ldr	r3, [r7, #12]
 3633 0066 0433     		adds	r3, r3, #4
 3634 0068 1846     		mov	r0, r3
 3635 006a FFF7FEFF 		bl	vListInitialiseItem
2748:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 3636              		.loc 1 2748 0
 3637 006e FB68     		ldr	r3, [r7, #12]
 3638 0070 1833     		adds	r3, r3, #24
 3639 0072 1846     		mov	r0, r3
 3640 0074 FFF7FEFF 		bl	vListInitialiseItem
2749:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2750:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
2751:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
2752:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 3641              		.loc 1 2752 0
 3642 0078 FB68     		ldr	r3, [r7, #12]
 3643 007a FA68     		ldr	r2, [r7, #12]
 3644 007c 1A61     		str	r2, [r3, #16]
2753:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2754:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* Event lists are always in priority order. */
2755:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickT
 3645              		.loc 1 2755 0
 3646 007e 7B68     		ldr	r3, [r7, #4]
 3647 0080 C3F10502 		rsb	r2, r3, #5
 3648 0084 FB68     		ldr	r3, [r7, #12]
 3649 0086 9A61     		str	r2, [r3, #24]
2756:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 3650              		.loc 1 2756 0
 3651 0088 FB68     		ldr	r3, [r7, #12]
 3652 008a FA68     		ldr	r2, [r7, #12]
 3653 008c 5A62     		str	r2, [r3, #36]
2757:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2758:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
2759:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2760:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		pxTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
2761:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2762:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#endif /* portCRITICAL_NESTING_IN_TCB */
2763:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2764:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
2765:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2766:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		pxTCB->pxTaskTag = NULL;
2767:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2768:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_APPLICATION_TASK_TAG */
2769:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2770:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
2771:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2772:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
2773:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2774:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#endif /* configGENERATE_RUN_TIME_STATS */
2775:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2776:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
2777:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2778:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
2779:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2780:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#else /* portUSING_MPU_WRAPPERS */
2781:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2782:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		( void ) xRegions;
2783:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		( void ) usStackDepth;
2784:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2785:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS */
2786:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2787:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
2788:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2789:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Initialise this task's Newlib reent structure. */
2790:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
2791:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2792:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_NEWLIB_REENTRANT */
2793:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** }
 3654              		.loc 1 2793 0
 3655 008e 1837     		adds	r7, r7, #24
 3656 0090 BD46     		mov	sp, r7
 3657              		@ sp needed
 3658 0092 80BD     		pop	{r7, pc}
 3659              		.cfi_endproc
 3660              	.LFE32:
 3662              		.section	.text.prvInitialiseTaskLists,"ax",%progbits
 3663              		.align	2
 3664              		.thumb
 3665              		.thumb_func
 3667              	prvInitialiseTaskLists:
 3668              	.LFB33:
2794:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2795:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2796:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
2797:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2798:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
2799:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2800:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
2801:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2802:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then we are deleting ourselves. */
2803:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2804:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2805:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2806:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2807:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2808:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
2809:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2810:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2811:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void )
2812:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** {
 3669              		.loc 1 2812 0
 3670              		.cfi_startproc
 3671              		@ args = 0, pretend = 0, frame = 8
 3672              		@ frame_needed = 1, uses_anonymous_args = 0
 3673 0000 80B5     		push	{r7, lr}
 3674              	.LCFI92:
 3675              		.cfi_def_cfa_offset 8
 3676              		.cfi_offset 7, -8
 3677              		.cfi_offset 14, -4
 3678 0002 82B0     		sub	sp, sp, #8
 3679              	.LCFI93:
 3680              		.cfi_def_cfa_offset 16
 3681 0004 00AF     		add	r7, sp, #0
 3682              	.LCFI94:
 3683              		.cfi_def_cfa_register 7
2813:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** UBaseType_t uxPriority;
2814:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2815:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriorit
 3684              		.loc 1 2815 0
 3685 0006 0023     		movs	r3, #0
 3686 0008 7B60     		str	r3, [r7, #4]
 3687 000a 0FE0     		b	.L217
 3688              	.L218:
2816:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2817:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 3689              		.loc 1 2817 0 discriminator 2
 3690 000c 7A68     		ldr	r2, [r7, #4]
 3691 000e 1346     		mov	r3, r2
 3692 0010 9B00     		lsls	r3, r3, #2
 3693 0012 1344     		add	r3, r3, r2
 3694 0014 9B00     		lsls	r3, r3, #2
 3695 0016 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 3696 001a C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 3697 001e 1344     		add	r3, r3, r2
 3698 0020 1846     		mov	r0, r3
 3699 0022 FFF7FEFF 		bl	vListInitialise
2815:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
 3700              		.loc 1 2815 0 discriminator 2
 3701 0026 7B68     		ldr	r3, [r7, #4]
 3702 0028 0133     		adds	r3, r3, #1
 3703 002a 7B60     		str	r3, [r7, #4]
 3704              	.L217:
2815:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
 3705              		.loc 1 2815 0 is_stmt 0 discriminator 1
 3706 002c 7B68     		ldr	r3, [r7, #4]
 3707 002e 042B     		cmp	r3, #4
 3708 0030 ECD9     		bls	.L218
2818:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2819:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2820:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	vListInitialise( &xDelayedTaskList1 );
 3709              		.loc 1 2820 0 is_stmt 1
 3710 0032 40F20000 		movw	r0, #:lower16:xDelayedTaskList1
 3711 0036 C0F20000 		movt	r0, #:upper16:xDelayedTaskList1
 3712 003a FFF7FEFF 		bl	vListInitialise
2821:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
 3713              		.loc 1 2821 0
 3714 003e 40F20000 		movw	r0, #:lower16:xDelayedTaskList2
 3715 0042 C0F20000 		movt	r0, #:upper16:xDelayedTaskList2
 3716 0046 FFF7FEFF 		bl	vListInitialise
2822:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	vListInitialise( &xPendingReadyList );
 3717              		.loc 1 2822 0
 3718 004a 40F20000 		movw	r0, #:lower16:xPendingReadyList
 3719 004e C0F20000 		movt	r0, #:upper16:xPendingReadyList
 3720 0052 FFF7FEFF 		bl	vListInitialise
2823:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2824:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2825:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2826:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		vListInitialise( &xTasksWaitingTermination );
 3721              		.loc 1 2826 0
 3722 0056 40F20000 		movw	r0, #:lower16:xTasksWaitingTermination
 3723 005a C0F20000 		movt	r0, #:upper16:xTasksWaitingTermination
 3724 005e FFF7FEFF 		bl	vListInitialise
2827:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2828:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
2829:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2830:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2831:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2832:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		vListInitialise( &xSuspendedTaskList );
 3725              		.loc 1 2832 0
 3726 0062 40F20000 		movw	r0, #:lower16:xSuspendedTaskList
 3727 0066 C0F20000 		movt	r0, #:upper16:xSuspendedTaskList
 3728 006a FFF7FEFF 		bl	vListInitialise
2833:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2834:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
2835:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2836:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
2837:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	using list2. */
2838:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 3729              		.loc 1 2838 0
 3730 006e 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 3731 0072 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 3732 0076 40F20002 		movw	r2, #:lower16:xDelayedTaskList1
 3733 007a C0F20002 		movt	r2, #:upper16:xDelayedTaskList1
 3734 007e 1A60     		str	r2, [r3]
2839:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 3735              		.loc 1 2839 0
 3736 0080 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 3737 0084 C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 3738 0088 40F20002 		movw	r2, #:lower16:xDelayedTaskList2
 3739 008c C0F20002 		movt	r2, #:upper16:xDelayedTaskList2
 3740 0090 1A60     		str	r2, [r3]
2840:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** }
 3741              		.loc 1 2840 0
 3742 0092 0837     		adds	r7, r7, #8
 3743 0094 BD46     		mov	sp, r7
 3744              		@ sp needed
 3745 0096 80BD     		pop	{r7, pc}
 3746              		.cfi_endproc
 3747              	.LFE33:
 3749              		.section	.text.prvCheckTasksWaitingTermination,"ax",%progbits
 3750              		.align	2
 3751              		.thumb
 3752              		.thumb_func
 3754              	prvCheckTasksWaitingTermination:
 3755              	.LFB34:
2841:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2842:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2843:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
2844:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** {
 3756              		.loc 1 2844 0
 3757              		.cfi_startproc
 3758              		@ args = 0, pretend = 0, frame = 8
 3759              		@ frame_needed = 1, uses_anonymous_args = 0
 3760 0000 80B5     		push	{r7, lr}
 3761              	.LCFI95:
 3762              		.cfi_def_cfa_offset 8
 3763              		.cfi_offset 7, -8
 3764              		.cfi_offset 14, -4
 3765 0002 82B0     		sub	sp, sp, #8
 3766              	.LCFI96:
 3767              		.cfi_def_cfa_offset 16
 3768 0004 00AF     		add	r7, sp, #0
 3769              	.LCFI97:
 3770              		.cfi_def_cfa_register 7
 3771              	.LBB18:
2845:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2846:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2847:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		BaseType_t xListIsEmpty;
2848:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2849:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
2850:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		too often in the idle task. */
2851:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		while( uxTasksDeleted > ( UBaseType_t ) 0U )
 3772              		.loc 1 2851 0
 3773 0006 3AE0     		b	.L220
 3774              	.L221:
2852:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2853:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
 3775              		.loc 1 2853 0
 3776 0008 FFF7FEFF 		bl	vTaskSuspendAll
2854:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
2855:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 3777              		.loc 1 2855 0
 3778 000c 40F20003 		movw	r3, #:lower16:xTasksWaitingTermination
 3779 0010 C0F20003 		movt	r3, #:upper16:xTasksWaitingTermination
 3780 0014 1B68     		ldr	r3, [r3]
 3781 0016 002B     		cmp	r3, #0
 3782 0018 14BF     		ite	ne
 3783 001a 0023     		movne	r3, #0
 3784 001c 0123     		moveq	r3, #1
 3785 001e DBB2     		uxtb	r3, r3
 3786 0020 7B60     		str	r3, [r7, #4]
2856:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
2857:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			( void ) xTaskResumeAll();
 3787              		.loc 1 2857 0
 3788 0022 FFF7FEFF 		bl	xTaskResumeAll
2858:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2859:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			if( xListIsEmpty == pdFALSE )
 3789              		.loc 1 2859 0
 3790 0026 7B68     		ldr	r3, [r7, #4]
 3791 0028 002B     		cmp	r3, #0
 3792 002a 28D1     		bne	.L220
 3793              	.LBB19:
2860:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
2861:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				TCB_t *pxTCB;
2862:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2863:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				taskENTER_CRITICAL();
 3794              		.loc 1 2863 0
 3795 002c FFF7FEFF 		bl	vPortEnterCritical
2864:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
2865:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 3796              		.loc 1 2865 0
 3797 0030 40F20003 		movw	r3, #:lower16:xTasksWaitingTermination
 3798 0034 C0F20003 		movt	r3, #:upper16:xTasksWaitingTermination
 3799 0038 DB68     		ldr	r3, [r3, #12]
 3800 003a DB68     		ldr	r3, [r3, #12]
 3801 003c 3B60     		str	r3, [r7]
2866:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 3802              		.loc 1 2866 0
 3803 003e 3B68     		ldr	r3, [r7]
 3804 0040 0433     		adds	r3, r3, #4
 3805 0042 1846     		mov	r0, r3
 3806 0044 FFF7FEFF 		bl	uxListRemove
2867:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					--uxCurrentNumberOfTasks;
 3807              		.loc 1 2867 0
 3808 0048 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 3809 004c C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 3810 0050 1B68     		ldr	r3, [r3]
 3811 0052 5A1E     		subs	r2, r3, #1
 3812 0054 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 3813 0058 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 3814 005c 1A60     		str	r2, [r3]
2868:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					--uxTasksDeleted;
 3815              		.loc 1 2868 0
 3816 005e 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 3817 0062 C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 3818 0066 1B68     		ldr	r3, [r3]
 3819 0068 5A1E     		subs	r2, r3, #1
 3820 006a 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 3821 006e C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 3822 0072 1A60     		str	r2, [r3]
2869:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
2870:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				taskEXIT_CRITICAL();
 3823              		.loc 1 2870 0
 3824 0074 FFF7FEFF 		bl	vPortExitCritical
2871:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2872:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				prvDeleteTCB( pxTCB );
 3825              		.loc 1 2872 0
 3826 0078 3868     		ldr	r0, [r7]
 3827 007a FFF7FEFF 		bl	prvDeleteTCB
 3828              	.L220:
 3829              	.LBE19:
2851:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
 3830              		.loc 1 2851 0 discriminator 1
 3831 007e 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 3832 0082 C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 3833 0086 1B68     		ldr	r3, [r3]
 3834 0088 002B     		cmp	r3, #0
 3835 008a BDD1     		bne	.L221
 3836              	.LBE18:
2873:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
2874:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			else
2875:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
2876:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2877:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
2878:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2879:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2880:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	#endif /* vTaskDelete */
2881:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** }
 3837              		.loc 1 2881 0
 3838 008c 0837     		adds	r7, r7, #8
 3839 008e BD46     		mov	sp, r7
 3840              		@ sp needed
 3841 0090 80BD     		pop	{r7, pc}
 3842              		.cfi_endproc
 3843              	.LFE34:
 3845 0092 00BF     		.section	.text.prvAddCurrentTaskToDelayedList,"ax",%progbits
 3846              		.align	2
 3847              		.thumb
 3848              		.thumb_func
 3850              	prvAddCurrentTaskToDelayedList:
 3851              	.LFB35:
2882:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2883:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2884:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
2885:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** {
 3852              		.loc 1 2885 0
 3853              		.cfi_startproc
 3854              		@ args = 0, pretend = 0, frame = 8
 3855              		@ frame_needed = 1, uses_anonymous_args = 0
 3856 0000 80B5     		push	{r7, lr}
 3857              	.LCFI98:
 3858              		.cfi_def_cfa_offset 8
 3859              		.cfi_offset 7, -8
 3860              		.cfi_offset 14, -4
 3861 0002 82B0     		sub	sp, sp, #8
 3862              	.LCFI99:
 3863              		.cfi_def_cfa_offset 16
 3864 0004 00AF     		add	r7, sp, #0
 3865              	.LCFI100:
 3866              		.cfi_def_cfa_register 7
 3867 0006 7860     		str	r0, [r7, #4]
2886:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* The list item will be inserted in wake time order. */
2887:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 3868              		.loc 1 2887 0
 3869 0008 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3870 000c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3871 0010 1B68     		ldr	r3, [r3]
 3872 0012 7A68     		ldr	r2, [r7, #4]
 3873 0014 5A60     		str	r2, [r3, #4]
2888:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2889:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	if( xTimeToWake < xTickCount )
 3874              		.loc 1 2889 0
 3875 0016 40F20003 		movw	r3, #:lower16:xTickCount
 3876 001a C0F20003 		movt	r3, #:upper16:xTickCount
 3877 001e 1B68     		ldr	r3, [r3]
 3878 0020 7A68     		ldr	r2, [r7, #4]
 3879 0022 9A42     		cmp	r2, r3
 3880 0024 0FD2     		bcs	.L223
2890:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2891:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Wake time has overflowed.  Place this item in the overflow list. */
2892:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 3881              		.loc 1 2892 0
 3882 0026 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 3883 002a C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 3884 002e 1A68     		ldr	r2, [r3]
 3885 0030 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3886 0034 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3887 0038 1B68     		ldr	r3, [r3]
 3888 003a 0433     		adds	r3, r3, #4
 3889 003c 1046     		mov	r0, r2
 3890 003e 1946     		mov	r1, r3
 3891 0040 FFF7FEFF 		bl	vListInsert
 3892 0044 1CE0     		b	.L222
 3893              	.L223:
2893:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2894:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	else
2895:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2896:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* The wake time has not overflowed, so the current block list is used. */
2897:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 3894              		.loc 1 2897 0
 3895 0046 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 3896 004a C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 3897 004e 1A68     		ldr	r2, [r3]
 3898 0050 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3899 0054 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3900 0058 1B68     		ldr	r3, [r3]
 3901 005a 0433     		adds	r3, r3, #4
 3902 005c 1046     		mov	r0, r2
 3903 005e 1946     		mov	r1, r3
 3904 0060 FFF7FEFF 		bl	vListInsert
2898:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2899:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* If the task entering the blocked state was placed at the head of the
2900:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		list of blocked tasks then xNextTaskUnblockTime needs to be updated
2901:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		too. */
2902:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( xTimeToWake < xNextTaskUnblockTime )
 3905              		.loc 1 2902 0
 3906 0064 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 3907 0068 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 3908 006c 1B68     		ldr	r3, [r3]
 3909 006e 7A68     		ldr	r2, [r7, #4]
 3910 0070 9A42     		cmp	r2, r3
 3911 0072 05D2     		bcs	.L222
2903:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2904:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			xNextTaskUnblockTime = xTimeToWake;
 3912              		.loc 1 2904 0
 3913 0074 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 3914 0078 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 3915 007c 7A68     		ldr	r2, [r7, #4]
 3916 007e 1A60     		str	r2, [r3]
 3917              	.L222:
2905:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2906:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
2907:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2908:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2909:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2910:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2911:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** }
 3918              		.loc 1 2911 0
 3919 0080 0837     		adds	r7, r7, #8
 3920 0082 BD46     		mov	sp, r7
 3921              		@ sp needed
 3922 0084 80BD     		pop	{r7, pc}
 3923              		.cfi_endproc
 3924              	.LFE35:
 3926 0086 00BF     		.section	.text.prvAllocateTCBAndStack,"ax",%progbits
 3927              		.align	2
 3928              		.thumb
 3929              		.thumb_func
 3931              	prvAllocateTCBAndStack:
 3932              	.LFB36:
2912:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2913:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2914:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuff
2915:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** {
 3933              		.loc 1 2915 0
 3934              		.cfi_startproc
 3935              		@ args = 0, pretend = 0, frame = 16
 3936              		@ frame_needed = 1, uses_anonymous_args = 0
 3937 0000 80B5     		push	{r7, lr}
 3938              	.LCFI101:
 3939              		.cfi_def_cfa_offset 8
 3940              		.cfi_offset 7, -8
 3941              		.cfi_offset 14, -4
 3942 0002 84B0     		sub	sp, sp, #16
 3943              	.LCFI102:
 3944              		.cfi_def_cfa_offset 24
 3945 0004 00AF     		add	r7, sp, #0
 3946              	.LCFI103:
 3947              		.cfi_def_cfa_register 7
 3948 0006 0346     		mov	r3, r0
 3949 0008 3960     		str	r1, [r7]
 3950 000a FB80     		strh	r3, [r7, #6]	@ movhi
2916:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** TCB_t *pxNewTCB;
2917:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2918:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* Allocate space for the TCB.  Where the memory comes from depends on
2919:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	the implementation of the port malloc function. */
2920:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 3951              		.loc 1 2920 0
 3952 000c 5020     		movs	r0, #80
 3953 000e FFF7FEFF 		bl	pvPortMalloc
 3954 0012 F860     		str	r0, [r7, #12]
2921:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2922:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	if( pxNewTCB != NULL )
 3955              		.loc 1 2922 0
 3956 0014 FB68     		ldr	r3, [r7, #12]
 3957 0016 002B     		cmp	r3, #0
 3958 0018 1FD0     		beq	.L226
2923:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
2924:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Allocate space for the stack used by the task being created.
2925:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		The base of the stack memory stored in the TCB so the task can
2926:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		be deleted later if required. */
2927:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof
 3959              		.loc 1 2927 0
 3960 001a 3B68     		ldr	r3, [r7]
 3961 001c 002B     		cmp	r3, #0
 3962 001e 06D1     		bne	.L227
 3963              		.loc 1 2927 0 is_stmt 0 discriminator 1
 3964 0020 FB88     		ldrh	r3, [r7, #6]
 3965 0022 9B00     		lsls	r3, r3, #2
 3966 0024 1846     		mov	r0, r3
 3967 0026 FFF7FEFF 		bl	pvPortMalloc
 3968 002a 0346     		mov	r3, r0
 3969 002c 00E0     		b	.L228
 3970              	.L227:
 3971              		.loc 1 2927 0 discriminator 2
 3972 002e 3B68     		ldr	r3, [r7]
 3973              	.L228:
 3974              		.loc 1 2927 0 discriminator 3
 3975 0030 FA68     		ldr	r2, [r7, #12]
 3976 0032 1363     		str	r3, [r2, #48]
2928:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2929:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
 3977              		.loc 1 2929 0 is_stmt 1 discriminator 3
 3978 0034 FB68     		ldr	r3, [r7, #12]
 3979 0036 1B6B     		ldr	r3, [r3, #48]
 3980 0038 002B     		cmp	r3, #0
 3981 003a 05D1     		bne	.L229
2930:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2931:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Could not allocate the stack.  Delete the allocated TCB. */
2932:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			vPortFree( pxNewTCB );
 3982              		.loc 1 2932 0
 3983 003c F868     		ldr	r0, [r7, #12]
 3984 003e FFF7FEFF 		bl	vPortFree
2933:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			pxNewTCB = NULL;
 3985              		.loc 1 2933 0
 3986 0042 0023     		movs	r3, #0
 3987 0044 FB60     		str	r3, [r7, #12]
 3988 0046 08E0     		b	.L226
 3989              	.L229:
2934:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2935:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
2936:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2937:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Avoid dependency on memset() if it is not required. */
2938:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_ux
2939:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
2940:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* Just to help debugging. */
2941:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeo
 3990              		.loc 1 2941 0
 3991 0048 FB68     		ldr	r3, [r7, #12]
 3992 004a 1A6B     		ldr	r2, [r3, #48]
 3993 004c FB88     		ldrh	r3, [r7, #6]
 3994 004e 9B00     		lsls	r3, r3, #2
 3995 0050 1046     		mov	r0, r2
 3996 0052 A521     		movs	r1, #165
 3997 0054 1A46     		mov	r2, r3
 3998 0056 FFF7FEFF 		bl	memset
 3999              	.L226:
2942:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
2943:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( I
2944:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
2945:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
2946:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2947:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	return pxNewTCB;
 4000              		.loc 1 2947 0
 4001 005a FB68     		ldr	r3, [r7, #12]
2948:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** }
 4002              		.loc 1 2948 0
 4003 005c 1846     		mov	r0, r3
 4004 005e 1037     		adds	r7, r7, #16
 4005 0060 BD46     		mov	sp, r7
 4006              		@ sp needed
 4007 0062 80BD     		pop	{r7, pc}
 4008              		.cfi_endproc
 4009              	.LFE36:
 4011              		.section	.text.prvListTaskWithinSingleList,"ax",%progbits
 4012              		.align	2
 4013              		.thumb
 4014              		.thumb_func
 4016              	prvListTaskWithinSingleList:
 4017              	.LFB37:
2949:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2950:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2951:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2952:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2953:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, e
2954:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
 4018              		.loc 1 2954 0
 4019              		.cfi_startproc
 4020              		@ args = 0, pretend = 0, frame = 40
 4021              		@ frame_needed = 1, uses_anonymous_args = 0
 4022 0000 90B5     		push	{r4, r7, lr}
 4023              	.LCFI104:
 4024              		.cfi_def_cfa_offset 12
 4025              		.cfi_offset 4, -12
 4026              		.cfi_offset 7, -8
 4027              		.cfi_offset 14, -4
 4028 0002 8BB0     		sub	sp, sp, #44
 4029              	.LCFI105:
 4030              		.cfi_def_cfa_offset 56
 4031 0004 00AF     		add	r7, sp, #0
 4032              	.LCFI106:
 4033              		.cfi_def_cfa_register 7
 4034 0006 F860     		str	r0, [r7, #12]
 4035 0008 B960     		str	r1, [r7, #8]
 4036 000a 1346     		mov	r3, r2
 4037 000c FB71     		strb	r3, [r7, #7]
2955:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	volatile TCB_t *pxNextTCB, *pxFirstTCB;
2956:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTask = 0;
 4038              		.loc 1 2956 0
 4039 000e 0023     		movs	r3, #0
 4040 0010 7B62     		str	r3, [r7, #36]
2957:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2958:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 4041              		.loc 1 2958 0
 4042 0012 BB68     		ldr	r3, [r7, #8]
 4043 0014 1B68     		ldr	r3, [r3]
 4044 0016 002B     		cmp	r3, #0
 4045 0018 78D0     		beq	.L232
 4046              	.LBB20:
2959:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
2960:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 4047              		.loc 1 2960 0
 4048 001a BB68     		ldr	r3, [r7, #8]
 4049 001c 3B62     		str	r3, [r7, #32]
 4050 001e 3B6A     		ldr	r3, [r7, #32]
 4051 0020 5B68     		ldr	r3, [r3, #4]
 4052 0022 5A68     		ldr	r2, [r3, #4]
 4053 0024 3B6A     		ldr	r3, [r7, #32]
 4054 0026 5A60     		str	r2, [r3, #4]
 4055 0028 3B6A     		ldr	r3, [r7, #32]
 4056 002a 5A68     		ldr	r2, [r3, #4]
 4057 002c 3B6A     		ldr	r3, [r7, #32]
 4058 002e 0833     		adds	r3, r3, #8
 4059 0030 9A42     		cmp	r2, r3
 4060 0032 04D1     		bne	.L233
 4061              		.loc 1 2960 0 is_stmt 0 discriminator 1
 4062 0034 3B6A     		ldr	r3, [r7, #32]
 4063 0036 5B68     		ldr	r3, [r3, #4]
 4064 0038 5A68     		ldr	r2, [r3, #4]
 4065 003a 3B6A     		ldr	r3, [r7, #32]
 4066 003c 5A60     		str	r2, [r3, #4]
 4067              	.L233:
 4068              		.loc 1 2960 0 discriminator 2
 4069 003e 3B6A     		ldr	r3, [r7, #32]
 4070 0040 5B68     		ldr	r3, [r3, #4]
 4071 0042 DB68     		ldr	r3, [r3, #12]
 4072 0044 FB61     		str	r3, [r7, #28]
 4073              	.L236:
 4074              	.LBE20:
 4075              	.LBB21:
2961:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2962:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Populate an TaskStatus_t structure within the
2963:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			pxTaskStatusArray array for each task that is referenced from
2964:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			pxList.  See the definition of TaskStatus_t in task.h for the
2965:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			meaning of each TaskStatus_t structure member. */
2966:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			do
2967:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
2968:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 4076              		.loc 1 2968 0 is_stmt 1
 4077 0046 BB68     		ldr	r3, [r7, #8]
 4078 0048 BB61     		str	r3, [r7, #24]
 4079 004a BB69     		ldr	r3, [r7, #24]
 4080 004c 5B68     		ldr	r3, [r3, #4]
 4081 004e 5A68     		ldr	r2, [r3, #4]
 4082 0050 BB69     		ldr	r3, [r7, #24]
 4083 0052 5A60     		str	r2, [r3, #4]
 4084 0054 BB69     		ldr	r3, [r7, #24]
 4085 0056 5A68     		ldr	r2, [r3, #4]
 4086 0058 BB69     		ldr	r3, [r7, #24]
 4087 005a 0833     		adds	r3, r3, #8
 4088 005c 9A42     		cmp	r2, r3
 4089 005e 04D1     		bne	.L234
 4090              		.loc 1 2968 0 is_stmt 0 discriminator 1
 4091 0060 BB69     		ldr	r3, [r7, #24]
 4092 0062 5B68     		ldr	r3, [r3, #4]
 4093 0064 5A68     		ldr	r2, [r3, #4]
 4094 0066 BB69     		ldr	r3, [r7, #24]
 4095 0068 5A60     		str	r2, [r3, #4]
 4096              	.L234:
 4097              		.loc 1 2968 0 discriminator 2
 4098 006a BB69     		ldr	r3, [r7, #24]
 4099 006c 5B68     		ldr	r3, [r3, #4]
 4100 006e DB68     		ldr	r3, [r3, #12]
 4101 0070 7B61     		str	r3, [r7, #20]
 4102              	.LBE21:
2969:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2970:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].xHandle = ( TaskHandle_t ) pxNextTCB;
 4103              		.loc 1 2970 0 is_stmt 1 discriminator 2
 4104 0072 7B6A     		ldr	r3, [r7, #36]
 4105 0074 5B01     		lsls	r3, r3, #5
 4106 0076 FA68     		ldr	r2, [r7, #12]
 4107 0078 1344     		add	r3, r3, r2
 4108 007a 7A69     		ldr	r2, [r7, #20]
 4109 007c 1A60     		str	r2, [r3]
2971:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].pcTaskName = ( const char * ) &( pxNextTCB->pcTaskName [ 0 ] );
 4110              		.loc 1 2971 0 discriminator 2
 4111 007e 7B6A     		ldr	r3, [r7, #36]
 4112 0080 5B01     		lsls	r3, r3, #5
 4113 0082 FA68     		ldr	r2, [r7, #12]
 4114 0084 1344     		add	r3, r3, r2
 4115 0086 7A69     		ldr	r2, [r7, #20]
 4116 0088 3432     		adds	r2, r2, #52
 4117 008a 5A60     		str	r2, [r3, #4]
2972:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].xTaskNumber = pxNextTCB->uxTCBNumber;
 4118              		.loc 1 2972 0 discriminator 2
 4119 008c 7B6A     		ldr	r3, [r7, #36]
 4120 008e 5B01     		lsls	r3, r3, #5
 4121 0090 FA68     		ldr	r2, [r7, #12]
 4122 0092 1344     		add	r3, r3, r2
 4123 0094 7A69     		ldr	r2, [r7, #20]
 4124 0096 126C     		ldr	r2, [r2, #64]
 4125 0098 9A60     		str	r2, [r3, #8]
2973:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].eCurrentState = eState;
 4126              		.loc 1 2973 0 discriminator 2
 4127 009a 7B6A     		ldr	r3, [r7, #36]
 4128 009c 5B01     		lsls	r3, r3, #5
 4129 009e FA68     		ldr	r2, [r7, #12]
 4130 00a0 1344     		add	r3, r3, r2
 4131 00a2 FA79     		ldrb	r2, [r7, #7]
 4132 00a4 1A73     		strb	r2, [r3, #12]
2974:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].uxCurrentPriority = pxNextTCB->uxPriority;
 4133              		.loc 1 2974 0 discriminator 2
 4134 00a6 7B6A     		ldr	r3, [r7, #36]
 4135 00a8 5B01     		lsls	r3, r3, #5
 4136 00aa FA68     		ldr	r2, [r7, #12]
 4137 00ac 1344     		add	r3, r3, r2
 4138 00ae 7A69     		ldr	r2, [r7, #20]
 4139 00b0 D26A     		ldr	r2, [r2, #44]
 4140 00b2 1A61     		str	r2, [r3, #16]
2975:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2976:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
2977:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
2978:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					/* If the task is in the suspended list then there is a chance
2979:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					it is actually just blocked indefinitely - so really it should
2980:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					be reported as being in the Blocked state. */
2981:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					if( eState == eSuspended )
 4141              		.loc 1 2981 0 discriminator 2
 4142 00b4 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4143 00b6 032B     		cmp	r3, #3
 4144 00b8 09D1     		bne	.L235
2982:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					{
2983:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						if( listLIST_ITEM_CONTAINER( &( pxNextTCB->xEventListItem ) ) != NULL )
 4145              		.loc 1 2983 0
 4146 00ba 7B69     		ldr	r3, [r7, #20]
 4147 00bc 9B6A     		ldr	r3, [r3, #40]
 4148 00be 002B     		cmp	r3, #0
 4149 00c0 05D0     		beq	.L235
2984:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						{
2985:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							pxTaskStatusArray[ uxTask ].eCurrentState = eBlocked;
 4150              		.loc 1 2985 0
 4151 00c2 7B6A     		ldr	r3, [r7, #36]
 4152 00c4 5B01     		lsls	r3, r3, #5
 4153 00c6 FA68     		ldr	r2, [r7, #12]
 4154 00c8 1344     		add	r3, r3, r2
 4155 00ca 0222     		movs	r2, #2
 4156 00cc 1A73     		strb	r2, [r3, #12]
 4157              	.L235:
2986:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						}
2987:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					}
2988:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
2989:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				#endif /* INCLUDE_vTaskSuspend */
2990:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
2991:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
2992:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
2993:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].uxBasePriority = pxNextTCB->uxBasePriority;
 4158              		.loc 1 2993 0
 4159 00ce 7B6A     		ldr	r3, [r7, #36]
 4160 00d0 5B01     		lsls	r3, r3, #5
 4161 00d2 FA68     		ldr	r2, [r7, #12]
 4162 00d4 1344     		add	r3, r3, r2
 4163 00d6 7A69     		ldr	r2, [r7, #20]
 4164 00d8 926C     		ldr	r2, [r2, #72]
 4165 00da 5A61     		str	r2, [r3, #20]
2994:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
2995:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				#else
2996:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
2997:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].uxBasePriority = 0;
2998:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
2999:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				#endif
3000:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3001:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1 )
3002:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
3003:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = pxNextTCB->ulRunTimeCounter;
3004:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
3005:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				#else
3006:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
3007:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = 0;
 4166              		.loc 1 3007 0
 4167 00dc 7B6A     		ldr	r3, [r7, #36]
 4168 00de 5B01     		lsls	r3, r3, #5
 4169 00e0 FA68     		ldr	r2, [r7, #12]
 4170 00e2 1344     		add	r3, r3, r2
 4171 00e4 0022     		movs	r2, #0
 4172 00e6 9A61     		str	r2, [r3, #24]
3008:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
3009:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				#endif
3010:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3011:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				#if ( portSTACK_GROWTH > 0 )
3012:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
3013:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) p
3014:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
3015:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				#else
3016:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
3017:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) p
 4173              		.loc 1 3017 0
 4174 00e8 7B6A     		ldr	r3, [r7, #36]
 4175 00ea 5B01     		lsls	r3, r3, #5
 4176 00ec FA68     		ldr	r2, [r7, #12]
 4177 00ee D418     		adds	r4, r2, r3
 4178 00f0 7B69     		ldr	r3, [r7, #20]
 4179 00f2 1B6B     		ldr	r3, [r3, #48]
 4180 00f4 1846     		mov	r0, r3
 4181 00f6 FFF7FEFF 		bl	prvTaskCheckFreeStackSpace
 4182 00fa 0346     		mov	r3, r0
 4183 00fc A383     		strh	r3, [r4, #28]	@ movhi
3018:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
3019:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				#endif
3020:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3021:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				uxTask++;
 4184              		.loc 1 3021 0
 4185 00fe 7B6A     		ldr	r3, [r7, #36]
 4186 0100 0133     		adds	r3, r3, #1
 4187 0102 7B62     		str	r3, [r7, #36]
3022:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3023:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
 4188              		.loc 1 3023 0
 4189 0104 7A69     		ldr	r2, [r7, #20]
 4190 0106 FB69     		ldr	r3, [r7, #28]
 4191 0108 9A42     		cmp	r2, r3
 4192 010a 9CD1     		bne	.L236
 4193              	.L232:
3024:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
3025:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
3026:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
3027:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3028:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
3029:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3030:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		return uxTask;
 4194              		.loc 1 3030 0
 4195 010c 7B6A     		ldr	r3, [r7, #36]
3031:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
 4196              		.loc 1 3031 0
 4197 010e 1846     		mov	r0, r3
 4198 0110 2C37     		adds	r7, r7, #44
 4199 0112 BD46     		mov	sp, r7
 4200              		@ sp needed
 4201 0114 90BD     		pop	{r4, r7, pc}
 4202              		.cfi_endproc
 4203              	.LFE37:
 4205 0116 00BF     		.section	.text.prvTaskCheckFreeStackSpace,"ax",%progbits
 4206              		.align	2
 4207              		.thumb
 4208              		.thumb_func
 4210              	prvTaskCheckFreeStackSpace:
 4211              	.LFB38:
3032:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3033:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3034:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3035:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3036:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
3037:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3038:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
3039:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
 4212              		.loc 1 3039 0
 4213              		.cfi_startproc
 4214              		@ args = 0, pretend = 0, frame = 16
 4215              		@ frame_needed = 1, uses_anonymous_args = 0
 4216              		@ link register save eliminated.
 4217 0000 80B4     		push	{r7}
 4218              	.LCFI107:
 4219              		.cfi_def_cfa_offset 4
 4220              		.cfi_offset 7, -4
 4221 0002 85B0     		sub	sp, sp, #20
 4222              	.LCFI108:
 4223              		.cfi_def_cfa_offset 24
 4224 0004 00AF     		add	r7, sp, #0
 4225              	.LCFI109:
 4226              		.cfi_def_cfa_register 7
 4227 0006 7860     		str	r0, [r7, #4]
3040:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	uint32_t ulCount = 0U;
 4228              		.loc 1 3040 0
 4229 0008 0023     		movs	r3, #0
 4230 000a FB60     		str	r3, [r7, #12]
3041:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3042:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 4231              		.loc 1 3042 0
 4232 000c 05E0     		b	.L239
 4233              	.L240:
3043:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
3044:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
 4234              		.loc 1 3044 0
 4235 000e 7B68     		ldr	r3, [r7, #4]
 4236 0010 0133     		adds	r3, r3, #1
 4237 0012 7B60     		str	r3, [r7, #4]
3045:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			ulCount++;
 4238              		.loc 1 3045 0
 4239 0014 FB68     		ldr	r3, [r7, #12]
 4240 0016 0133     		adds	r3, r3, #1
 4241 0018 FB60     		str	r3, [r7, #12]
 4242              	.L239:
3042:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
 4243              		.loc 1 3042 0 discriminator 1
 4244 001a 7B68     		ldr	r3, [r7, #4]
 4245 001c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 4246 001e A52B     		cmp	r3, #165
 4247 0020 F5D0     		beq	.L240
3046:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
3047:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3048:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller a
 4248              		.loc 1 3048 0
 4249 0022 FB68     		ldr	r3, [r7, #12]
 4250 0024 9B08     		lsrs	r3, r3, #2
 4251 0026 FB60     		str	r3, [r7, #12]
3049:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3050:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		return ( uint16_t ) ulCount;
 4252              		.loc 1 3050 0
 4253 0028 FB68     		ldr	r3, [r7, #12]
 4254 002a 9BB2     		uxth	r3, r3
3051:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
 4255              		.loc 1 3051 0
 4256 002c 1846     		mov	r0, r3
 4257 002e 1437     		adds	r7, r7, #20
 4258 0030 BD46     		mov	sp, r7
 4259              		@ sp needed
 4260 0032 5DF8047B 		ldr	r7, [sp], #4
 4261 0036 7047     		bx	lr
 4262              		.cfi_endproc
 4263              	.LFE38:
 4265              		.section	.text.prvDeleteTCB,"ax",%progbits
 4266              		.align	2
 4267              		.thumb
 4268              		.thumb_func
 4270              	prvDeleteTCB:
 4271              	.LFB39:
3052:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3053:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
3054:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3055:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3056:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
3057:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3058:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
3059:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
3060:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3061:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	uint8_t *pucEndOfStack;
3062:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn;
3063:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3064:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
3065:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3066:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#if portSTACK_GROWTH < 0
3067:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
3068:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
3069:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
3070:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#else
3071:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
3072:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3073:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
3074:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#endif
3075:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3076:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
3077:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3078:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		return uxReturn;
3079:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
3080:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3081:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
3082:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3083:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3084:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
3085:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3086:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB )
3087:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
 4272              		.loc 1 3087 0
 4273              		.cfi_startproc
 4274              		@ args = 0, pretend = 0, frame = 8
 4275              		@ frame_needed = 1, uses_anonymous_args = 0
 4276 0000 80B5     		push	{r7, lr}
 4277              	.LCFI110:
 4278              		.cfi_def_cfa_offset 8
 4279              		.cfi_offset 7, -8
 4280              		.cfi_offset 14, -4
 4281 0002 82B0     		sub	sp, sp, #8
 4282              	.LCFI111:
 4283              		.cfi_def_cfa_offset 16
 4284 0004 00AF     		add	r7, sp, #0
 4285              	.LCFI112:
 4286              		.cfi_def_cfa_register 7
 4287 0006 7860     		str	r0, [r7, #4]
3088:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
3089:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		above the vPortFree() calls.  The call is also used by ports/demos that
3090:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		want to allocate and clean RAM statically. */
3091:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
3092:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3093:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up
3094:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		to the task to free any memory allocated at the application level. */
3095:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
3096:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
3097:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
3098:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
3099:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
3100:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		vPortFreeAligned( pxTCB->pxStack );
 4288              		.loc 1 3100 0
 4289 0008 7B68     		ldr	r3, [r7, #4]
 4290 000a 1B6B     		ldr	r3, [r3, #48]
 4291 000c 1846     		mov	r0, r3
 4292 000e FFF7FEFF 		bl	vPortFree
3101:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		vPortFree( pxTCB );
 4293              		.loc 1 3101 0
 4294 0012 7868     		ldr	r0, [r7, #4]
 4295 0014 FFF7FEFF 		bl	vPortFree
3102:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
 4296              		.loc 1 3102 0
 4297 0018 0837     		adds	r7, r7, #8
 4298 001a BD46     		mov	sp, r7
 4299              		@ sp needed
 4300 001c 80BD     		pop	{r7, pc}
 4301              		.cfi_endproc
 4302              	.LFE39:
 4304 001e 00BF     		.section	.text.prvResetNextTaskUnblockTime,"ax",%progbits
 4305              		.align	2
 4306              		.thumb
 4307              		.thumb_func
 4309              	prvResetNextTaskUnblockTime:
 4310              	.LFB40:
3103:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3104:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
3105:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3106:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3107:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** static void prvResetNextTaskUnblockTime( void )
3108:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** {
 4311              		.loc 1 3108 0
 4312              		.cfi_startproc
 4313              		@ args = 0, pretend = 0, frame = 8
 4314              		@ frame_needed = 1, uses_anonymous_args = 0
 4315              		@ link register save eliminated.
 4316 0000 80B4     		push	{r7}
 4317              	.LCFI113:
 4318              		.cfi_def_cfa_offset 4
 4319              		.cfi_offset 7, -4
 4320 0002 83B0     		sub	sp, sp, #12
 4321              	.LCFI114:
 4322              		.cfi_def_cfa_offset 16
 4323 0004 00AF     		add	r7, sp, #0
 4324              	.LCFI115:
 4325              		.cfi_def_cfa_register 7
3109:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** TCB_t *pxTCB;
3110:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3111:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 4326              		.loc 1 3111 0
 4327 0006 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 4328 000a C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 4329 000e 1B68     		ldr	r3, [r3]
 4330 0010 1B68     		ldr	r3, [r3]
 4331 0012 002B     		cmp	r3, #0
 4332 0014 01D1     		bne	.L244
 4333              		.loc 1 3111 0 is_stmt 0 discriminator 1
 4334 0016 0123     		movs	r3, #1
 4335 0018 00E0     		b	.L245
 4336              	.L244:
 4337              		.loc 1 3111 0 discriminator 2
 4338 001a 0023     		movs	r3, #0
 4339              	.L245:
 4340              		.loc 1 3111 0 discriminator 3
 4341 001c 002B     		cmp	r3, #0
 4342 001e 07D0     		beq	.L246
3112:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
3113:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* The new current delayed list is empty.  Set
3114:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime to the maximum possible value so it is
3115:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		extremely unlikely that the
3116:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
3117:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		there is an item in the delayed list. */
3118:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
 4343              		.loc 1 3118 0 is_stmt 1
 4344 0020 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 4345 0024 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 4346 0028 4FF0FF32 		mov	r2, #-1
 4347 002c 1A60     		str	r2, [r3]
 4348 002e 0EE0     		b	.L243
 4349              	.L246:
3119:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
3120:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	else
3121:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
3122:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* The new current delayed list is not empty, get the value of
3123:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		the item at the head of the delayed list.  This is the time at
3124:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		which the task at the head of the delayed list should be removed
3125:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		from the Blocked state. */
3126:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 4350              		.loc 1 3126 0
 4351 0030 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 4352 0034 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 4353 0038 1B68     		ldr	r3, [r3]
 4354 003a DB68     		ldr	r3, [r3, #12]
 4355 003c DB68     		ldr	r3, [r3, #12]
 4356 003e 7B60     		str	r3, [r7, #4]
3127:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 4357              		.loc 1 3127 0
 4358 0040 7B68     		ldr	r3, [r7, #4]
 4359 0042 5A68     		ldr	r2, [r3, #4]
 4360 0044 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 4361 0048 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 4362 004c 1A60     		str	r2, [r3]
 4363              	.L243:
3128:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
3129:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** }
 4364              		.loc 1 3129 0
 4365 004e 0C37     		adds	r7, r7, #12
 4366 0050 BD46     		mov	sp, r7
 4367              		@ sp needed
 4368 0052 5DF8047B 		ldr	r7, [sp], #4
 4369 0056 7047     		bx	lr
 4370              		.cfi_endproc
 4371              	.LFE40:
 4373              		.section	.text.xTaskGetCurrentTaskHandle,"ax",%progbits
 4374              		.align	2
 4375              		.global	xTaskGetCurrentTaskHandle
 4376              		.thumb
 4377              		.thumb_func
 4379              	xTaskGetCurrentTaskHandle:
 4380              	.LFB41:
3130:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3131:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3132:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
3133:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3134:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	TaskHandle_t xTaskGetCurrentTaskHandle( void )
3135:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
 4381              		.loc 1 3135 0
 4382              		.cfi_startproc
 4383              		@ args = 0, pretend = 0, frame = 8
 4384              		@ frame_needed = 1, uses_anonymous_args = 0
 4385              		@ link register save eliminated.
 4386 0000 80B4     		push	{r7}
 4387              	.LCFI116:
 4388              		.cfi_def_cfa_offset 4
 4389              		.cfi_offset 7, -4
 4390 0002 83B0     		sub	sp, sp, #12
 4391              	.LCFI117:
 4392              		.cfi_def_cfa_offset 16
 4393 0004 00AF     		add	r7, sp, #0
 4394              	.LCFI118:
 4395              		.cfi_def_cfa_register 7
3136:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	TaskHandle_t xReturn;
3137:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3138:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* A critical section is not required as this is not called from
3139:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		an interrupt and the current TCB will always be the same for any
3140:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		individual execution thread. */
3141:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		xReturn = pxCurrentTCB;
 4396              		.loc 1 3141 0
 4397 0006 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 4398 000a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 4399 000e 1B68     		ldr	r3, [r3]
 4400 0010 7B60     		str	r3, [r7, #4]
3142:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3143:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		return xReturn;
 4401              		.loc 1 3143 0
 4402 0012 7B68     		ldr	r3, [r7, #4]
3144:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
 4403              		.loc 1 3144 0
 4404 0014 1846     		mov	r0, r3
 4405 0016 0C37     		adds	r7, r7, #12
 4406 0018 BD46     		mov	sp, r7
 4407              		@ sp needed
 4408 001a 5DF8047B 		ldr	r7, [sp], #4
 4409 001e 7047     		bx	lr
 4410              		.cfi_endproc
 4411              	.LFE41:
 4413              		.section	.text.xTaskGetSchedulerState,"ax",%progbits
 4414              		.align	2
 4415              		.global	xTaskGetSchedulerState
 4416              		.thumb
 4417              		.thumb_func
 4419              	xTaskGetSchedulerState:
 4420              	.LFB42:
3145:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3146:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
3147:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3148:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3149:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
3150:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3151:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskGetSchedulerState( void )
3152:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
 4421              		.loc 1 3152 0
 4422              		.cfi_startproc
 4423              		@ args = 0, pretend = 0, frame = 8
 4424              		@ frame_needed = 1, uses_anonymous_args = 0
 4425              		@ link register save eliminated.
 4426 0000 80B4     		push	{r7}
 4427              	.LCFI119:
 4428              		.cfi_def_cfa_offset 4
 4429              		.cfi_offset 7, -4
 4430 0002 83B0     		sub	sp, sp, #12
 4431              	.LCFI120:
 4432              		.cfi_def_cfa_offset 16
 4433 0004 00AF     		add	r7, sp, #0
 4434              	.LCFI121:
 4435              		.cfi_def_cfa_register 7
3153:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
3154:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3155:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
 4436              		.loc 1 3155 0
 4437 0006 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 4438 000a C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 4439 000e 1B68     		ldr	r3, [r3]
 4440 0010 002B     		cmp	r3, #0
 4441 0012 02D1     		bne	.L251
3156:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
3157:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
 4442              		.loc 1 3157 0
 4443 0014 0123     		movs	r3, #1
 4444 0016 7B60     		str	r3, [r7, #4]
 4445 0018 0BE0     		b	.L252
 4446              	.L251:
3158:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
3159:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
3160:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
3161:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 4447              		.loc 1 3161 0
 4448 001a 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 4449 001e C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 4450 0022 1B68     		ldr	r3, [r3]
 4451 0024 002B     		cmp	r3, #0
 4452 0026 02D1     		bne	.L253
3162:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
3163:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
 4453              		.loc 1 3163 0
 4454 0028 0223     		movs	r3, #2
 4455 002a 7B60     		str	r3, [r7, #4]
 4456 002c 01E0     		b	.L252
 4457              	.L253:
3164:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
3165:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			else
3166:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
3167:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
 4458              		.loc 1 3167 0
 4459 002e 0023     		movs	r3, #0
 4460 0030 7B60     		str	r3, [r7, #4]
 4461              	.L252:
3168:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
3169:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
3170:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3171:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		return xReturn;
 4462              		.loc 1 3171 0
 4463 0032 7B68     		ldr	r3, [r7, #4]
3172:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
 4464              		.loc 1 3172 0
 4465 0034 1846     		mov	r0, r3
 4466 0036 0C37     		adds	r7, r7, #12
 4467 0038 BD46     		mov	sp, r7
 4468              		@ sp needed
 4469 003a 5DF8047B 		ldr	r7, [sp], #4
 4470 003e 7047     		bx	lr
 4471              		.cfi_endproc
 4472              	.LFE42:
 4474              		.section	.text.vTaskPriorityInherit,"ax",%progbits
 4475              		.align	2
 4476              		.global	vTaskPriorityInherit
 4477              		.thumb
 4478              		.thumb_func
 4480              	vTaskPriorityInherit:
 4481              	.LFB43:
3173:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3174:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
3175:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3176:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3177:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3178:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3179:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
3180:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
 4482              		.loc 1 3180 0
 4483              		.cfi_startproc
 4484              		@ args = 0, pretend = 0, frame = 16
 4485              		@ frame_needed = 1, uses_anonymous_args = 0
 4486 0000 80B5     		push	{r7, lr}
 4487              	.LCFI122:
 4488              		.cfi_def_cfa_offset 8
 4489              		.cfi_offset 7, -8
 4490              		.cfi_offset 14, -4
 4491 0002 84B0     		sub	sp, sp, #16
 4492              	.LCFI123:
 4493              		.cfi_def_cfa_offset 24
 4494 0004 00AF     		add	r7, sp, #0
 4495              	.LCFI124:
 4496              		.cfi_def_cfa_register 7
 4497 0006 7860     		str	r0, [r7, #4]
3181:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
 4498              		.loc 1 3181 0
 4499 0008 7B68     		ldr	r3, [r7, #4]
 4500 000a FB60     		str	r3, [r7, #12]
3182:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3183:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* If the mutex was given back by an interrupt while the queue was
3184:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		locked then the mutex holder might now be NULL. */
3185:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
 4501              		.loc 1 3185 0
 4502 000c 7B68     		ldr	r3, [r7, #4]
 4503 000e 002B     		cmp	r3, #0
 4504 0010 00F08480 		beq	.L255
3186:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
3187:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 4505              		.loc 1 3187 0
 4506 0014 FB68     		ldr	r3, [r7, #12]
 4507 0016 DA6A     		ldr	r2, [r3, #44]
 4508 0018 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 4509 001c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 4510 0020 1B68     		ldr	r3, [r3]
 4511 0022 DB6A     		ldr	r3, [r3, #44]
 4512 0024 9A42     		cmp	r2, r3
 4513 0026 79D2     		bcs	.L255
3188:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
3189:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* Adjust the mutex holder state to account for its new
3190:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				priority.  Only reset the event list item value if the value is
3191:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				not	being used for anything else. */
3192:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE 
 4514              		.loc 1 3192 0
 4515 0028 FB68     		ldr	r3, [r7, #12]
 4516 002a 9B69     		ldr	r3, [r3, #24]
 4517 002c 002B     		cmp	r3, #0
 4518 002e 09DB     		blt	.L257
3193:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
3194:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( T
 4519              		.loc 1 3194 0
 4520 0030 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 4521 0034 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 4522 0038 1B68     		ldr	r3, [r3]
 4523 003a DB6A     		ldr	r3, [r3, #44]
 4524 003c C3F10502 		rsb	r2, r3, #5
 4525 0040 FB68     		ldr	r3, [r7, #12]
 4526 0042 9A61     		str	r2, [r3, #24]
 4527              	.L257:
3195:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
3196:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				else
3197:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
3198:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3199:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
3200:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3201:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* If the task being modified is in the ready state it will need to
3202:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				be moved into a new list. */
3203:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericLis
 4528              		.loc 1 3203 0
 4529 0044 FB68     		ldr	r3, [r7, #12]
 4530 0046 5969     		ldr	r1, [r3, #20]
 4531 0048 FB68     		ldr	r3, [r7, #12]
 4532 004a DA6A     		ldr	r2, [r3, #44]
 4533 004c 1346     		mov	r3, r2
 4534 004e 9B00     		lsls	r3, r3, #2
 4535 0050 1344     		add	r3, r3, r2
 4536 0052 9B00     		lsls	r3, r3, #2
 4537 0054 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 4538 0058 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 4539 005c 1344     		add	r3, r3, r2
 4540 005e 9942     		cmp	r1, r3
 4541 0060 01D1     		bne	.L258
 4542              		.loc 1 3203 0 is_stmt 0 discriminator 1
 4543 0062 0123     		movs	r3, #1
 4544 0064 00E0     		b	.L259
 4545              	.L258:
 4546              		.loc 1 3203 0 discriminator 2
 4547 0066 0023     		movs	r3, #0
 4548              	.L259:
 4549              		.loc 1 3203 0 discriminator 3
 4550 0068 002B     		cmp	r3, #0
 4551 006a 4FD0     		beq	.L260
3204:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
3205:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 4552              		.loc 1 3205 0 is_stmt 1
 4553 006c FB68     		ldr	r3, [r7, #12]
 4554 006e 0433     		adds	r3, r3, #4
 4555 0070 1846     		mov	r0, r3
 4556 0072 FFF7FEFF 		bl	uxListRemove
 4557 0076 0346     		mov	r3, r0
 4558 0078 002B     		cmp	r3, #0
 4559 007a 1ED1     		bne	.L261
3206:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					{
3207:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 4560              		.loc 1 3207 0
 4561 007c FB68     		ldr	r3, [r7, #12]
 4562 007e D96A     		ldr	r1, [r3, #44]
 4563 0080 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 4564 0084 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 4565 0088 0B46     		mov	r3, r1
 4566 008a 9B00     		lsls	r3, r3, #2
 4567 008c 0B44     		add	r3, r3, r1
 4568 008e 9B00     		lsls	r3, r3, #2
 4569 0090 1344     		add	r3, r3, r2
 4570 0092 1B68     		ldr	r3, [r3]
 4571 0094 002B     		cmp	r3, #0
 4572 0096 10D1     		bne	.L261
 4573              		.loc 1 3207 0 is_stmt 0 discriminator 1
 4574 0098 FB68     		ldr	r3, [r7, #12]
 4575 009a DB6A     		ldr	r3, [r3, #44]
 4576 009c 0122     		movs	r2, #1
 4577 009e 02FA03F3 		lsl	r3, r2, r3
 4578 00a2 DA43     		mvns	r2, r3
 4579 00a4 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 4580 00a8 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 4581 00ac 1B68     		ldr	r3, [r3]
 4582 00ae 1A40     		ands	r2, r2, r3
 4583 00b0 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 4584 00b4 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 4585 00b8 1A60     		str	r2, [r3]
 4586              	.L261:
3208:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					}
3209:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					else
3210:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					{
3211:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3212:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					}
3213:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3214:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					/* Inherit the priority before being moved into the new list. */
3215:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 4587              		.loc 1 3215 0 is_stmt 1 discriminator 1
 4588 00ba 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 4589 00be C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 4590 00c2 1B68     		ldr	r3, [r3]
 4591 00c4 DA6A     		ldr	r2, [r3, #44]
 4592 00c6 FB68     		ldr	r3, [r7, #12]
 4593 00c8 DA62     		str	r2, [r3, #44]
3216:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 4594              		.loc 1 3216 0 discriminator 1
 4595 00ca FB68     		ldr	r3, [r7, #12]
 4596 00cc DB6A     		ldr	r3, [r3, #44]
 4597 00ce 0122     		movs	r2, #1
 4598 00d0 9A40     		lsls	r2, r2, r3
 4599 00d2 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 4600 00d6 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 4601 00da 1B68     		ldr	r3, [r3]
 4602 00dc 1A43     		orrs	r2, r2, r3
 4603 00de 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 4604 00e2 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 4605 00e6 1A60     		str	r2, [r3]
 4606 00e8 FB68     		ldr	r3, [r7, #12]
 4607 00ea DA6A     		ldr	r2, [r3, #44]
 4608 00ec 1346     		mov	r3, r2
 4609 00ee 9B00     		lsls	r3, r3, #2
 4610 00f0 1344     		add	r3, r3, r2
 4611 00f2 9B00     		lsls	r3, r3, #2
 4612 00f4 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 4613 00f8 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 4614 00fc 1A44     		add	r2, r2, r3
 4615 00fe FB68     		ldr	r3, [r7, #12]
 4616 0100 0433     		adds	r3, r3, #4
 4617 0102 1046     		mov	r0, r2
 4618 0104 1946     		mov	r1, r3
 4619 0106 FFF7FEFF 		bl	vListInsertEnd
 4620 010a 07E0     		b	.L255
 4621              	.L260:
3217:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
3218:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				else
3219:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
3220:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					/* Just inherit the priority. */
3221:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 4622              		.loc 1 3221 0
 4623 010c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 4624 0110 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 4625 0114 1B68     		ldr	r3, [r3]
 4626 0116 DA6A     		ldr	r2, [r3, #44]
 4627 0118 FB68     		ldr	r3, [r7, #12]
 4628 011a DA62     		str	r2, [r3, #44]
 4629              	.L255:
3222:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
3223:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3224:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
3225:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
3226:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			else
3227:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
3228:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3229:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
3230:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
3231:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
3232:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
3233:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3234:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
3235:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
 4630              		.loc 1 3235 0
 4631 011c 1037     		adds	r7, r7, #16
 4632 011e BD46     		mov	sp, r7
 4633              		@ sp needed
 4634 0120 80BD     		pop	{r7, pc}
 4635              		.cfi_endproc
 4636              	.LFE43:
 4638 0122 00BF     		.section	.text.xTaskPriorityDisinherit,"ax",%progbits
 4639              		.align	2
 4640              		.global	xTaskPriorityDisinherit
 4641              		.thumb
 4642              		.thumb_func
 4644              	xTaskPriorityDisinherit:
 4645              	.LFB44:
3236:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3237:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
3238:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3239:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3240:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3241:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3242:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
3243:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
 4646              		.loc 1 3243 0
 4647              		.cfi_startproc
 4648              		@ args = 0, pretend = 0, frame = 16
 4649              		@ frame_needed = 1, uses_anonymous_args = 0
 4650 0000 80B5     		push	{r7, lr}
 4651              	.LCFI125:
 4652              		.cfi_def_cfa_offset 8
 4653              		.cfi_offset 7, -8
 4654              		.cfi_offset 14, -4
 4655 0002 84B0     		sub	sp, sp, #16
 4656              	.LCFI126:
 4657              		.cfi_def_cfa_offset 24
 4658 0004 00AF     		add	r7, sp, #0
 4659              	.LCFI127:
 4660              		.cfi_def_cfa_register 7
 4661 0006 7860     		str	r0, [r7, #4]
3244:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
 4662              		.loc 1 3244 0
 4663 0008 7B68     		ldr	r3, [r7, #4]
 4664 000a BB60     		str	r3, [r7, #8]
3245:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
 4665              		.loc 1 3245 0
 4666 000c 0023     		movs	r3, #0
 4667 000e FB60     		str	r3, [r7, #12]
3246:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3247:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
 4668              		.loc 1 3247 0
 4669 0010 7B68     		ldr	r3, [r7, #4]
 4670 0012 002B     		cmp	r3, #0
 4671 0014 68D0     		beq	.L265
3248:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
3249:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			configASSERT( pxTCB->uxMutexesHeld );
 4672              		.loc 1 3249 0
 4673 0016 BB68     		ldr	r3, [r7, #8]
 4674 0018 DB6C     		ldr	r3, [r3, #76]
 4675 001a 002B     		cmp	r3, #0
 4676 001c 02D1     		bne	.L266
 4677              		.loc 1 3249 0 is_stmt 0 discriminator 1
 4678 001e FFF7FEFF 		bl	ulPortSetInterruptMask
 4679              	.L267:
 4680 0022 FEE7     		b	.L267
 4681              	.L266:
3250:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			( pxTCB->uxMutexesHeld )--;
 4682              		.loc 1 3250 0 is_stmt 1
 4683 0024 BB68     		ldr	r3, [r7, #8]
 4684 0026 DB6C     		ldr	r3, [r3, #76]
 4685 0028 5A1E     		subs	r2, r3, #1
 4686 002a BB68     		ldr	r3, [r7, #8]
 4687 002c DA64     		str	r2, [r3, #76]
3251:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3252:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 4688              		.loc 1 3252 0
 4689 002e BB68     		ldr	r3, [r7, #8]
 4690 0030 DA6A     		ldr	r2, [r3, #44]
 4691 0032 BB68     		ldr	r3, [r7, #8]
 4692 0034 9B6C     		ldr	r3, [r3, #72]
 4693 0036 9A42     		cmp	r2, r3
 4694 0038 56D0     		beq	.L265
3253:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
3254:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* Only disinherit if no other mutexes are held. */
3255:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 4695              		.loc 1 3255 0
 4696 003a BB68     		ldr	r3, [r7, #8]
 4697 003c DB6C     		ldr	r3, [r3, #76]
 4698 003e 002B     		cmp	r3, #0
 4699 0040 52D1     		bne	.L265
3256:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
3257:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					/* The holding task must be the running task to be able to give
3258:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					the mutex back.  Remove the holding task from the ready list. */
3259:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 4700              		.loc 1 3259 0
 4701 0042 BB68     		ldr	r3, [r7, #8]
 4702 0044 0433     		adds	r3, r3, #4
 4703 0046 1846     		mov	r0, r3
 4704 0048 FFF7FEFF 		bl	uxListRemove
 4705 004c 0346     		mov	r3, r0
 4706 004e 002B     		cmp	r3, #0
 4707 0050 1ED1     		bne	.L268
3260:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					{
3261:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 4708              		.loc 1 3261 0
 4709 0052 BB68     		ldr	r3, [r7, #8]
 4710 0054 D96A     		ldr	r1, [r3, #44]
 4711 0056 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 4712 005a C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 4713 005e 0B46     		mov	r3, r1
 4714 0060 9B00     		lsls	r3, r3, #2
 4715 0062 0B44     		add	r3, r3, r1
 4716 0064 9B00     		lsls	r3, r3, #2
 4717 0066 1344     		add	r3, r3, r2
 4718 0068 1B68     		ldr	r3, [r3]
 4719 006a 002B     		cmp	r3, #0
 4720 006c 10D1     		bne	.L268
 4721              		.loc 1 3261 0 is_stmt 0 discriminator 1
 4722 006e BB68     		ldr	r3, [r7, #8]
 4723 0070 DB6A     		ldr	r3, [r3, #44]
 4724 0072 0122     		movs	r2, #1
 4725 0074 02FA03F3 		lsl	r3, r2, r3
 4726 0078 DA43     		mvns	r2, r3
 4727 007a 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 4728 007e C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 4729 0082 1B68     		ldr	r3, [r3]
 4730 0084 1A40     		ands	r2, r2, r3
 4731 0086 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 4732 008a C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 4733 008e 1A60     		str	r2, [r3]
 4734              	.L268:
3262:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					}
3263:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					else
3264:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					{
3265:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3266:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					}
3267:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3268:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					/* Disinherit the priority before adding the task into the new
3269:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					ready list. */
3270:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
3271:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = pxTCB->uxBasePriority;
 4735              		.loc 1 3271 0 is_stmt 1 discriminator 1
 4736 0090 BB68     		ldr	r3, [r7, #8]
 4737 0092 9A6C     		ldr	r2, [r3, #72]
 4738 0094 BB68     		ldr	r3, [r7, #8]
 4739 0096 DA62     		str	r2, [r3, #44]
3272:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3273:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					/* Reset the event list item value.  It cannot be in use for
3274:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					any other purpose if this task is running, and it must be
3275:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					running to give back the mutex. */
3276:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( T
 4740              		.loc 1 3276 0 discriminator 1
 4741 0098 BB68     		ldr	r3, [r7, #8]
 4742 009a DB6A     		ldr	r3, [r3, #44]
 4743 009c C3F10502 		rsb	r2, r3, #5
 4744 00a0 BB68     		ldr	r3, [r7, #8]
 4745 00a2 9A61     		str	r2, [r3, #24]
3277:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 4746              		.loc 1 3277 0 discriminator 1
 4747 00a4 BB68     		ldr	r3, [r7, #8]
 4748 00a6 DB6A     		ldr	r3, [r3, #44]
 4749 00a8 0122     		movs	r2, #1
 4750 00aa 9A40     		lsls	r2, r2, r3
 4751 00ac 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 4752 00b0 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 4753 00b4 1B68     		ldr	r3, [r3]
 4754 00b6 1A43     		orrs	r2, r2, r3
 4755 00b8 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 4756 00bc C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 4757 00c0 1A60     		str	r2, [r3]
 4758 00c2 BB68     		ldr	r3, [r7, #8]
 4759 00c4 DA6A     		ldr	r2, [r3, #44]
 4760 00c6 1346     		mov	r3, r2
 4761 00c8 9B00     		lsls	r3, r3, #2
 4762 00ca 1344     		add	r3, r3, r2
 4763 00cc 9B00     		lsls	r3, r3, #2
 4764 00ce 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 4765 00d2 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 4766 00d6 1A44     		add	r2, r2, r3
 4767 00d8 BB68     		ldr	r3, [r7, #8]
 4768 00da 0433     		adds	r3, r3, #4
 4769 00dc 1046     		mov	r0, r2
 4770 00de 1946     		mov	r1, r3
 4771 00e0 FFF7FEFF 		bl	vListInsertEnd
3278:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3279:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					/* Return true to indicate that a context switch is required.
3280:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					This is only actually required in the corner case whereby
3281:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					multiple mutexes were held and the mutexes were given back
3282:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					in an order different to that in which they were taken. */
3283:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
 4772              		.loc 1 3283 0 discriminator 1
 4773 00e4 0123     		movs	r3, #1
 4774 00e6 FB60     		str	r3, [r7, #12]
 4775              	.L265:
3284:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
3285:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				else
3286:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
3287:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3288:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
3289:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
3290:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			else
3291:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
3292:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3293:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
3294:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
3295:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
3296:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
3297:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3298:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
3299:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3300:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		return xReturn;
 4776              		.loc 1 3300 0
 4777 00e8 FB68     		ldr	r3, [r7, #12]
3301:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
 4778              		.loc 1 3301 0
 4779 00ea 1846     		mov	r0, r3
 4780 00ec 1037     		adds	r7, r7, #16
 4781 00ee BD46     		mov	sp, r7
 4782              		@ sp needed
 4783 00f0 80BD     		pop	{r7, pc}
 4784              		.cfi_endproc
 4785              	.LFE44:
 4787 00f2 00BF     		.section	.text.uxTaskResetEventItemValue,"ax",%progbits
 4788              		.align	2
 4789              		.global	uxTaskResetEventItemValue
 4790              		.thumb
 4791              		.thumb_func
 4793              	uxTaskResetEventItemValue:
 4794              	.LFB45:
3302:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3303:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
3304:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3305:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3306:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3307:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3308:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	void vTaskEnterCritical( void )
3309:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
3310:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
3311:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3312:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
3313:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
3314:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			( pxCurrentTCB->uxCriticalNesting )++;
3315:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3316:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* This is not the interrupt safe version of the enter critical
3317:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			function so	assert() if it is being called from an interrupt
3318:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			context.  Only API functions that end in "FromISR" can be used in an
3319:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			interrupt.  Only assert if the critical nesting count is 1 to
3320:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			protect against recursive calls if the assert function also uses a
3321:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			critical section. */
3322:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting == 1 )
3323:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
3324:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				portASSERT_IF_IN_ISR();
3325:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
3326:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3327:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
3328:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
3329:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
3330:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3331:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
3332:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
3333:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3334:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
3335:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3336:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3337:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3338:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3339:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	void vTaskExitCritical( void )
3340:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
3341:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
3342:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
3343:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting > 0U )
3344:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
3345:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				( pxCurrentTCB->uxCriticalNesting )--;
3346:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3347:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				if( pxCurrentTCB->uxCriticalNesting == 0U )
3348:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
3349:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					portENABLE_INTERRUPTS();
3350:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
3351:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				else
3352:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
3353:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3354:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
3355:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
3356:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			else
3357:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
3358:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3359:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
3360:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
3361:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
3362:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
3363:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3364:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
3365:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
3366:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3367:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
3368:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3369:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3370:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) )
3371:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3372:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	void vTaskList( char * pcWriteBuffer )
3373:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
3374:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
3375:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	volatile UBaseType_t uxArraySize, x;
3376:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	char cStatus;
3377:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3378:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/*
3379:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * PLEASE NOTE:
3380:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 *
3381:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * This function is provided for convenience only, and is used by many
3382:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
3383:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * scheduler.
3384:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 *
3385:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
3386:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * uxTaskGetSystemState() output into a human readable table that
3387:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * displays task names, states and stack usage.
3388:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 *
3389:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * vTaskList() has a dependency on the sprintf() C library function that
3390:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * might bloat the code size, use a lot of stack, and provide different
3391:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * results on different platforms.  An alternative, tiny, third party,
3392:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * and limited functionality implementation of sprintf() is provided in
3393:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * many of the FreeRTOS/Demo sub-directories in a file called
3394:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
3395:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * snprintf() implementation!).
3396:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 *
3397:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
3398:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
3399:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * through a call to vTaskList().
3400:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 */
3401:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3402:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3403:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
3404:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		*pcWriteBuffer = 0x00;
3405:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3406:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
3407:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		function is executing. */
3408:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
3409:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3410:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Allocate an array index for each task. */
3411:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
3412:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3413:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( pxTaskStatusArray != NULL )
3414:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
3415:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Generate the (binary) data. */
3416:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
3417:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3418:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Create a human readable table from the binary data. */
3419:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			for( x = 0; x < uxArraySize; x++ )
3420:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
3421:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				switch( pxTaskStatusArray[ x ].eCurrentState )
3422:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
3423:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				case eReady:		cStatus = tskREADY_CHAR;
3424:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 									break;
3425:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3426:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				case eBlocked:		cStatus = tskBLOCKED_CHAR;
3427:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 									break;
3428:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3429:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				case eSuspended:	cStatus = tskSUSPENDED_CHAR;
3430:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 									break;
3431:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3432:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				case eDeleted:		cStatus = tskDELETED_CHAR;
3433:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 									break;
3434:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3435:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				default:			/* Should not get here, but it is included
3436:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 									to prevent static checking errors. */
3437:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 									cStatus = 0x00;
3438:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 									break;
3439:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
3440:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3441:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				sprintf( pcWriteBuffer, "%s\t\t%c\t%u\t%u\t%u\r\n", pxTaskStatusArray[ x ].pcTaskName, cStatus,
3442:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				pcWriteBuffer += strlen( pcWriteBuffer );
3443:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
3444:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3445:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Free the array again. */
3446:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			vPortFree( pxTaskStatusArray );
3447:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
3448:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
3449:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
3450:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3451:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
3452:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
3453:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3454:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) ) */
3455:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
3456:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3457:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) )
3458:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3459:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	void vTaskGetRunTimeStats( char *pcWriteBuffer )
3460:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
3461:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
3462:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	volatile UBaseType_t uxArraySize, x;
3463:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	uint32_t ulTotalTime, ulStatsAsPercentage;
3464:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3465:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#if( configUSE_TRACE_FACILITY != 1 )
3466:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
3467:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTime
3468:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
3469:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		#endif
3470:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3471:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/*
3472:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * PLEASE NOTE:
3473:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 *
3474:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * This function is provided for convenience only, and is used by many
3475:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
3476:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * scheduler.
3477:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 *
3478:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
3479:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * of the uxTaskGetSystemState() output into a human readable table that
3480:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * displays the amount of time each task has spent in the Running state
3481:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * in both absolute and percentage terms.
3482:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 *
3483:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
3484:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * function that might bloat the code size, use a lot of stack, and
3485:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * provide different results on different platforms.  An alternative,
3486:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * tiny, third party, and limited functionality implementation of
3487:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
3488:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
3489:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * a full snprintf() implementation!).
3490:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 *
3491:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
3492:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
3493:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 * through a call to vTaskGetRunTimeStats().
3494:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		 */
3495:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3496:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
3497:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		*pcWriteBuffer = 0x00;
3498:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3499:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
3500:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		function is executing. */
3501:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
3502:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3503:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* Allocate an array index for each task. */
3504:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
3505:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3506:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( pxTaskStatusArray != NULL )
3507:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
3508:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Generate the (binary) data. */
3509:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
3510:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3511:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* For percentage calculations. */
3512:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			ulTotalTime /= 100UL;
3513:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3514:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Avoid divide by zero errors. */
3515:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			if( ulTotalTime > 0 )
3516:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
3517:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				/* Create a human readable table from the binary data. */
3518:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				for( x = 0; x < uxArraySize; x++ )
3519:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				{
3520:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					/* What percentage of the total run time has the task used?
3521:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					This will always be rounded down to the nearest integer.
3522:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					ulTotalRunTimeDiv100 has already been divided by 100. */
3523:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
3524:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3525:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
3526:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					{
3527:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
3528:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						{
3529:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "%s\t\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskS
3530:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						}
3531:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						#else
3532:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						{
3533:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
3534:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
3535:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "%s\t\t%u\t\t%u%%\r\n", pxTaskStatusArray[ x ].pcTaskName, ( unsigne
3536:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						}
3537:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						#endif
3538:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					}
3539:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					else
3540:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					{
3541:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						/* If the percentage is zero here then the task has
3542:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						consumed less than 1% of the total run time. */
3543:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
3544:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						{
3545:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "%s\t\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskSt
3546:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						}
3547:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						#else
3548:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						{
3549:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
3550:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
3551:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "%s\t\t%u\t\t<1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, ( unsigne
3552:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						}
3553:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 						#endif
3554:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					}
3555:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3556:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 					pcWriteBuffer += strlen( pcWriteBuffer );
3557:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				}
3558:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
3559:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			else
3560:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			{
3561:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3562:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			}
3563:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3564:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			/* Free the array again. */
3565:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			vPortFree( pxTaskStatusArray );
3566:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
3567:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		else
3568:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
3569:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3570:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
3571:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
3572:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3573:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
3574:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3575:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3576:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** TickType_t uxTaskResetEventItemValue( void )
3577:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** {
 4795              		.loc 1 3577 0
 4796              		.cfi_startproc
 4797              		@ args = 0, pretend = 0, frame = 8
 4798              		@ frame_needed = 1, uses_anonymous_args = 0
 4799              		@ link register save eliminated.
 4800 0000 80B4     		push	{r7}
 4801              	.LCFI128:
 4802              		.cfi_def_cfa_offset 4
 4803              		.cfi_offset 7, -4
 4804 0002 83B0     		sub	sp, sp, #12
 4805              	.LCFI129:
 4806              		.cfi_def_cfa_offset 16
 4807 0004 00AF     		add	r7, sp, #0
 4808              	.LCFI130:
 4809              		.cfi_def_cfa_register 7
3578:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** TickType_t uxReturn;
3579:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3580:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 4810              		.loc 1 3580 0
 4811 0006 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 4812 000a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 4813 000e 1B68     		ldr	r3, [r3]
 4814 0010 9B69     		ldr	r3, [r3, #24]
 4815 0012 7B60     		str	r3, [r7, #4]
3581:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3582:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	/* Reset the event list item to its normal value - so it can be used with
3583:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	queues and semaphores. */
3584:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES 
 4816              		.loc 1 3584 0
 4817 0014 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 4818 0018 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 4819 001c 1A68     		ldr	r2, [r3]
 4820 001e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 4821 0022 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 4822 0026 1B68     		ldr	r3, [r3]
 4823 0028 DB6A     		ldr	r3, [r3, #44]
 4824 002a C3F10503 		rsb	r3, r3, #5
 4825 002e 9361     		str	r3, [r2, #24]
3585:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3586:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	return uxReturn;
 4826              		.loc 1 3586 0
 4827 0030 7B68     		ldr	r3, [r7, #4]
3587:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** }
 4828              		.loc 1 3587 0
 4829 0032 1846     		mov	r0, r3
 4830 0034 0C37     		adds	r7, r7, #12
 4831 0036 BD46     		mov	sp, r7
 4832              		@ sp needed
 4833 0038 5DF8047B 		ldr	r7, [sp], #4
 4834 003c 7047     		bx	lr
 4835              		.cfi_endproc
 4836              	.LFE45:
 4838 003e 00BF     		.section	.text.pvTaskIncrementMutexHeldCount,"ax",%progbits
 4839              		.align	2
 4840              		.global	pvTaskIncrementMutexHeldCount
 4841              		.thumb
 4842              		.thumb_func
 4844              	pvTaskIncrementMutexHeldCount:
 4845              	.LFB46:
3588:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3589:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3590:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3591:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3592:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	void *pvTaskIncrementMutexHeldCount( void )
3593:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	{
 4846              		.loc 1 3593 0
 4847              		.cfi_startproc
 4848              		@ args = 0, pretend = 0, frame = 0
 4849              		@ frame_needed = 1, uses_anonymous_args = 0
 4850              		@ link register save eliminated.
 4851 0000 80B4     		push	{r7}
 4852              	.LCFI131:
 4853              		.cfi_def_cfa_offset 4
 4854              		.cfi_offset 7, -4
 4855 0002 00AF     		add	r7, sp, #0
 4856              	.LCFI132:
 4857              		.cfi_def_cfa_register 7
3594:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		/* If xSemaphoreCreateMutex() is called before any tasks have been created
3595:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		then pxCurrentTCB will be NULL. */
3596:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB != NULL )
 4858              		.loc 1 3596 0
 4859 0004 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 4860 0008 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 4861 000c 1B68     		ldr	r3, [r3]
 4862 000e 002B     		cmp	r3, #0
 4863 0010 07D0     		beq	.L274
3597:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		{
3598:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 			( pxCurrentTCB->uxMutexesHeld )++;
 4864              		.loc 1 3598 0
 4865 0012 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 4866 0016 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 4867 001a 1B68     		ldr	r3, [r3]
 4868 001c DA6C     		ldr	r2, [r3, #76]
 4869 001e 0132     		adds	r2, r2, #1
 4870 0020 DA64     		str	r2, [r3, #76]
 4871              	.L274:
3599:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		}
3600:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 
3601:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 		return pxCurrentTCB;
 4872              		.loc 1 3601 0
 4873 0022 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 4874 0026 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 4875 002a 1B68     		ldr	r3, [r3]
3602:lib/FreeRTOSV8.1.2/FreeRTOS/Source/tasks.c **** 	}
 4876              		.loc 1 3602 0
 4877 002c 1846     		mov	r0, r3
 4878 002e BD46     		mov	sp, r7
 4879              		@ sp needed
 4880 0030 5DF8047B 		ldr	r7, [sp], #4
 4881 0034 7047     		bx	lr
 4882              		.cfi_endproc
 4883              	.LFE46:
 4885 0036 00BF     		.section	.rodata.ucExpectedStackBytes.5311,"a",%progbits
 4886              		.align	2
 4889              	ucExpectedStackBytes.5311:
 4890 0000 A5       		.byte	-91
 4891 0001 A5       		.byte	-91
 4892 0002 A5       		.byte	-91
 4893 0003 A5       		.byte	-91
 4894 0004 A5       		.byte	-91
 4895 0005 A5       		.byte	-91
 4896 0006 A5       		.byte	-91
 4897 0007 A5       		.byte	-91
 4898 0008 A5       		.byte	-91
 4899 0009 A5       		.byte	-91
 4900 000a A5       		.byte	-91
 4901 000b A5       		.byte	-91
 4902 000c A5       		.byte	-91
 4903 000d A5       		.byte	-91
 4904 000e A5       		.byte	-91
 4905 000f A5       		.byte	-91
 4906 0010 A5       		.byte	-91
 4907 0011 A5       		.byte	-91
 4908 0012 A5       		.byte	-91
 4909 0013 A5       		.byte	-91
 4910              		.text
 4911              	.Letext0:
 4912              		.file 3 "/usr/lib/gcc/arm-none-eabi/4.8.2/include/stddef.h"
 4913              		.file 4 "/usr/include/newlib/machine/_default_types.h"
 4914              		.file 5 "/usr/include/newlib/stdint.h"
 4915              		.file 6 "lib/FreeRTOSV8.1.2/FreeRTOS/Source/include/projdefs.h"
 4916              		.file 7 "lib/FreeRTOSV8.1.2/FreeRTOS/Source/include/list.h"
 4917              		.file 8 "lib/FreeRTOSV8.1.2/FreeRTOS/Source/include/task.h"
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
     /tmp/ccGDghef.s:24     .bss.pxCurrentTCB:00000000 pxCurrentTCB
     /tmp/ccGDghef.s:21     .bss.pxCurrentTCB:00000000 $d
     /tmp/ccGDghef.s:27     .bss.pxReadyTasksLists:00000000 $d
     /tmp/ccGDghef.s:30     .bss.pxReadyTasksLists:00000000 pxReadyTasksLists
     /tmp/ccGDghef.s:33     .bss.xDelayedTaskList1:00000000 $d
     /tmp/ccGDghef.s:36     .bss.xDelayedTaskList1:00000000 xDelayedTaskList1
     /tmp/ccGDghef.s:39     .bss.xDelayedTaskList2:00000000 $d
     /tmp/ccGDghef.s:42     .bss.xDelayedTaskList2:00000000 xDelayedTaskList2
     /tmp/ccGDghef.s:45     .bss.pxDelayedTaskList:00000000 $d
     /tmp/ccGDghef.s:48     .bss.pxDelayedTaskList:00000000 pxDelayedTaskList
     /tmp/ccGDghef.s:51     .bss.pxOverflowDelayedTaskList:00000000 $d
     /tmp/ccGDghef.s:54     .bss.pxOverflowDelayedTaskList:00000000 pxOverflowDelayedTaskList
     /tmp/ccGDghef.s:57     .bss.xPendingReadyList:00000000 $d
     /tmp/ccGDghef.s:60     .bss.xPendingReadyList:00000000 xPendingReadyList
     /tmp/ccGDghef.s:63     .bss.xTasksWaitingTermination:00000000 $d
     /tmp/ccGDghef.s:66     .bss.xTasksWaitingTermination:00000000 xTasksWaitingTermination
     /tmp/ccGDghef.s:69     .bss.uxTasksDeleted:00000000 $d
     /tmp/ccGDghef.s:72     .bss.uxTasksDeleted:00000000 uxTasksDeleted
     /tmp/ccGDghef.s:75     .bss.xSuspendedTaskList:00000000 $d
     /tmp/ccGDghef.s:78     .bss.xSuspendedTaskList:00000000 xSuspendedTaskList
     /tmp/ccGDghef.s:81     .bss.uxCurrentNumberOfTasks:00000000 $d
     /tmp/ccGDghef.s:84     .bss.uxCurrentNumberOfTasks:00000000 uxCurrentNumberOfTasks
     /tmp/ccGDghef.s:87     .bss.xTickCount:00000000 $d
     /tmp/ccGDghef.s:90     .bss.xTickCount:00000000 xTickCount
     /tmp/ccGDghef.s:93     .bss.uxTopReadyPriority:00000000 $d
     /tmp/ccGDghef.s:96     .bss.uxTopReadyPriority:00000000 uxTopReadyPriority
     /tmp/ccGDghef.s:99     .bss.xSchedulerRunning:00000000 $d
     /tmp/ccGDghef.s:102    .bss.xSchedulerRunning:00000000 xSchedulerRunning
     /tmp/ccGDghef.s:105    .bss.uxPendedTicks:00000000 $d
     /tmp/ccGDghef.s:108    .bss.uxPendedTicks:00000000 uxPendedTicks
     /tmp/ccGDghef.s:111    .bss.xYieldPending:00000000 $d
     /tmp/ccGDghef.s:114    .bss.xYieldPending:00000000 xYieldPending
     /tmp/ccGDghef.s:117    .bss.xNumOfOverflows:00000000 $d
     /tmp/ccGDghef.s:120    .bss.xNumOfOverflows:00000000 xNumOfOverflows
     /tmp/ccGDghef.s:123    .bss.uxTaskNumber:00000000 $d
     /tmp/ccGDghef.s:126    .bss.uxTaskNumber:00000000 uxTaskNumber
     /tmp/ccGDghef.s:129    .data.xNextTaskUnblockTime:00000000 $d
     /tmp/ccGDghef.s:132    .data.xNextTaskUnblockTime:00000000 xNextTaskUnblockTime
     /tmp/ccGDghef.s:135    .bss.uxSchedulerSuspended:00000000 $d
     /tmp/ccGDghef.s:138    .bss.uxSchedulerSuspended:00000000 uxSchedulerSuspended
     /tmp/ccGDghef.s:141    .text.xTaskGenericCreate:00000000 $t
     /tmp/ccGDghef.s:146    .text.xTaskGenericCreate:00000000 xTaskGenericCreate
     /tmp/ccGDghef.s:3931   .text.prvAllocateTCBAndStack:00000000 prvAllocateTCBAndStack
     /tmp/ccGDghef.s:3551   .text.prvInitialiseTCBVariables:00000000 prvInitialiseTCBVariables
     /tmp/ccGDghef.s:3667   .text.prvInitialiseTaskLists:00000000 prvInitialiseTaskLists
     /tmp/ccGDghef.s:382    .text.vTaskDelete:00000000 $t
     /tmp/ccGDghef.s:387    .text.vTaskDelete:00000000 vTaskDelete
     /tmp/ccGDghef.s:4309   .text.prvResetNextTaskUnblockTime:00000000 prvResetNextTaskUnblockTime
     /tmp/ccGDghef.s:537    .text.vTaskDelayUntil:00000000 $t
     /tmp/ccGDghef.s:542    .text.vTaskDelayUntil:00000000 vTaskDelayUntil
     /tmp/ccGDghef.s:1704   .text.vTaskSuspendAll:00000000 vTaskSuspendAll
     /tmp/ccGDghef.s:3850   .text.prvAddCurrentTaskToDelayedList:00000000 prvAddCurrentTaskToDelayedList
     /tmp/ccGDghef.s:1740   .text.xTaskResumeAll:00000000 xTaskResumeAll
     /tmp/ccGDghef.s:703    .text.vTaskDelay:00000000 $t
     /tmp/ccGDghef.s:708    .text.vTaskDelay:00000000 vTaskDelay
     /tmp/ccGDghef.s:802    .text.uxTaskPriorityGet:00000000 $t
     /tmp/ccGDghef.s:807    .text.uxTaskPriorityGet:00000000 uxTaskPriorityGet
     /tmp/ccGDghef.s:860    .text.vTaskPrioritySet:00000000 $t
     /tmp/ccGDghef.s:865    .text.vTaskPrioritySet:00000000 vTaskPrioritySet
     /tmp/ccGDghef.s:1086   .text.vTaskSuspend:00000000 $t
     /tmp/ccGDghef.s:1091   .text.vTaskSuspend:00000000 vTaskSuspend
     /tmp/ccGDghef.s:2466   .text.vTaskSwitchContext:00000000 vTaskSwitchContext
     /tmp/ccGDghef.s:1251   .text.prvTaskIsTaskSuspended:00000000 $t
     /tmp/ccGDghef.s:1255   .text.prvTaskIsTaskSuspended:00000000 prvTaskIsTaskSuspended
     /tmp/ccGDghef.s:1343   .text.vTaskResume:00000000 $t
     /tmp/ccGDghef.s:1348   .text.vTaskResume:00000000 vTaskResume
     /tmp/ccGDghef.s:1452   .text.xTaskResumeFromISR:00000000 $t
     /tmp/ccGDghef.s:1457   .text.xTaskResumeFromISR:00000000 xTaskResumeFromISR
     /tmp/ccGDghef.s:1576   .rodata:00000000 $d
     /tmp/ccGDghef.s:1577   .rodata:00000000 .LC0
     /tmp/ccGDghef.s:1580   .text.vTaskStartScheduler:00000000 $t
     /tmp/ccGDghef.s:1585   .text.vTaskStartScheduler:00000000 vTaskStartScheduler
     /tmp/ccGDghef.s:3507   .text.prvIdleTask:00000000 prvIdleTask
     /tmp/ccGDghef.s:1665   .text.vTaskEndScheduler:00000000 $t
     /tmp/ccGDghef.s:1670   .text.vTaskEndScheduler:00000000 vTaskEndScheduler
     /tmp/ccGDghef.s:1699   .text.vTaskSuspendAll:00000000 $t
     /tmp/ccGDghef.s:1735   .text.xTaskResumeAll:00000000 $t
     /tmp/ccGDghef.s:2201   .text.xTaskIncrementTick:00000000 xTaskIncrementTick
     /tmp/ccGDghef.s:1921   .text.xTaskGetTickCount:00000000 $t
     /tmp/ccGDghef.s:1926   .text.xTaskGetTickCount:00000000 xTaskGetTickCount
     /tmp/ccGDghef.s:1964   .text.xTaskGetTickCountFromISR:00000000 $t
     /tmp/ccGDghef.s:1969   .text.xTaskGetTickCountFromISR:00000000 xTaskGetTickCountFromISR
     /tmp/ccGDghef.s:2011   .text.uxTaskGetNumberOfTasks:00000000 $t
     /tmp/ccGDghef.s:2016   .text.uxTaskGetNumberOfTasks:00000000 uxTaskGetNumberOfTasks
     /tmp/ccGDghef.s:2044   .text.uxTaskGetSystemState:00000000 $t
     /tmp/ccGDghef.s:2049   .text.uxTaskGetSystemState:00000000 uxTaskGetSystemState
     /tmp/ccGDghef.s:4016   .text.prvListTaskWithinSingleList:00000000 prvListTaskWithinSingleList
     /tmp/ccGDghef.s:2196   .text.xTaskIncrementTick:00000000 $t
     /tmp/ccGDghef.s:2461   .text.vTaskSwitchContext:00000000 $t
     /tmp/ccGDghef.s:4889   .rodata.ucExpectedStackBytes.5311:00000000 ucExpectedStackBytes.5311
     /tmp/ccGDghef.s:2638   .text.vTaskPlaceOnEventList:00000000 $t
     /tmp/ccGDghef.s:2643   .text.vTaskPlaceOnEventList:00000000 vTaskPlaceOnEventList
     /tmp/ccGDghef.s:2740   .text.vTaskPlaceOnUnorderedEventList:00000000 $t
     /tmp/ccGDghef.s:2745   .text.vTaskPlaceOnUnorderedEventList:00000000 vTaskPlaceOnUnorderedEventList
     /tmp/ccGDghef.s:2861   .text.vTaskPlaceOnEventListRestricted:00000000 $t
     /tmp/ccGDghef.s:2866   .text.vTaskPlaceOnEventListRestricted:00000000 vTaskPlaceOnEventListRestricted
     /tmp/ccGDghef.s:2947   .text.xTaskRemoveFromEventList:00000000 $t
     /tmp/ccGDghef.s:2952   .text.xTaskRemoveFromEventList:00000000 xTaskRemoveFromEventList
     /tmp/ccGDghef.s:3071   .text.xTaskRemoveFromUnorderedEventList:00000000 $t
     /tmp/ccGDghef.s:3076   .text.xTaskRemoveFromUnorderedEventList:00000000 xTaskRemoveFromUnorderedEventList
     /tmp/ccGDghef.s:3193   .text.vTaskSetTimeOutState:00000000 $t
     /tmp/ccGDghef.s:3198   .text.vTaskSetTimeOutState:00000000 vTaskSetTimeOutState
     /tmp/ccGDghef.s:3246   .text.xTaskCheckForTimeOut:00000000 $t
     /tmp/ccGDghef.s:3251   .text.xTaskCheckForTimeOut:00000000 xTaskCheckForTimeOut
     /tmp/ccGDghef.s:3371   .text.vTaskMissedYield:00000000 $t
     /tmp/ccGDghef.s:3376   .text.vTaskMissedYield:00000000 vTaskMissedYield
     /tmp/ccGDghef.s:3404   .text.uxTaskGetTaskNumber:00000000 $t
     /tmp/ccGDghef.s:3409   .text.uxTaskGetTaskNumber:00000000 uxTaskGetTaskNumber
     /tmp/ccGDghef.s:3457   .text.vTaskSetTaskNumber:00000000 $t
     /tmp/ccGDghef.s:3462   .text.vTaskSetTaskNumber:00000000 vTaskSetTaskNumber
     /tmp/ccGDghef.s:3503   .text.prvIdleTask:00000000 $t
     /tmp/ccGDghef.s:3754   .text.prvCheckTasksWaitingTermination:00000000 prvCheckTasksWaitingTermination
     /tmp/ccGDghef.s:3547   .text.prvInitialiseTCBVariables:00000000 $t
     /tmp/ccGDghef.s:3663   .text.prvInitialiseTaskLists:00000000 $t
     /tmp/ccGDghef.s:3750   .text.prvCheckTasksWaitingTermination:00000000 $t
     /tmp/ccGDghef.s:4270   .text.prvDeleteTCB:00000000 prvDeleteTCB
     /tmp/ccGDghef.s:3846   .text.prvAddCurrentTaskToDelayedList:00000000 $t
     /tmp/ccGDghef.s:3927   .text.prvAllocateTCBAndStack:00000000 $t
     /tmp/ccGDghef.s:4012   .text.prvListTaskWithinSingleList:00000000 $t
     /tmp/ccGDghef.s:4210   .text.prvTaskCheckFreeStackSpace:00000000 prvTaskCheckFreeStackSpace
     /tmp/ccGDghef.s:4206   .text.prvTaskCheckFreeStackSpace:00000000 $t
     /tmp/ccGDghef.s:4266   .text.prvDeleteTCB:00000000 $t
     /tmp/ccGDghef.s:4305   .text.prvResetNextTaskUnblockTime:00000000 $t
     /tmp/ccGDghef.s:4374   .text.xTaskGetCurrentTaskHandle:00000000 $t
     /tmp/ccGDghef.s:4379   .text.xTaskGetCurrentTaskHandle:00000000 xTaskGetCurrentTaskHandle
     /tmp/ccGDghef.s:4414   .text.xTaskGetSchedulerState:00000000 $t
     /tmp/ccGDghef.s:4419   .text.xTaskGetSchedulerState:00000000 xTaskGetSchedulerState
     /tmp/ccGDghef.s:4475   .text.vTaskPriorityInherit:00000000 $t
     /tmp/ccGDghef.s:4480   .text.vTaskPriorityInherit:00000000 vTaskPriorityInherit
     /tmp/ccGDghef.s:4639   .text.xTaskPriorityDisinherit:00000000 $t
     /tmp/ccGDghef.s:4644   .text.xTaskPriorityDisinherit:00000000 xTaskPriorityDisinherit
     /tmp/ccGDghef.s:4788   .text.uxTaskResetEventItemValue:00000000 $t
     /tmp/ccGDghef.s:4793   .text.uxTaskResetEventItemValue:00000000 uxTaskResetEventItemValue
     /tmp/ccGDghef.s:4839   .text.pvTaskIncrementMutexHeldCount:00000000 $t
     /tmp/ccGDghef.s:4844   .text.pvTaskIncrementMutexHeldCount:00000000 pvTaskIncrementMutexHeldCount
     /tmp/ccGDghef.s:4886   .rodata.ucExpectedStackBytes.5311:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
ulPortSetInterruptMask
pxPortInitialiseStack
vPortEnterCritical
vListInsertEnd
vPortExitCritical
vPortYield
uxListRemove
vPortValidateInterruptPriority
vPortClearInterruptMask
xTimerCreateTimerTask
xPortStartScheduler
vPortEndScheduler
vApplicationTickHook
vApplicationStackOverflowHook
memcmp
vListInsert
vApplicationIdleHook
vListInitialiseItem
vListInitialise
pvPortMalloc
vPortFree
memset
