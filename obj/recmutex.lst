   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"recmutex.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.bss.xMutex,"aw",%nobits
  20              		.align	2
  23              	xMutex:
  24 0000 00000000 		.space	4
  25              		.section	.bss.xErrorOccurred,"aw",%nobits
  26              		.align	2
  29              	xErrorOccurred:
  30 0000 00000000 		.space	4
  31              		.section	.bss.xControllingIsSuspended,"aw",%nobits
  32              		.align	2
  35              	xControllingIsSuspended:
  36 0000 00000000 		.space	4
  37              		.section	.bss.xBlockingIsSuspended,"aw",%nobits
  38              		.align	2
  41              	xBlockingIsSuspended:
  42 0000 00000000 		.space	4
  43              		.section	.bss.uxControllingCycles,"aw",%nobits
  44              		.align	2
  47              	uxControllingCycles:
  48 0000 00000000 		.space	4
  49              		.section	.bss.uxBlockingCycles,"aw",%nobits
  50              		.align	2
  53              	uxBlockingCycles:
  54 0000 00000000 		.space	4
  55              		.section	.bss.uxPollingCycles,"aw",%nobits
  56              		.align	2
  59              	uxPollingCycles:
  60 0000 00000000 		.space	4
  61              		.section	.bss.xControllingTaskHandle,"aw",%nobits
  62              		.align	2
  65              	xControllingTaskHandle:
  66 0000 00000000 		.space	4
  67              		.section	.bss.xBlockingTaskHandle,"aw",%nobits
  68              		.align	2
  71              	xBlockingTaskHandle:
  72 0000 00000000 		.space	4
  73              		.section	.rodata
  74              		.align	2
  75              	.LC0:
  76 0000 52656375 		.ascii	"Recursive_Mutex\000"
  76      72736976 
  76      655F4D75 
  76      74657800 
  77              		.align	2
  78              	.LC1:
  79 0010 52656331 		.ascii	"Rec1\000"
  79      00
  80 0015 000000   		.align	2
  81              	.LC2:
  82 0018 52656332 		.ascii	"Rec2\000"
  82      00
  83 001d 000000   		.align	2
  84              	.LC3:
  85 0020 52656333 		.ascii	"Rec3\000"
  85      00
  86 0025 000000   		.section	.text.vStartRecursiveMutexTasks,"ax",%progbits
  87              		.align	2
  88              		.global	vStartRecursiveMutexTasks
  89              		.thumb
  90              		.thumb_func
  92              	vStartRecursiveMutexTasks:
  93              	.LFB1:
  94              		.file 1 "lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c"
   1:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** /*
   2:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****     FreeRTOS V8.1.2 - Copyright (C) 2014 Real Time Engineers Ltd.
   3:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****     All rights reserved
   4:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
   5:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
   7:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****     ***************************************************************************
   8:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****      *                                                                       *
   9:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  10:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****      *    robust, strictly quality controlled, supported, and cross          *
  11:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****      *    platform software that has become a de facto standard.             *
  12:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****      *                                                                       *
  13:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  14:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  15:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  16:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****      *                                                                       *
  17:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****      *    Thank you!                                                         *
  18:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****      *                                                                       *
  19:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****     ***************************************************************************
  20:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
  21:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****     This file is part of the FreeRTOS distribution.
  22:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
  23:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  24:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****     the terms of the GNU General Public License (version 2) as published by the
  25:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  26:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
  27:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****     >>!   NOTE: The modification to the GPL is included to allow you to     !<<
  28:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****     >>!   distribute a combined work that includes FreeRTOS without being   !<<
  29:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****     >>!   obliged to provide the source code for proprietary components     !<<
  30:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****     >>!   outside of the FreeRTOS kernel.                                   !<<
  31:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
  32:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  33:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  34:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  35:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****     link: http://www.freertos.org/a00114.html
  36:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
  37:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****     1 tab == 4 spaces!
  38:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
  39:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****     ***************************************************************************
  40:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****      *                                                                       *
  41:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  42:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****      *    not run, what could be wrong?"                                     *
  43:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****      *                                                                       *
  44:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  45:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****      *                                                                       *
  46:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****     ***************************************************************************
  47:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
  48:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  49:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****     license and Real Time Engineers Ltd. contact details.
  50:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
  51:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  52:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  53:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  54:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
  55:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  56:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  57:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****     licenses offer ticketed support, indemnification and middleware.
  58:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
  59:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  60:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****     engineered and independently SIL3 certified version for use in safety and
  61:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****     mission critical applications that require provable dependability.
  62:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
  63:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****     1 tab == 4 spaces!
  64:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** */
  65:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
  66:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** /*
  67:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	The tasks defined on this page demonstrate the use of recursive mutexes.
  68:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
  69:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	For recursive mutex functionality the created mutex should be created using
  70:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	xSemaphoreCreateRecursiveMutex(), then be manipulated
  71:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	using the xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() API
  72:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	functions.
  73:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
  74:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	This demo creates three tasks all of which access the same recursive mutex:
  75:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
  76:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	prvRecursiveMutexControllingTask() has the highest priority so executes
  77:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	first and grabs the mutex.  It then performs some recursive accesses -
  78:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	between each of which it sleeps for a short period to let the lower
  79:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	priority tasks execute.  When it has completed its demo functionality
  80:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	it gives the mutex back before suspending itself.
  81:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
  82:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	prvRecursiveMutexBlockingTask() attempts to access the mutex by performing
  83:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	a blocking 'take'.  The blocking task has a lower priority than the
  84:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	controlling	task so by the time it executes the mutex has already been
  85:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	taken by the controlling task,  causing the blocking task to block.  It
  86:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	does not unblock until the controlling task has given the mutex back,
  87:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	and it does not actually run until the controlling task has suspended
  88:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	itself (due to the relative priorities).  When it eventually does obtain
  89:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	the mutex all it does is give the mutex back prior to also suspending
  90:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	itself.  At this point both the controlling task and the blocking task are
  91:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	suspended.
  92:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
  93:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	prvRecursiveMutexPollingTask() runs at the idle priority.  It spins round
  94:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	a tight loop attempting to obtain the mutex with a non-blocking call.  As
  95:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	the lowest priority task it will not successfully obtain the mutex until
  96:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	both the controlling and blocking tasks are suspended.  Once it eventually
  97:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	does obtain the mutex it first unsuspends both the controlling task and
  98:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	blocking task prior to giving the mutex back - resulting in the polling
  99:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	task temporarily inheriting the controlling tasks priority.
 100:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** */
 101:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 102:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** /* Scheduler include files. */
 103:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** #include "FreeRTOS.h"
 104:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** #include "task.h"
 105:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** #include "semphr.h"
 106:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 107:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** /* Demo app include files. */
 108:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** #include "recmutex.h"
 109:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 110:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** /* Priorities assigned to the three tasks.  recmuCONTROLLING_TASK_PRIORITY can
 111:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** be overridden by a definition in FreeRTOSConfig.h. */
 112:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** #ifndef recmuCONTROLLING_TASK_PRIORITY
 113:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	#define recmuCONTROLLING_TASK_PRIORITY	( tskIDLE_PRIORITY + 2 )
 114:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** #endif
 115:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** #define recmuBLOCKING_TASK_PRIORITY		( tskIDLE_PRIORITY + 1 )
 116:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** #define recmuPOLLING_TASK_PRIORITY		( tskIDLE_PRIORITY + 0 )
 117:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 118:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** /* The recursive call depth. */
 119:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** #define recmuMAX_COUNT					( 10 )
 120:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 121:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** /* Misc. */
 122:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** #define recmuSHORT_DELAY				( 20 / portTICK_PERIOD_MS )
 123:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** #define recmuNO_DELAY					( ( TickType_t ) 0 )
 124:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** #define recmuEIGHT_TICK_DELAY			( ( TickType_t ) 8 )
 125:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 126:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** /* The three tasks as described at the top of this file. */
 127:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** static void prvRecursiveMutexControllingTask( void *pvParameters );
 128:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** static void prvRecursiveMutexBlockingTask( void *pvParameters );
 129:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** static void prvRecursiveMutexPollingTask( void *pvParameters );
 130:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 131:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** /* The mutex used by the demo. */
 132:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** static SemaphoreHandle_t xMutex;
 133:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 134:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** /* Variables used to detect and latch errors. */
 135:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** static volatile BaseType_t xErrorOccurred = pdFALSE, xControllingIsSuspended = pdFALSE, xBlockingIs
 136:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** static volatile UBaseType_t uxControllingCycles = 0, uxBlockingCycles = 0, uxPollingCycles = 0;
 137:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 138:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** /* Handles of the two higher priority tasks, required so they can be resumed
 139:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** (unsuspended). */
 140:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** static TaskHandle_t xControllingTaskHandle, xBlockingTaskHandle;
 141:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 142:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** /*-----------------------------------------------------------*/
 143:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 144:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** void vStartRecursiveMutexTasks( void )
 145:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** {
  95              		.loc 1 145 0
  96              		.cfi_startproc
  97              		@ args = 0, pretend = 0, frame = 0
  98              		@ frame_needed = 1, uses_anonymous_args = 0
  99 0000 80B5     		push	{r7, lr}
 100              	.LCFI0:
 101              		.cfi_def_cfa_offset 8
 102              		.cfi_offset 7, -8
 103              		.cfi_offset 14, -4
 104 0002 84B0     		sub	sp, sp, #16
 105              	.LCFI1:
 106              		.cfi_def_cfa_offset 24
 107 0004 04AF     		add	r7, sp, #16
 108              	.LCFI2:
 109              		.cfi_def_cfa 7, 8
 146:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	/* Just creates the mutex and the three tasks. */
 147:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 148:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	xMutex = xSemaphoreCreateRecursiveMutex();
 110              		.loc 1 148 0
 111 0006 0420     		movs	r0, #4
 112 0008 FFF7FEFF 		bl	xQueueCreateMutex
 113 000c 0246     		mov	r2, r0
 114 000e 40F20003 		movw	r3, #:lower16:xMutex
 115 0012 C0F20003 		movt	r3, #:upper16:xMutex
 116 0016 1A60     		str	r2, [r3]
 149:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 150:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	/* vQueueAddToRegistry() adds the mutex to the registry, if one is
 151:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	in use.  The registry is provided as a means for kernel aware
 152:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	debuggers to locate mutex and has no purpose if a kernel aware debugger
 153:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	is not being used.  The call to vQueueAddToRegistry() will be removed
 154:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is
 155:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	defined to be less than 1. */
 156:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	vQueueAddToRegistry( ( QueueHandle_t ) xMutex, "Recursive_Mutex" );
 117              		.loc 1 156 0
 118 0018 40F20003 		movw	r3, #:lower16:xMutex
 119 001c C0F20003 		movt	r3, #:upper16:xMutex
 120 0020 1B68     		ldr	r3, [r3]
 121 0022 1846     		mov	r0, r3
 122 0024 40F20001 		movw	r1, #:lower16:.LC0
 123 0028 C0F20001 		movt	r1, #:upper16:.LC0
 124 002c FFF7FEFF 		bl	vQueueAddToRegistry
 157:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 158:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 159:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	if( xMutex != NULL )
 125              		.loc 1 159 0
 126 0030 40F20003 		movw	r3, #:lower16:xMutex
 127 0034 C0F20003 		movt	r3, #:upper16:xMutex
 128 0038 1B68     		ldr	r3, [r3]
 129 003a 002B     		cmp	r3, #0
 130 003c 41D0     		beq	.L1
 160:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	{
 161:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		xTaskCreate( prvRecursiveMutexControllingTask, "Rec1", configMINIMAL_STACK_SIZE, NULL, recmuCONTR
 131              		.loc 1 161 0
 132 003e 0223     		movs	r3, #2
 133 0040 0093     		str	r3, [sp]
 134 0042 40F20003 		movw	r3, #:lower16:xControllingTaskHandle
 135 0046 C0F20003 		movt	r3, #:upper16:xControllingTaskHandle
 136 004a 0193     		str	r3, [sp, #4]
 137 004c 0023     		movs	r3, #0
 138 004e 0293     		str	r3, [sp, #8]
 139 0050 0023     		movs	r3, #0
 140 0052 0393     		str	r3, [sp, #12]
 141 0054 40F20000 		movw	r0, #:lower16:prvRecursiveMutexControllingTask
 142 0058 C0F20000 		movt	r0, #:upper16:prvRecursiveMutexControllingTask
 143 005c 40F20001 		movw	r1, #:lower16:.LC1
 144 0060 C0F20001 		movt	r1, #:upper16:.LC1
 145 0064 8222     		movs	r2, #130
 146 0066 0023     		movs	r3, #0
 147 0068 FFF7FEFF 		bl	xTaskGenericCreate
 162:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****         xTaskCreate( prvRecursiveMutexBlockingTask, "Rec2", configMINIMAL_STACK_SIZE, NULL, recmuBL
 148              		.loc 1 162 0
 149 006c 0123     		movs	r3, #1
 150 006e 0093     		str	r3, [sp]
 151 0070 40F20003 		movw	r3, #:lower16:xBlockingTaskHandle
 152 0074 C0F20003 		movt	r3, #:upper16:xBlockingTaskHandle
 153 0078 0193     		str	r3, [sp, #4]
 154 007a 0023     		movs	r3, #0
 155 007c 0293     		str	r3, [sp, #8]
 156 007e 0023     		movs	r3, #0
 157 0080 0393     		str	r3, [sp, #12]
 158 0082 40F20000 		movw	r0, #:lower16:prvRecursiveMutexBlockingTask
 159 0086 C0F20000 		movt	r0, #:upper16:prvRecursiveMutexBlockingTask
 160 008a 40F20001 		movw	r1, #:lower16:.LC2
 161 008e C0F20001 		movt	r1, #:upper16:.LC2
 162 0092 8222     		movs	r2, #130
 163 0094 0023     		movs	r3, #0
 164 0096 FFF7FEFF 		bl	xTaskGenericCreate
 163:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****         xTaskCreate( prvRecursiveMutexPollingTask, "Rec3", configMINIMAL_STACK_SIZE, NULL, recmuPOL
 165              		.loc 1 163 0
 166 009a 0023     		movs	r3, #0
 167 009c 0093     		str	r3, [sp]
 168 009e 0023     		movs	r3, #0
 169 00a0 0193     		str	r3, [sp, #4]
 170 00a2 0023     		movs	r3, #0
 171 00a4 0293     		str	r3, [sp, #8]
 172 00a6 0023     		movs	r3, #0
 173 00a8 0393     		str	r3, [sp, #12]
 174 00aa 40F20000 		movw	r0, #:lower16:prvRecursiveMutexPollingTask
 175 00ae C0F20000 		movt	r0, #:upper16:prvRecursiveMutexPollingTask
 176 00b2 40F20001 		movw	r1, #:lower16:.LC3
 177 00b6 C0F20001 		movt	r1, #:upper16:.LC3
 178 00ba 8222     		movs	r2, #130
 179 00bc 0023     		movs	r3, #0
 180 00be FFF7FEFF 		bl	xTaskGenericCreate
 181              	.L1:
 164:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	}
 165:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** }
 182              		.loc 1 165 0
 183 00c2 BD46     		mov	sp, r7
 184              		@ sp needed
 185 00c4 80BD     		pop	{r7, pc}
 186              		.cfi_endproc
 187              	.LFE1:
 189 00c6 00BF     		.section	.text.prvRecursiveMutexControllingTask,"ax",%progbits
 190              		.align	2
 191              		.thumb
 192              		.thumb_func
 194              	prvRecursiveMutexControllingTask:
 195              	.LFB2:
 166:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** /*-----------------------------------------------------------*/
 167:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 168:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** static void prvRecursiveMutexControllingTask( void *pvParameters )
 169:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** {
 196              		.loc 1 169 0
 197              		.cfi_startproc
 198              		@ args = 0, pretend = 0, frame = 16
 199              		@ frame_needed = 1, uses_anonymous_args = 0
 200 0000 80B5     		push	{r7, lr}
 201              	.LCFI3:
 202              		.cfi_def_cfa_offset 8
 203              		.cfi_offset 7, -8
 204              		.cfi_offset 14, -4
 205 0002 84B0     		sub	sp, sp, #16
 206              	.LCFI4:
 207              		.cfi_def_cfa_offset 24
 208 0004 00AF     		add	r7, sp, #0
 209              	.LCFI5:
 210              		.cfi_def_cfa_register 7
 211 0006 7860     		str	r0, [r7, #4]
 212              	.L12:
 170:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** UBaseType_t ux;
 171:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 172:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	/* Just to remove compiler warning. */
 173:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	( void ) pvParameters;
 174:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 175:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	for( ;; )
 176:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	{
 177:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		/* Should not be able to 'give' the mutex, as we have not yet 'taken'
 178:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		it.   The first time through, the mutex will not have been used yet,
 179:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		subsequent times through, at this point the mutex will be held by the
 180:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		polling task. */
 181:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		if( xSemaphoreGiveRecursive( xMutex ) == pdPASS )
 213              		.loc 1 181 0
 214 0008 40F20003 		movw	r3, #:lower16:xMutex
 215 000c C0F20003 		movt	r3, #:upper16:xMutex
 216 0010 1B68     		ldr	r3, [r3]
 217 0012 1846     		mov	r0, r3
 218 0014 FFF7FEFF 		bl	xQueueGiveMutexRecursive
 219 0018 0346     		mov	r3, r0
 220 001a 012B     		cmp	r3, #1
 221 001c 05D1     		bne	.L4
 182:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		{
 183:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			xErrorOccurred = pdTRUE;
 222              		.loc 1 183 0
 223 001e 40F20003 		movw	r3, #:lower16:xErrorOccurred
 224 0022 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 225 0026 0122     		movs	r2, #1
 226 0028 1A60     		str	r2, [r3]
 227              	.L4:
 184:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		}
 185:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 186:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		for( ux = 0; ux < recmuMAX_COUNT; ux++ )
 228              		.loc 1 186 0
 229 002a 0023     		movs	r3, #0
 230 002c FB60     		str	r3, [r7, #12]
 231 002e 17E0     		b	.L5
 232              	.L7:
 187:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		{
 188:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			/* We should now be able to take the mutex as many times as
 189:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			we like.
 190:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 191:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			The first time through the mutex will be immediately available, on
 192:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			subsequent times through the mutex will be held by the polling task
 193:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			at this point and this Take will cause the polling task to inherit
 194:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			the priority of this task.  In this case the block time must be
 195:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			long enough to ensure the polling task will execute again before the
 196:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			block time expires.  If the block time does expire then the error
 197:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			flag will be set here. */
 198:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			if( xSemaphoreTakeRecursive( xMutex, recmuEIGHT_TICK_DELAY ) != pdPASS )
 233              		.loc 1 198 0
 234 0030 40F20003 		movw	r3, #:lower16:xMutex
 235 0034 C0F20003 		movt	r3, #:upper16:xMutex
 236 0038 1B68     		ldr	r3, [r3]
 237 003a 1846     		mov	r0, r3
 238 003c 0821     		movs	r1, #8
 239 003e FFF7FEFF 		bl	xQueueTakeMutexRecursive
 240 0042 0346     		mov	r3, r0
 241 0044 012B     		cmp	r3, #1
 242 0046 05D0     		beq	.L6
 199:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			{
 200:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				xErrorOccurred = pdTRUE;
 243              		.loc 1 200 0
 244 0048 40F20003 		movw	r3, #:lower16:xErrorOccurred
 245 004c C0F20003 		movt	r3, #:upper16:xErrorOccurred
 246 0050 0122     		movs	r2, #1
 247 0052 1A60     		str	r2, [r3]
 248              	.L6:
 201:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			}
 202:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 203:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			/* Ensure the other task attempting to access the mutex (and the
 204:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			other demo tasks) are able to execute to ensure they either block
 205:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			(where a block time is specified) or return an error (where no
 206:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			block time is specified) as the mutex is held by this task. */
 207:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			vTaskDelay( recmuSHORT_DELAY );
 249              		.loc 1 207 0
 250 0054 1420     		movs	r0, #20
 251 0056 FFF7FEFF 		bl	vTaskDelay
 186:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		{
 252              		.loc 1 186 0
 253 005a FB68     		ldr	r3, [r7, #12]
 254 005c 0133     		adds	r3, r3, #1
 255 005e FB60     		str	r3, [r7, #12]
 256              	.L5:
 186:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		{
 257              		.loc 1 186 0 is_stmt 0 discriminator 1
 258 0060 FB68     		ldr	r3, [r7, #12]
 259 0062 092B     		cmp	r3, #9
 260 0064 E4D9     		bls	.L7
 208:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		}
 209:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 210:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		/* For each time we took the mutex, give it back. */
 211:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		for( ux = 0; ux < recmuMAX_COUNT; ux++ )
 261              		.loc 1 211 0 is_stmt 1
 262 0066 0023     		movs	r3, #0
 263 0068 FB60     		str	r3, [r7, #12]
 264 006a 16E0     		b	.L8
 265              	.L10:
 212:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		{
 213:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			/* Ensure the other task attempting to access the mutex (and the
 214:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			other demo tasks) are able to execute. */
 215:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			vTaskDelay( recmuSHORT_DELAY );
 266              		.loc 1 215 0
 267 006c 1420     		movs	r0, #20
 268 006e FFF7FEFF 		bl	vTaskDelay
 216:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 217:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			/* We should now be able to give the mutex as many times as we
 218:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			took it.  When the mutex is available again the Blocking task
 219:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			should be unblocked but not run because it has a lower priority
 220:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			than this task.  The polling task should also not run at this point
 221:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			as it too has a lower priority than this task. */
 222:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			if( xSemaphoreGiveRecursive( xMutex ) != pdPASS )
 269              		.loc 1 222 0
 270 0072 40F20003 		movw	r3, #:lower16:xMutex
 271 0076 C0F20003 		movt	r3, #:upper16:xMutex
 272 007a 1B68     		ldr	r3, [r3]
 273 007c 1846     		mov	r0, r3
 274 007e FFF7FEFF 		bl	xQueueGiveMutexRecursive
 275 0082 0346     		mov	r3, r0
 276 0084 012B     		cmp	r3, #1
 277 0086 05D0     		beq	.L9
 223:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			{
 224:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				xErrorOccurred = pdTRUE;
 278              		.loc 1 224 0
 279 0088 40F20003 		movw	r3, #:lower16:xErrorOccurred
 280 008c C0F20003 		movt	r3, #:upper16:xErrorOccurred
 281 0090 0122     		movs	r2, #1
 282 0092 1A60     		str	r2, [r3]
 283              	.L9:
 211:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		{
 284              		.loc 1 211 0
 285 0094 FB68     		ldr	r3, [r7, #12]
 286 0096 0133     		adds	r3, r3, #1
 287 0098 FB60     		str	r3, [r7, #12]
 288              	.L8:
 211:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		{
 289              		.loc 1 211 0 is_stmt 0 discriminator 1
 290 009a FB68     		ldr	r3, [r7, #12]
 291 009c 092B     		cmp	r3, #9
 292 009e E5D9     		bls	.L10
 225:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			}
 226:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		}
 227:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 228:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		/* Having given it back the same number of times as it was taken, we
 229:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		should no longer be the mutex owner, so the next give should fail. */
 230:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		if( xSemaphoreGiveRecursive( xMutex ) == pdPASS )
 293              		.loc 1 230 0 is_stmt 1
 294 00a0 40F20003 		movw	r3, #:lower16:xMutex
 295 00a4 C0F20003 		movt	r3, #:upper16:xMutex
 296 00a8 1B68     		ldr	r3, [r3]
 297 00aa 1846     		mov	r0, r3
 298 00ac FFF7FEFF 		bl	xQueueGiveMutexRecursive
 299 00b0 0346     		mov	r3, r0
 300 00b2 012B     		cmp	r3, #1
 301 00b4 05D1     		bne	.L11
 231:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		{
 232:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			xErrorOccurred = pdTRUE;
 302              		.loc 1 232 0
 303 00b6 40F20003 		movw	r3, #:lower16:xErrorOccurred
 304 00ba C0F20003 		movt	r3, #:upper16:xErrorOccurred
 305 00be 0122     		movs	r2, #1
 306 00c0 1A60     		str	r2, [r3]
 307              	.L11:
 233:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		}
 234:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 235:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		/* Keep count of the number of cycles this task has performed so a
 236:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		stall can be detected. */
 237:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		uxControllingCycles++;
 308              		.loc 1 237 0
 309 00c2 40F20003 		movw	r3, #:lower16:uxControllingCycles
 310 00c6 C0F20003 		movt	r3, #:upper16:uxControllingCycles
 311 00ca 1B68     		ldr	r3, [r3]
 312 00cc 5A1C     		adds	r2, r3, #1
 313 00ce 40F20003 		movw	r3, #:lower16:uxControllingCycles
 314 00d2 C0F20003 		movt	r3, #:upper16:uxControllingCycles
 315 00d6 1A60     		str	r2, [r3]
 238:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 239:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		/* Suspend ourselves so the blocking task can execute. */
 240:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		xControllingIsSuspended = pdTRUE;
 316              		.loc 1 240 0
 317 00d8 40F20003 		movw	r3, #:lower16:xControllingIsSuspended
 318 00dc C0F20003 		movt	r3, #:upper16:xControllingIsSuspended
 319 00e0 0122     		movs	r2, #1
 320 00e2 1A60     		str	r2, [r3]
 241:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		vTaskSuspend( NULL );
 321              		.loc 1 241 0
 322 00e4 0020     		movs	r0, #0
 323 00e6 FFF7FEFF 		bl	vTaskSuspend
 242:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		xControllingIsSuspended = pdFALSE;
 324              		.loc 1 242 0
 325 00ea 40F20003 		movw	r3, #:lower16:xControllingIsSuspended
 326 00ee C0F20003 		movt	r3, #:upper16:xControllingIsSuspended
 327 00f2 0022     		movs	r2, #0
 328 00f4 1A60     		str	r2, [r3]
 243:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	}
 329              		.loc 1 243 0
 330 00f6 87E7     		b	.L12
 331              		.cfi_endproc
 332              	.LFE2:
 334              		.section	.text.prvRecursiveMutexBlockingTask,"ax",%progbits
 335              		.align	2
 336              		.thumb
 337              		.thumb_func
 339              	prvRecursiveMutexBlockingTask:
 340              	.LFB3:
 244:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** }
 245:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** /*-----------------------------------------------------------*/
 246:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 247:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** static void prvRecursiveMutexBlockingTask( void *pvParameters )
 248:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** {
 341              		.loc 1 248 0
 342              		.cfi_startproc
 343              		@ args = 0, pretend = 0, frame = 8
 344              		@ frame_needed = 1, uses_anonymous_args = 0
 345 0000 80B5     		push	{r7, lr}
 346              	.LCFI6:
 347              		.cfi_def_cfa_offset 8
 348              		.cfi_offset 7, -8
 349              		.cfi_offset 14, -4
 350 0002 82B0     		sub	sp, sp, #8
 351              	.LCFI7:
 352              		.cfi_def_cfa_offset 16
 353 0004 00AF     		add	r7, sp, #0
 354              	.LCFI8:
 355              		.cfi_def_cfa_register 7
 356 0006 7860     		str	r0, [r7, #4]
 357              	.L20:
 249:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	/* Just to remove compiler warning. */
 250:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	( void ) pvParameters;
 251:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 252:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	for( ;; )
 253:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	{
 254:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		/* This task will run while the controlling task is blocked, and the
 255:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		controlling task will block only once it has the mutex - therefore
 256:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		this call should block until the controlling task has given up the
 257:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		mutex, and not actually execute	past this call until the controlling
 258:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		task is suspended.  portMAX_DELAY - 1 is used instead of portMAX_DELAY
 259:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		to ensure the task's state is reported as Blocked and not Suspended in
 260:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		a later call to configASSERT() (within the polling task). */
 261:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		if( xSemaphoreTakeRecursive( xMutex, ( portMAX_DELAY - 1 ) ) == pdPASS )
 358              		.loc 1 261 0
 359 0008 40F20003 		movw	r3, #:lower16:xMutex
 360 000c C0F20003 		movt	r3, #:upper16:xMutex
 361 0010 1B68     		ldr	r3, [r3]
 362 0012 1846     		mov	r0, r3
 363 0014 6FF00101 		mvn	r1, #1
 364 0018 FFF7FEFF 		bl	xQueueTakeMutexRecursive
 365 001c 0346     		mov	r3, r0
 366 001e 012B     		cmp	r3, #1
 367 0020 2ED1     		bne	.L14
 262:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		{
 263:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			if( xControllingIsSuspended != pdTRUE )
 368              		.loc 1 263 0
 369 0022 40F20003 		movw	r3, #:lower16:xControllingIsSuspended
 370 0026 C0F20003 		movt	r3, #:upper16:xControllingIsSuspended
 371 002a 1B68     		ldr	r3, [r3]
 372 002c 012B     		cmp	r3, #1
 373 002e 06D0     		beq	.L15
 264:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			{
 265:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				/* Did not expect to execute until the controlling task was
 266:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				suspended. */
 267:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				xErrorOccurred = pdTRUE;
 374              		.loc 1 267 0
 375 0030 40F20003 		movw	r3, #:lower16:xErrorOccurred
 376 0034 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 377 0038 0122     		movs	r2, #1
 378 003a 1A60     		str	r2, [r3]
 379 003c 26E0     		b	.L18
 380              	.L15:
 268:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			}
 269:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			else
 270:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			{
 271:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				/* Give the mutex back before suspending ourselves to allow
 272:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				the polling task to obtain the mutex. */
 273:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				if( xSemaphoreGiveRecursive( xMutex ) != pdPASS )
 381              		.loc 1 273 0
 382 003e 40F20003 		movw	r3, #:lower16:xMutex
 383 0042 C0F20003 		movt	r3, #:upper16:xMutex
 384 0046 1B68     		ldr	r3, [r3]
 385 0048 1846     		mov	r0, r3
 386 004a FFF7FEFF 		bl	xQueueGiveMutexRecursive
 387 004e 0346     		mov	r3, r0
 388 0050 012B     		cmp	r3, #1
 389 0052 05D0     		beq	.L17
 274:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				{
 275:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 					xErrorOccurred = pdTRUE;
 390              		.loc 1 275 0
 391 0054 40F20003 		movw	r3, #:lower16:xErrorOccurred
 392 0058 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 393 005c 0122     		movs	r2, #1
 394 005e 1A60     		str	r2, [r3]
 395              	.L17:
 276:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				}
 277:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 278:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				xBlockingIsSuspended = pdTRUE;
 396              		.loc 1 278 0
 397 0060 40F20003 		movw	r3, #:lower16:xBlockingIsSuspended
 398 0064 C0F20003 		movt	r3, #:upper16:xBlockingIsSuspended
 399 0068 0122     		movs	r2, #1
 400 006a 1A60     		str	r2, [r3]
 279:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				vTaskSuspend( NULL );
 401              		.loc 1 279 0
 402 006c 0020     		movs	r0, #0
 403 006e FFF7FEFF 		bl	vTaskSuspend
 280:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				xBlockingIsSuspended = pdFALSE;
 404              		.loc 1 280 0
 405 0072 40F20003 		movw	r3, #:lower16:xBlockingIsSuspended
 406 0076 C0F20003 		movt	r3, #:upper16:xBlockingIsSuspended
 407 007a 0022     		movs	r2, #0
 408 007c 1A60     		str	r2, [r3]
 409 007e 05E0     		b	.L18
 410              	.L14:
 281:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			}
 282:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		}
 283:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		else
 284:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		{
 285:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			/* We should not leave the xSemaphoreTakeRecursive() function
 286:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			until the mutex was obtained. */
 287:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			xErrorOccurred = pdTRUE;
 411              		.loc 1 287 0
 412 0080 40F20003 		movw	r3, #:lower16:xErrorOccurred
 413 0084 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 414 0088 0122     		movs	r2, #1
 415 008a 1A60     		str	r2, [r3]
 416              	.L18:
 288:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		}
 289:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 290:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		/* The controlling and blocking tasks should be in lock step. */
 291:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		if( uxControllingCycles != ( uxBlockingCycles + 1 ) )
 417              		.loc 1 291 0
 418 008c 40F20003 		movw	r3, #:lower16:uxBlockingCycles
 419 0090 C0F20003 		movt	r3, #:upper16:uxBlockingCycles
 420 0094 1B68     		ldr	r3, [r3]
 421 0096 5A1C     		adds	r2, r3, #1
 422 0098 40F20003 		movw	r3, #:lower16:uxControllingCycles
 423 009c C0F20003 		movt	r3, #:upper16:uxControllingCycles
 424 00a0 1B68     		ldr	r3, [r3]
 425 00a2 9A42     		cmp	r2, r3
 426 00a4 05D0     		beq	.L19
 292:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		{
 293:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			xErrorOccurred = pdTRUE;
 427              		.loc 1 293 0
 428 00a6 40F20003 		movw	r3, #:lower16:xErrorOccurred
 429 00aa C0F20003 		movt	r3, #:upper16:xErrorOccurred
 430 00ae 0122     		movs	r2, #1
 431 00b0 1A60     		str	r2, [r3]
 432              	.L19:
 294:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		}
 295:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 296:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		/* Keep count of the number of cycles this task has performed so a
 297:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		stall can be detected. */
 298:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		uxBlockingCycles++;
 433              		.loc 1 298 0
 434 00b2 40F20003 		movw	r3, #:lower16:uxBlockingCycles
 435 00b6 C0F20003 		movt	r3, #:upper16:uxBlockingCycles
 436 00ba 1B68     		ldr	r3, [r3]
 437 00bc 5A1C     		adds	r2, r3, #1
 438 00be 40F20003 		movw	r3, #:lower16:uxBlockingCycles
 439 00c2 C0F20003 		movt	r3, #:upper16:uxBlockingCycles
 440 00c6 1A60     		str	r2, [r3]
 299:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	}
 441              		.loc 1 299 0
 442 00c8 9EE7     		b	.L20
 443              		.cfi_endproc
 444              	.LFE3:
 446 00ca 00BF     		.section	.text.prvRecursiveMutexPollingTask,"ax",%progbits
 447              		.align	2
 448              		.thumb
 449              		.thumb_func
 451              	prvRecursiveMutexPollingTask:
 452              	.LFB4:
 300:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** }
 301:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** /*-----------------------------------------------------------*/
 302:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 303:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** static void prvRecursiveMutexPollingTask( void *pvParameters )
 304:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** {
 453              		.loc 1 304 0
 454              		.cfi_startproc
 455              		@ args = 0, pretend = 0, frame = 8
 456              		@ frame_needed = 1, uses_anonymous_args = 0
 457 0000 80B5     		push	{r7, lr}
 458              	.LCFI9:
 459              		.cfi_def_cfa_offset 8
 460              		.cfi_offset 7, -8
 461              		.cfi_offset 14, -4
 462 0002 82B0     		sub	sp, sp, #8
 463              	.LCFI10:
 464              		.cfi_def_cfa_offset 16
 465 0004 00AF     		add	r7, sp, #0
 466              	.LCFI11:
 467              		.cfi_def_cfa_register 7
 468 0006 7860     		str	r0, [r7, #4]
 469              	.L31:
 305:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	/* Just to remove compiler warning. */
 306:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	( void ) pvParameters;
 307:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 308:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	for( ;; )
 309:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	{
 310:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		/* Keep attempting to obtain the mutex.  We should only obtain it when
 311:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		the blocking task has suspended itself, which in turn should only
 312:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		happen when the controlling task is also suspended. */
 313:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		if( xSemaphoreTakeRecursive( xMutex, recmuNO_DELAY ) == pdPASS )
 470              		.loc 1 313 0
 471 0008 40F20003 		movw	r3, #:lower16:xMutex
 472 000c C0F20003 		movt	r3, #:upper16:xMutex
 473 0010 1B68     		ldr	r3, [r3]
 474 0012 1846     		mov	r0, r3
 475 0014 0021     		movs	r1, #0
 476 0016 FFF7FEFF 		bl	xQueueTakeMutexRecursive
 477 001a 0346     		mov	r3, r0
 478 001c 012B     		cmp	r3, #1
 479 001e 66D1     		bne	.L22
 314:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		{
 315:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			#if( INCLUDE_eTaskGetState == 1 )
 316:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			{
 317:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				configASSERT( eTaskGetState( xControllingTaskHandle ) == eSuspended );
 318:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				configASSERT( eTaskGetState( xBlockingTaskHandle ) == eSuspended );
 319:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			}
 320:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			#endif /* INCLUDE_eTaskGetState */
 321:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 322:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			/* Is the blocking task suspended? */
 323:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			if( ( xBlockingIsSuspended != pdTRUE ) || ( xControllingIsSuspended != pdTRUE ) )
 480              		.loc 1 323 0
 481 0020 40F20003 		movw	r3, #:lower16:xBlockingIsSuspended
 482 0024 C0F20003 		movt	r3, #:upper16:xBlockingIsSuspended
 483 0028 1B68     		ldr	r3, [r3]
 484 002a 012B     		cmp	r3, #1
 485 002c 06D1     		bne	.L23
 486              		.loc 1 323 0 is_stmt 0 discriminator 1
 487 002e 40F20003 		movw	r3, #:lower16:xControllingIsSuspended
 488 0032 C0F20003 		movt	r3, #:upper16:xControllingIsSuspended
 489 0036 1B68     		ldr	r3, [r3]
 490 0038 012B     		cmp	r3, #1
 491 003a 06D0     		beq	.L24
 492              	.L23:
 324:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			{
 325:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				xErrorOccurred = pdTRUE;
 493              		.loc 1 325 0 is_stmt 1
 494 003c 40F20003 		movw	r3, #:lower16:xErrorOccurred
 495 0040 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 496 0044 0122     		movs	r2, #1
 497 0046 1A60     		str	r2, [r3]
 498 0048 51E0     		b	.L22
 499              	.L24:
 326:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			}
 327:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			else
 328:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			{
 329:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				/* Keep count of the number of cycles this task has performed
 330:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				so a stall can be detected. */
 331:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				uxPollingCycles++;
 500              		.loc 1 331 0
 501 004a 40F20003 		movw	r3, #:lower16:uxPollingCycles
 502 004e C0F20003 		movt	r3, #:upper16:uxPollingCycles
 503 0052 1B68     		ldr	r3, [r3]
 504 0054 5A1C     		adds	r2, r3, #1
 505 0056 40F20003 		movw	r3, #:lower16:uxPollingCycles
 506 005a C0F20003 		movt	r3, #:upper16:uxPollingCycles
 507 005e 1A60     		str	r2, [r3]
 332:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 333:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				/* We can resume the other tasks here even though they have a
 334:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				higher priority than the polling task.  When they execute they
 335:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				will attempt to obtain the mutex but fail because the polling
 336:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				task is still the mutex holder.  The polling task (this task)
 337:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				will then inherit the higher priority.  The Blocking task will
 338:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				block indefinitely when it attempts to obtain the mutex, the
 339:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				Controlling task will only block for a fixed period and an
 340:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				error will be latched if the polling task has not returned the
 341:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				mutex by the time this fixed period has expired. */
 342:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				vTaskResume( xBlockingTaskHandle );
 508              		.loc 1 342 0
 509 0060 40F20003 		movw	r3, #:lower16:xBlockingTaskHandle
 510 0064 C0F20003 		movt	r3, #:upper16:xBlockingTaskHandle
 511 0068 1B68     		ldr	r3, [r3]
 512 006a 1846     		mov	r0, r3
 513 006c FFF7FEFF 		bl	vTaskResume
 343:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c ****                 vTaskResume( xControllingTaskHandle );
 514              		.loc 1 343 0
 515 0070 40F20003 		movw	r3, #:lower16:xControllingTaskHandle
 516 0074 C0F20003 		movt	r3, #:upper16:xControllingTaskHandle
 517 0078 1B68     		ldr	r3, [r3]
 518 007a 1846     		mov	r0, r3
 519 007c FFF7FEFF 		bl	vTaskResume
 344:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 345:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				/* The other two tasks should now have executed and no longer
 346:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				be suspended. */
 347:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				if( ( xBlockingIsSuspended == pdTRUE ) || ( xControllingIsSuspended == pdTRUE ) )
 520              		.loc 1 347 0
 521 0080 40F20003 		movw	r3, #:lower16:xBlockingIsSuspended
 522 0084 C0F20003 		movt	r3, #:upper16:xBlockingIsSuspended
 523 0088 1B68     		ldr	r3, [r3]
 524 008a 012B     		cmp	r3, #1
 525 008c 06D0     		beq	.L25
 526              		.loc 1 347 0 is_stmt 0 discriminator 1
 527 008e 40F20003 		movw	r3, #:lower16:xControllingIsSuspended
 528 0092 C0F20003 		movt	r3, #:upper16:xControllingIsSuspended
 529 0096 1B68     		ldr	r3, [r3]
 530 0098 012B     		cmp	r3, #1
 531 009a 05D1     		bne	.L26
 532              	.L25:
 348:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				{
 349:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 					xErrorOccurred = pdTRUE;
 533              		.loc 1 349 0 is_stmt 1
 534 009c 40F20003 		movw	r3, #:lower16:xErrorOccurred
 535 00a0 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 536 00a4 0122     		movs	r2, #1
 537 00a6 1A60     		str	r2, [r3]
 538              	.L26:
 350:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				}
 351:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 352:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				#if( INCLUDE_uxTaskPriorityGet == 1 )
 353:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				{
 354:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 					/* Check priority inherited. */
 355:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 					configASSERT( uxTaskPriorityGet( NULL ) == recmuCONTROLLING_TASK_PRIORITY );
 539              		.loc 1 355 0
 540 00a8 0020     		movs	r0, #0
 541 00aa FFF7FEFF 		bl	uxTaskPriorityGet
 542 00ae 0346     		mov	r3, r0
 543 00b0 022B     		cmp	r3, #2
 544 00b2 02D0     		beq	.L27
 545              		.loc 1 355 0 is_stmt 0 discriminator 1
 546 00b4 FFF7FEFF 		bl	ulPortSetInterruptMask
 547              	.L28:
 548 00b8 FEE7     		b	.L28
 549              	.L27:
 356:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				}
 357:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				#endif /* INCLUDE_uxTaskPriorityGet */
 358:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 359:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				#if( INCLUDE_eTaskGetState == 1 )
 360:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				{
 361:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 					configASSERT( eTaskGetState( xControllingTaskHandle ) == eBlocked );
 362:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 					configASSERT( eTaskGetState( xBlockingTaskHandle ) == eBlocked );
 363:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				}
 364:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				#endif /* INCLUDE_eTaskGetState */
 365:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 366:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				/* Release the mutex, disinheriting the higher priority again. */
 367:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				if( xSemaphoreGiveRecursive( xMutex ) != pdPASS )
 550              		.loc 1 367 0 is_stmt 1
 551 00ba 40F20003 		movw	r3, #:lower16:xMutex
 552 00be C0F20003 		movt	r3, #:upper16:xMutex
 553 00c2 1B68     		ldr	r3, [r3]
 554 00c4 1846     		mov	r0, r3
 555 00c6 FFF7FEFF 		bl	xQueueGiveMutexRecursive
 556 00ca 0346     		mov	r3, r0
 557 00cc 012B     		cmp	r3, #1
 558 00ce 05D0     		beq	.L29
 368:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				{
 369:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 					xErrorOccurred = pdTRUE;
 559              		.loc 1 369 0
 560 00d0 40F20003 		movw	r3, #:lower16:xErrorOccurred
 561 00d4 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 562 00d8 0122     		movs	r2, #1
 563 00da 1A60     		str	r2, [r3]
 564              	.L29:
 370:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				}
 371:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 372:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				#if( INCLUDE_uxTaskPriorityGet == 1 )
 373:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				{
 374:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 					/* Check priority disinherited. */
 375:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 					configASSERT( uxTaskPriorityGet( NULL ) == recmuPOLLING_TASK_PRIORITY );
 565              		.loc 1 375 0
 566 00dc 0020     		movs	r0, #0
 567 00de FFF7FEFF 		bl	uxTaskPriorityGet
 568 00e2 0346     		mov	r3, r0
 569 00e4 002B     		cmp	r3, #0
 570 00e6 02D0     		beq	.L22
 571              		.loc 1 375 0 is_stmt 0 discriminator 1
 572 00e8 FFF7FEFF 		bl	ulPortSetInterruptMask
 573              	.L30:
 574 00ec FEE7     		b	.L30
 575              	.L22:
 376:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				}
 377:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 				#endif /* INCLUDE_uxTaskPriorityGet */
 378:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			}
 379:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		}
 380:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 381:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		#if configUSE_PREEMPTION == 0
 382:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		{
 383:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 			taskYIELD();
 384:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		}
 385:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		#endif
 386:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	}
 576              		.loc 1 386 0 is_stmt 1
 577 00ee 8BE7     		b	.L31
 578              		.cfi_endproc
 579              	.LFE4:
 581              		.section	.text.xAreRecursiveMutexTasksStillRunning,"ax",%progbits
 582              		.align	2
 583              		.global	xAreRecursiveMutexTasksStillRunning
 584              		.thumb
 585              		.thumb_func
 587              	xAreRecursiveMutexTasksStillRunning:
 588              	.LFB5:
 387:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** }
 388:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** /*-----------------------------------------------------------*/
 389:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 390:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** /* This is called to check that all the created tasks are still running. */
 391:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** BaseType_t xAreRecursiveMutexTasksStillRunning( void )
 392:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** {
 589              		.loc 1 392 0
 590              		.cfi_startproc
 591              		@ args = 0, pretend = 0, frame = 8
 592              		@ frame_needed = 1, uses_anonymous_args = 0
 593              		@ link register save eliminated.
 594 0000 80B4     		push	{r7}
 595              	.LCFI12:
 596              		.cfi_def_cfa_offset 4
 597              		.cfi_offset 7, -4
 598 0002 83B0     		sub	sp, sp, #12
 599              	.LCFI13:
 600              		.cfi_def_cfa_offset 16
 601 0004 00AF     		add	r7, sp, #0
 602              	.LCFI14:
 603              		.cfi_def_cfa_register 7
 393:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** BaseType_t xReturn;
 394:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** static UBaseType_t uxLastControllingCycles = 0, uxLastBlockingCycles = 0, uxLastPollingCycles = 0;
 395:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 396:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	/* Is the controlling task still cycling? */
 397:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	if( uxLastControllingCycles == uxControllingCycles )
 604              		.loc 1 397 0
 605 0006 40F20003 		movw	r3, #:lower16:uxLastControllingCycles.4495
 606 000a C0F20003 		movt	r3, #:upper16:uxLastControllingCycles.4495
 607 000e 1A68     		ldr	r2, [r3]
 608 0010 40F20003 		movw	r3, #:lower16:uxControllingCycles
 609 0014 C0F20003 		movt	r3, #:upper16:uxControllingCycles
 610 0018 1B68     		ldr	r3, [r3]
 611 001a 9A42     		cmp	r2, r3
 612 001c 06D1     		bne	.L33
 398:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	{
 399:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		xErrorOccurred = pdTRUE;
 613              		.loc 1 399 0
 614 001e 40F20003 		movw	r3, #:lower16:xErrorOccurred
 615 0022 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 616 0026 0122     		movs	r2, #1
 617 0028 1A60     		str	r2, [r3]
 618 002a 09E0     		b	.L34
 619              	.L33:
 400:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	}
 401:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	else
 402:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	{
 403:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		uxLastControllingCycles = uxControllingCycles;
 620              		.loc 1 403 0
 621 002c 40F20003 		movw	r3, #:lower16:uxControllingCycles
 622 0030 C0F20003 		movt	r3, #:upper16:uxControllingCycles
 623 0034 1A68     		ldr	r2, [r3]
 624 0036 40F20003 		movw	r3, #:lower16:uxLastControllingCycles.4495
 625 003a C0F20003 		movt	r3, #:upper16:uxLastControllingCycles.4495
 626 003e 1A60     		str	r2, [r3]
 627              	.L34:
 404:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	}
 405:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 406:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	/* Is the blocking task still cycling? */
 407:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	if( uxLastBlockingCycles == uxBlockingCycles )
 628              		.loc 1 407 0
 629 0040 40F20003 		movw	r3, #:lower16:uxLastBlockingCycles.4496
 630 0044 C0F20003 		movt	r3, #:upper16:uxLastBlockingCycles.4496
 631 0048 1A68     		ldr	r2, [r3]
 632 004a 40F20003 		movw	r3, #:lower16:uxBlockingCycles
 633 004e C0F20003 		movt	r3, #:upper16:uxBlockingCycles
 634 0052 1B68     		ldr	r3, [r3]
 635 0054 9A42     		cmp	r2, r3
 636 0056 06D1     		bne	.L35
 408:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	{
 409:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		xErrorOccurred = pdTRUE;
 637              		.loc 1 409 0
 638 0058 40F20003 		movw	r3, #:lower16:xErrorOccurred
 639 005c C0F20003 		movt	r3, #:upper16:xErrorOccurred
 640 0060 0122     		movs	r2, #1
 641 0062 1A60     		str	r2, [r3]
 642 0064 09E0     		b	.L36
 643              	.L35:
 410:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	}
 411:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	else
 412:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	{
 413:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		uxLastBlockingCycles = uxBlockingCycles;
 644              		.loc 1 413 0
 645 0066 40F20003 		movw	r3, #:lower16:uxBlockingCycles
 646 006a C0F20003 		movt	r3, #:upper16:uxBlockingCycles
 647 006e 1A68     		ldr	r2, [r3]
 648 0070 40F20003 		movw	r3, #:lower16:uxLastBlockingCycles.4496
 649 0074 C0F20003 		movt	r3, #:upper16:uxLastBlockingCycles.4496
 650 0078 1A60     		str	r2, [r3]
 651              	.L36:
 414:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	}
 415:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 416:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	/* Is the polling task still cycling? */
 417:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	if( uxLastPollingCycles == uxPollingCycles )
 652              		.loc 1 417 0
 653 007a 40F20003 		movw	r3, #:lower16:uxLastPollingCycles.4497
 654 007e C0F20003 		movt	r3, #:upper16:uxLastPollingCycles.4497
 655 0082 1A68     		ldr	r2, [r3]
 656 0084 40F20003 		movw	r3, #:lower16:uxPollingCycles
 657 0088 C0F20003 		movt	r3, #:upper16:uxPollingCycles
 658 008c 1B68     		ldr	r3, [r3]
 659 008e 9A42     		cmp	r2, r3
 660 0090 06D1     		bne	.L37
 418:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	{
 419:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		xErrorOccurred = pdTRUE;
 661              		.loc 1 419 0
 662 0092 40F20003 		movw	r3, #:lower16:xErrorOccurred
 663 0096 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 664 009a 0122     		movs	r2, #1
 665 009c 1A60     		str	r2, [r3]
 666 009e 09E0     		b	.L38
 667              	.L37:
 420:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	}
 421:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	else
 422:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	{
 423:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		uxLastPollingCycles = uxPollingCycles;
 668              		.loc 1 423 0
 669 00a0 40F20003 		movw	r3, #:lower16:uxPollingCycles
 670 00a4 C0F20003 		movt	r3, #:upper16:uxPollingCycles
 671 00a8 1A68     		ldr	r2, [r3]
 672 00aa 40F20003 		movw	r3, #:lower16:uxLastPollingCycles.4497
 673 00ae C0F20003 		movt	r3, #:upper16:uxLastPollingCycles.4497
 674 00b2 1A60     		str	r2, [r3]
 675              	.L38:
 424:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	}
 425:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 426:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	if( xErrorOccurred == pdTRUE )
 676              		.loc 1 426 0
 677 00b4 40F20003 		movw	r3, #:lower16:xErrorOccurred
 678 00b8 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 679 00bc 1B68     		ldr	r3, [r3]
 680 00be 012B     		cmp	r3, #1
 681 00c0 02D1     		bne	.L39
 427:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	{
 428:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		xReturn = pdFAIL;
 682              		.loc 1 428 0
 683 00c2 0023     		movs	r3, #0
 684 00c4 7B60     		str	r3, [r7, #4]
 685 00c6 01E0     		b	.L40
 686              	.L39:
 429:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	}
 430:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	else
 431:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	{
 432:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 		xReturn = pdTRUE;
 687              		.loc 1 432 0
 688 00c8 0123     		movs	r3, #1
 689 00ca 7B60     		str	r3, [r7, #4]
 690              	.L40:
 433:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	}
 434:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 
 435:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** 	return xReturn;
 691              		.loc 1 435 0
 692 00cc 7B68     		ldr	r3, [r7, #4]
 436:lib/FreeRTOSV8.1.2/FreeRTOS/Demo/Common/Minimal/recmutex.c **** }
 693              		.loc 1 436 0
 694 00ce 1846     		mov	r0, r3
 695 00d0 0C37     		adds	r7, r7, #12
 696 00d2 BD46     		mov	sp, r7
 697              		@ sp needed
 698 00d4 5DF8047B 		ldr	r7, [sp], #4
 699 00d8 7047     		bx	lr
 700              		.cfi_endproc
 701              	.LFE5:
 703 00da 00BF     		.section	.bss.uxLastControllingCycles.4495,"aw",%nobits
 704              		.align	2
 707              	uxLastControllingCycles.4495:
 708 0000 00000000 		.space	4
 709              		.section	.bss.uxLastBlockingCycles.4496,"aw",%nobits
 710              		.align	2
 713              	uxLastBlockingCycles.4496:
 714 0000 00000000 		.space	4
 715              		.section	.bss.uxLastPollingCycles.4497,"aw",%nobits
 716              		.align	2
 719              	uxLastPollingCycles.4497:
 720 0000 00000000 		.space	4
 721              		.text
 722              	.Letext0:
 723              		.file 2 "/usr/include/newlib/machine/_default_types.h"
 724              		.file 3 "/usr/include/newlib/stdint.h"
 725              		.file 4 "lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h"
 726              		.file 5 "lib/FreeRTOSV8.1.2/FreeRTOS/Source/include/task.h"
 727              		.file 6 "lib/FreeRTOSV8.1.2/FreeRTOS/Source/include/queue.h"
 728              		.file 7 "lib/FreeRTOSV8.1.2/FreeRTOS/Source/include/semphr.h"
DEFINED SYMBOLS
                            *ABS*:00000000 recmutex.c
     /tmp/cc1FqMHs.s:20     .bss.xMutex:00000000 $d
     /tmp/cc1FqMHs.s:23     .bss.xMutex:00000000 xMutex
     /tmp/cc1FqMHs.s:26     .bss.xErrorOccurred:00000000 $d
     /tmp/cc1FqMHs.s:29     .bss.xErrorOccurred:00000000 xErrorOccurred
     /tmp/cc1FqMHs.s:32     .bss.xControllingIsSuspended:00000000 $d
     /tmp/cc1FqMHs.s:35     .bss.xControllingIsSuspended:00000000 xControllingIsSuspended
     /tmp/cc1FqMHs.s:38     .bss.xBlockingIsSuspended:00000000 $d
     /tmp/cc1FqMHs.s:41     .bss.xBlockingIsSuspended:00000000 xBlockingIsSuspended
     /tmp/cc1FqMHs.s:44     .bss.uxControllingCycles:00000000 $d
     /tmp/cc1FqMHs.s:47     .bss.uxControllingCycles:00000000 uxControllingCycles
     /tmp/cc1FqMHs.s:50     .bss.uxBlockingCycles:00000000 $d
     /tmp/cc1FqMHs.s:53     .bss.uxBlockingCycles:00000000 uxBlockingCycles
     /tmp/cc1FqMHs.s:56     .bss.uxPollingCycles:00000000 $d
     /tmp/cc1FqMHs.s:59     .bss.uxPollingCycles:00000000 uxPollingCycles
     /tmp/cc1FqMHs.s:62     .bss.xControllingTaskHandle:00000000 $d
     /tmp/cc1FqMHs.s:65     .bss.xControllingTaskHandle:00000000 xControllingTaskHandle
     /tmp/cc1FqMHs.s:68     .bss.xBlockingTaskHandle:00000000 $d
     /tmp/cc1FqMHs.s:71     .bss.xBlockingTaskHandle:00000000 xBlockingTaskHandle
     /tmp/cc1FqMHs.s:74     .rodata:00000000 $d
     /tmp/cc1FqMHs.s:75     .rodata:00000000 .LC0
     /tmp/cc1FqMHs.s:78     .rodata:00000010 .LC1
     /tmp/cc1FqMHs.s:81     .rodata:00000018 .LC2
     /tmp/cc1FqMHs.s:84     .rodata:00000020 .LC3
     /tmp/cc1FqMHs.s:87     .text.vStartRecursiveMutexTasks:00000000 $t
     /tmp/cc1FqMHs.s:92     .text.vStartRecursiveMutexTasks:00000000 vStartRecursiveMutexTasks
     /tmp/cc1FqMHs.s:194    .text.prvRecursiveMutexControllingTask:00000000 prvRecursiveMutexControllingTask
     /tmp/cc1FqMHs.s:339    .text.prvRecursiveMutexBlockingTask:00000000 prvRecursiveMutexBlockingTask
     /tmp/cc1FqMHs.s:451    .text.prvRecursiveMutexPollingTask:00000000 prvRecursiveMutexPollingTask
     /tmp/cc1FqMHs.s:190    .text.prvRecursiveMutexControllingTask:00000000 $t
     /tmp/cc1FqMHs.s:335    .text.prvRecursiveMutexBlockingTask:00000000 $t
     /tmp/cc1FqMHs.s:447    .text.prvRecursiveMutexPollingTask:00000000 $t
     /tmp/cc1FqMHs.s:582    .text.xAreRecursiveMutexTasksStillRunning:00000000 $t
     /tmp/cc1FqMHs.s:587    .text.xAreRecursiveMutexTasksStillRunning:00000000 xAreRecursiveMutexTasksStillRunning
     /tmp/cc1FqMHs.s:707    .bss.uxLastControllingCycles.4495:00000000 uxLastControllingCycles.4495
     /tmp/cc1FqMHs.s:713    .bss.uxLastBlockingCycles.4496:00000000 uxLastBlockingCycles.4496
     /tmp/cc1FqMHs.s:719    .bss.uxLastPollingCycles.4497:00000000 uxLastPollingCycles.4497
     /tmp/cc1FqMHs.s:704    .bss.uxLastControllingCycles.4495:00000000 $d
     /tmp/cc1FqMHs.s:710    .bss.uxLastBlockingCycles.4496:00000000 $d
     /tmp/cc1FqMHs.s:716    .bss.uxLastPollingCycles.4497:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
xQueueCreateMutex
vQueueAddToRegistry
xTaskGenericCreate
xQueueGiveMutexRecursive
xQueueTakeMutexRecursive
vTaskDelay
vTaskSuspend
vTaskResume
uxTaskPriorityGet
ulPortSetInterruptMask
