   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"port.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.data.uxCriticalNesting,"aw",%progbits
  20              		.align	2
  23              	uxCriticalNesting:
  24 0000 AAAAAAAA 		.word	-1431655766
  25              		.section	.bss.ucMaxSysCallPriority,"aw",%nobits
  28              	ucMaxSysCallPriority:
  29 0000 00       		.space	1
  30              		.section	.bss.ulMaxPRIGROUPValue,"aw",%nobits
  31              		.align	2
  34              	ulMaxPRIGROUPValue:
  35 0000 00000000 		.space	4
  36              		.section	.rodata.pcInterruptPriorityRegisters,"a",%progbits
  37              		.align	2
  40              	pcInterruptPriorityRegisters:
  41 0000 F0E300E0 		.word	-536812560
  42              		.section	.text.pxPortInitialiseStack,"ax",%progbits
  43              		.align	2
  44              		.global	pxPortInitialiseStack
  45              		.thumb
  46              		.thumb_func
  48              	pxPortInitialiseStack:
  49              	.LFB1:
  50              		.file 1 "lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c"
   1:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /*
   2:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****     FreeRTOS V8.1.2 - Copyright (C) 2014 Real Time Engineers Ltd.
   3:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****     All rights reserved
   4:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
   5:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
   7:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****     ***************************************************************************
   8:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****      *                                                                       *
   9:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  10:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****      *    robust, strictly quality controlled, supported, and cross          *
  11:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****      *    platform software that has become a de facto standard.             *
  12:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****      *                                                                       *
  13:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  14:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  15:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  16:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****      *                                                                       *
  17:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****      *    Thank you!                                                         *
  18:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****      *                                                                       *
  19:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****     ***************************************************************************
  20:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
  21:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****     This file is part of the FreeRTOS distribution.
  22:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
  23:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  24:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****     the terms of the GNU General Public License (version 2) as published by the
  25:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  26:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
  27:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****     >>!   NOTE: The modification to the GPL is included to allow you to     !<<
  28:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****     >>!   distribute a combined work that includes FreeRTOS without being   !<<
  29:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****     >>!   obliged to provide the source code for proprietary components     !<<
  30:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****     >>!   outside of the FreeRTOS kernel.                                   !<<
  31:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
  32:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  33:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  34:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  35:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****     link: http://www.freertos.org/a00114.html
  36:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
  37:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****     1 tab == 4 spaces!
  38:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
  39:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****     ***************************************************************************
  40:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****      *                                                                       *
  41:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  42:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****      *    not run, what could be wrong?"                                     *
  43:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****      *                                                                       *
  44:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  45:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****      *                                                                       *
  46:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****     ***************************************************************************
  47:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
  48:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  49:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****     license and Real Time Engineers Ltd. contact details.
  50:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
  51:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  52:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  53:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  54:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
  55:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  56:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  57:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****     licenses offer ticketed support, indemnification and middleware.
  58:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
  59:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  60:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****     engineered and independently SIL3 certified version for use in safety and
  61:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****     mission critical applications that require provable dependability.
  62:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
  63:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****     1 tab == 4 spaces!
  64:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** */
  65:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
  66:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /*-----------------------------------------------------------
  67:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  * Implementation of functions defined in portable.h for the ARM CM4F port.
  68:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  *----------------------------------------------------------*/
  69:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
  70:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /* Scheduler includes. */
  71:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #include "FreeRTOS.h"
  72:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #include "task.h"
  73:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
  74:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #ifndef __VFP_FP__
  75:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	#error This port can only be used when the project options are configured to enable hardware float
  76:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #endif
  77:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
  78:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #ifndef configSYSTICK_CLOCK_HZ
  79:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	#define configSYSTICK_CLOCK_HZ configCPU_CLOCK_HZ
  80:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	/* Ensure the SysTick is clocked at the same frequency as the core. */
  81:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	#define portNVIC_SYSTICK_CLK_BIT	( 1UL << 2UL )
  82:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #else
  83:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	/* The way the SysTick is clocked is not modified in case it is not the same
  84:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	as the core. */
  85:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	#define portNVIC_SYSTICK_CLK_BIT	( 0 )
  86:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #endif
  87:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
  88:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /* Constants required to manipulate the core.  Registers first... */
  89:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #define portNVIC_SYSTICK_CTRL_REG			( * ( ( volatile uint32_t * ) 0xe000e010 ) )
  90:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #define portNVIC_SYSTICK_LOAD_REG			( * ( ( volatile uint32_t * ) 0xe000e014 ) )
  91:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #define portNVIC_SYSTICK_CURRENT_VALUE_REG	( * ( ( volatile uint32_t * ) 0xe000e018 ) )
  92:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #define portNVIC_SYSPRI2_REG				( * ( ( volatile uint32_t * ) 0xe000ed20 ) )
  93:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /* ...then bits in the registers. */
  94:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #define portNVIC_SYSTICK_INT_BIT			( 1UL << 1UL )
  95:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #define portNVIC_SYSTICK_ENABLE_BIT			( 1UL << 0UL )
  96:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #define portNVIC_SYSTICK_COUNT_FLAG_BIT		( 1UL << 16UL )
  97:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #define portNVIC_PENDSVCLEAR_BIT 			( 1UL << 27UL )
  98:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #define portNVIC_PEND_SYSTICK_CLEAR_BIT		( 1UL << 25UL )
  99:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 100:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #define portNVIC_PENDSV_PRI					( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 16UL )
 101:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #define portNVIC_SYSTICK_PRI				( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 24UL )
 102:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 103:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /* Constants required to check the validity of an interrupt priority. */
 104:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #define portFIRST_USER_INTERRUPT_NUMBER		( 16 )
 105:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #define portNVIC_IP_REGISTERS_OFFSET_16 	( 0xE000E3F0 )
 106:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #define portAIRCR_REG						( * ( ( volatile uint32_t * ) 0xE000ED0C ) )
 107:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #define portMAX_8_BIT_VALUE					( ( uint8_t ) 0xff )
 108:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #define portTOP_BIT_OF_BYTE					( ( uint8_t ) 0x80 )
 109:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #define portMAX_PRIGROUP_BITS				( ( uint8_t ) 7 )
 110:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #define portPRIORITY_GROUP_MASK				( 0x07UL << 8UL )
 111:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #define portPRIGROUP_SHIFT					( 8UL )
 112:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 113:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /* Masks off all bits but the VECTACTIVE bits in the ICSR register. */
 114:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #define portVECTACTIVE_MASK					( 0x1FUL )
 115:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 116:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /* Constants required to manipulate the VFP. */
 117:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #define portFPCCR					( ( volatile uint32_t * ) 0xe000ef34 ) /* Floating point context control regi
 118:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #define portASPEN_AND_LSPEN_BITS	( 0x3UL << 30UL )
 119:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 120:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /* Constants required to set up the initial stack. */
 121:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #define portINITIAL_XPSR			( 0x01000000 )
 122:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #define portINITIAL_EXEC_RETURN		( 0xfffffffd )
 123:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 124:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /* The systick is a 24-bit counter. */
 125:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #define portMAX_24_BIT_NUMBER				( 0xffffffUL )
 126:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 127:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /* A fiddle factor to estimate the number of SysTick counts that would have
 128:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** occurred while the SysTick counter is stopped during tickless idle
 129:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** calculations. */
 130:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #define portMISSED_COUNTS_FACTOR			( 45UL )
 131:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 132:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /* Let the user override the pre-loading of the initial LR with the address of
 133:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** prvTaskExitError() in case is messes up unwinding of the stack in the
 134:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** debugger. */
 135:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #ifdef configTASK_RETURN_ADDRESS
 136:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	#define portTASK_RETURN_ADDRESS	configTASK_RETURN_ADDRESS
 137:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #else
 138:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	#define portTASK_RETURN_ADDRESS	prvTaskExitError
 139:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #endif
 140:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 141:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /* Each task maintains its own interrupt status in the critical nesting
 142:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** variable. */
 143:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** static UBaseType_t uxCriticalNesting = 0xaaaaaaaa;
 144:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 145:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /*
 146:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  * Setup the timer to generate the tick interrupts.  The implementation in this
 147:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  * file is weak to allow application writers to change the timer used to
 148:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  * generate the tick interrupt.
 149:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  */
 150:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** void vPortSetupTimerInterrupt( void );
 151:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 152:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /*
 153:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  * Exception handlers.
 154:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  */
 155:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** void xPortPendSVHandler( void ) __attribute__ (( naked ));
 156:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** void xPortSysTickHandler( void );
 157:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** void vPortSVCHandler( void ) __attribute__ (( naked ));
 158:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 159:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /*
 160:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  * Start first task is a separate function so it can be tested in isolation.
 161:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  */
 162:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** static void prvPortStartFirstTask( void ) __attribute__ (( naked ));
 163:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 164:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /*
 165:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  * Function to enable the VFP.
 166:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  */
 167:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  static void vPortEnableVFP( void ) __attribute__ (( naked ));
 168:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 169:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /*
 170:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  * Used to catch tasks that attempt to return from their implementing function.
 171:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  */
 172:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** static void prvTaskExitError( void );
 173:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 174:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /*-----------------------------------------------------------*/
 175:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 176:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /*
 177:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  * The number of SysTick increments that make up one tick period.
 178:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  */
 179:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #if configUSE_TICKLESS_IDLE == 1
 180:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	static uint32_t ulTimerCountsForOneTick = 0;
 181:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #endif /* configUSE_TICKLESS_IDLE */
 182:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 183:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /*
 184:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  * The maximum number of tick periods that can be suppressed is limited by the
 185:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  * 24 bit resolution of the SysTick timer.
 186:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  */
 187:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #if configUSE_TICKLESS_IDLE == 1
 188:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	static uint32_t xMaximumPossibleSuppressedTicks = 0;
 189:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #endif /* configUSE_TICKLESS_IDLE */
 190:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 191:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /*
 192:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  * Compensate for the CPU cycles that pass while the SysTick is stopped (low
 193:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  * power functionality only.
 194:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  */
 195:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #if configUSE_TICKLESS_IDLE == 1
 196:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	static uint32_t ulStoppedTimerCompensation = 0;
 197:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #endif /* configUSE_TICKLESS_IDLE */
 198:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 199:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /*
 200:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  * Used by the portASSERT_IF_INTERRUPT_PRIORITY_INVALID() macro to ensure
 201:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  * FreeRTOS API functions are not called from interrupts that have been assigned
 202:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  * a priority above configMAX_SYSCALL_INTERRUPT_PRIORITY.
 203:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  */
 204:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #if ( configASSERT_DEFINED == 1 )
 205:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	 static uint8_t ucMaxSysCallPriority = 0;
 206:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	 static uint32_t ulMaxPRIGROUPValue = 0;
 207:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	 static const volatile uint8_t * const pcInterruptPriorityRegisters = ( const volatile uint8_t * c
 208:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #endif /* configASSERT_DEFINED */
 209:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 210:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /*-----------------------------------------------------------*/
 211:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 212:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /*
 213:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  * See header file for description.
 214:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  */
 215:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParam
 216:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** {
  51              		.loc 1 216 0
  52              		.cfi_startproc
  53              		@ args = 0, pretend = 0, frame = 16
  54              		@ frame_needed = 1, uses_anonymous_args = 0
  55              		@ link register save eliminated.
  56 0000 80B4     		push	{r7}
  57              	.LCFI0:
  58              		.cfi_def_cfa_offset 4
  59              		.cfi_offset 7, -4
  60 0002 85B0     		sub	sp, sp, #20
  61              	.LCFI1:
  62              		.cfi_def_cfa_offset 24
  63 0004 00AF     		add	r7, sp, #0
  64              	.LCFI2:
  65              		.cfi_def_cfa_register 7
  66 0006 F860     		str	r0, [r7, #12]
  67 0008 B960     		str	r1, [r7, #8]
  68 000a 7A60     		str	r2, [r7, #4]
 217:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	/* Simulate the stack frame as it would be created by a context switch
 218:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	interrupt. */
 219:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 220:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	/* Offset added to account for the way the MCU uses the stack on entry/exit
 221:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	of interrupts, and to ensure alignment. */
 222:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	pxTopOfStack--;
  69              		.loc 1 222 0
  70 000c FB68     		ldr	r3, [r7, #12]
  71 000e 043B     		subs	r3, r3, #4
  72 0010 FB60     		str	r3, [r7, #12]
 223:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 224:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
  73              		.loc 1 224 0
  74 0012 FB68     		ldr	r3, [r7, #12]
  75 0014 4FF08072 		mov	r2, #16777216
  76 0018 1A60     		str	r2, [r3]
 225:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	pxTopOfStack--;
  77              		.loc 1 225 0
  78 001a FB68     		ldr	r3, [r7, #12]
  79 001c 043B     		subs	r3, r3, #4
  80 001e FB60     		str	r3, [r7, #12]
 226:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
  81              		.loc 1 226 0
  82 0020 BA68     		ldr	r2, [r7, #8]
  83 0022 FB68     		ldr	r3, [r7, #12]
  84 0024 1A60     		str	r2, [r3]
 227:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	pxTopOfStack--;
  85              		.loc 1 227 0
  86 0026 FB68     		ldr	r3, [r7, #12]
  87 0028 043B     		subs	r3, r3, #4
  88 002a FB60     		str	r3, [r7, #12]
 228:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
  89              		.loc 1 228 0
  90 002c 40F20003 		movw	r3, #:lower16:prvTaskExitError
  91 0030 C0F20003 		movt	r3, #:upper16:prvTaskExitError
  92 0034 FA68     		ldr	r2, [r7, #12]
  93 0036 1360     		str	r3, [r2]
 229:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 230:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	/* Save code space by skipping register initialisation. */
 231:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
  94              		.loc 1 231 0
  95 0038 FB68     		ldr	r3, [r7, #12]
  96 003a 143B     		subs	r3, r3, #20
  97 003c FB60     		str	r3, [r7, #12]
 232:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
  98              		.loc 1 232 0
  99 003e 7A68     		ldr	r2, [r7, #4]
 100 0040 FB68     		ldr	r3, [r7, #12]
 101 0042 1A60     		str	r2, [r3]
 233:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 234:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	/* A save method is being used that requires each task to maintain its
 235:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	own exec return value. */
 236:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	pxTopOfStack--;
 102              		.loc 1 236 0
 103 0044 FB68     		ldr	r3, [r7, #12]
 104 0046 043B     		subs	r3, r3, #4
 105 0048 FB60     		str	r3, [r7, #12]
 237:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	*pxTopOfStack = portINITIAL_EXEC_RETURN;
 106              		.loc 1 237 0
 107 004a FB68     		ldr	r3, [r7, #12]
 108 004c 6FF00202 		mvn	r2, #2
 109 0050 1A60     		str	r2, [r3]
 238:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 239:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
 110              		.loc 1 239 0
 111 0052 FB68     		ldr	r3, [r7, #12]
 112 0054 203B     		subs	r3, r3, #32
 113 0056 FB60     		str	r3, [r7, #12]
 240:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 241:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	return pxTopOfStack;
 114              		.loc 1 241 0
 115 0058 FB68     		ldr	r3, [r7, #12]
 242:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** }
 116              		.loc 1 242 0
 117 005a 1846     		mov	r0, r3
 118 005c 1437     		adds	r7, r7, #20
 119 005e BD46     		mov	sp, r7
 120              		@ sp needed
 121 0060 5DF8047B 		ldr	r7, [sp], #4
 122 0064 7047     		bx	lr
 123              		.cfi_endproc
 124              	.LFE1:
 126 0066 00BF     		.section	.text.prvTaskExitError,"ax",%progbits
 127              		.align	2
 128              		.thumb
 129              		.thumb_func
 131              	prvTaskExitError:
 132              	.LFB2:
 243:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /*-----------------------------------------------------------*/
 244:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 245:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** static void prvTaskExitError( void )
 246:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** {
 133              		.loc 1 246 0
 134              		.cfi_startproc
 135              		@ args = 0, pretend = 0, frame = 0
 136              		@ frame_needed = 1, uses_anonymous_args = 0
 137 0000 80B5     		push	{r7, lr}
 138              	.LCFI3:
 139              		.cfi_def_cfa_offset 8
 140              		.cfi_offset 7, -8
 141              		.cfi_offset 14, -4
 142 0002 00AF     		add	r7, sp, #0
 143              	.LCFI4:
 144              		.cfi_def_cfa_register 7
 247:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	/* A function that implements a task must not exit or attempt to return to
 248:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	its caller as there is nothing to return to.  If a task wants to exit it
 249:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	should instead call vTaskDelete( NULL ).
 250:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 251:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	Artificially force an assert() to be triggered if configASSERT() is
 252:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	defined, then stop here so application writers can catch the error. */
 253:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	configASSERT( uxCriticalNesting == ~0UL );
 145              		.loc 1 253 0
 146 0004 40F20003 		movw	r3, #:lower16:uxCriticalNesting
 147 0008 C0F20003 		movt	r3, #:upper16:uxCriticalNesting
 148 000c 1B68     		ldr	r3, [r3]
 149 000e B3F1FF3F 		cmp	r3, #-1
 150 0012 02D0     		beq	.L4
 151              		.loc 1 253 0 is_stmt 0 discriminator 1
 152 0014 FFF7FEFF 		bl	ulPortSetInterruptMask
 153              	.L5:
 154 0018 FEE7     		b	.L5
 155              	.L4:
 254:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	portDISABLE_INTERRUPTS();
 156              		.loc 1 254 0 is_stmt 1
 157 001a FFF7FEFF 		bl	ulPortSetInterruptMask
 158              	.L6:
 255:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	for( ;; );
 159              		.loc 1 255 0 discriminator 1
 160 001e FEE7     		b	.L6
 161              		.cfi_endproc
 162              	.LFE2:
 164              		.section	.text.SVC_Handler,"ax",%progbits
 165              		.align	2
 166              		.global	SVC_Handler
 167              		.thumb
 168              		.thumb_func
 170              	SVC_Handler:
 171              	.LFB3:
 256:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** }
 257:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /*-----------------------------------------------------------*/
 258:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 259:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** void vPortSVCHandler( void )
 260:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** {
 172              		.loc 1 260 0
 173              		.cfi_startproc
 174              		@ Naked Function: prologue and epilogue provided by programmer.
 175              		@ args = 0, pretend = 0, frame = 0
 176              		@ frame_needed = 1, uses_anonymous_args = 0
 261:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	__asm volatile (
 177              		.loc 1 261 0
 178              	@ 261 "lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c" 1
 179 0000 064B     			ldr	r3, pxCurrentTCBConst2		
 180 0002 1968     		ldr r1, [r3]					
 181 0004 0868     		ldr r0, [r1]					
 182 0006 B0E8F04F 		ldmia r0!, {r4-r11, r14}		
 183 000a 80F30988 		msr psp, r0						
 184 000e BFF36F8F 		isb								
 185 0012 4FF00000 		mov r0, #0 						
 186 0016 80F31188 		msr	basepri, r0					
 187 001a 7047     		bx r14							
 188              										
 189              		.align 2						
 190 001c 00000000 	pxCurrentTCBConst2: .word pxCurrentTCB				
 191              	
 192              	@ 0 "" 2
 262:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 					"	ldr	r3, pxCurrentTCBConst2		\n" /* Restore the context. */
 263:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 					"	ldr r1, [r3]					\n" /* Use pxCurrentTCBConst to get the pxCurrentTCB address. */
 264:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 					"	ldr r0, [r1]					\n" /* The first item in pxCurrentTCB is the task top of stack. */
 265:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 					"	ldmia r0!, {r4-r11, r14}		\n" /* Pop the registers that are not automatically saved on excep
 266:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 					"	msr psp, r0						\n" /* Restore the task stack pointer. */
 267:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 					"	isb								\n"
 268:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 					"	mov r0, #0 						\n"
 269:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 					"	msr	basepri, r0					\n"
 270:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 					"	bx r14							\n"
 271:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 					"									\n"
 272:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 					"	.align 2						\n"
 273:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 					"pxCurrentTCBConst2: .word pxCurrentTCB				\n"
 274:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				);
 275:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** }
 193              		.loc 1 275 0
 194              		.thumb
 195              		.cfi_endproc
 196              	.LFE3:
 198              		.section	.text.prvPortStartFirstTask,"ax",%progbits
 199              		.align	2
 200              		.thumb
 201              		.thumb_func
 203              	prvPortStartFirstTask:
 204              	.LFB4:
 276:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /*-----------------------------------------------------------*/
 277:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 278:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** static void prvPortStartFirstTask( void )
 279:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** {
 205              		.loc 1 279 0
 206              		.cfi_startproc
 207              		@ Naked Function: prologue and epilogue provided by programmer.
 208              		@ args = 0, pretend = 0, frame = 0
 209              		@ frame_needed = 1, uses_anonymous_args = 0
 280:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	__asm volatile(
 210              		.loc 1 280 0
 211              	@ 280 "lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c" 1
 212 0000 0648     		 ldr r0, =0xE000ED08 	
 213 0002 0068     	 ldr r0, [r0] 			
 214 0004 0068     	 ldr r0, [r0] 			
 215 0006 80F30888 	 msr msp, r0			
 216 000a 62B6     	 cpsie i				
 217 000c 61B6     	 cpsie f				
 218 000e BFF34F8F 	 dsb					
 219 0012 BFF36F8F 	 isb					
 220 0016 00DF     	 svc 0					
 221 0018 00BF     	 nop					
 222              	
 223              	@ 0 "" 2
 281:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 					" ldr r0, =0xE000ED08 	\n" /* Use the NVIC offset register to locate the stack. */
 282:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 					" ldr r0, [r0] 			\n"
 283:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 					" ldr r0, [r0] 			\n"
 284:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 					" msr msp, r0			\n" /* Set the msp back to the start of the stack. */
 285:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 					" cpsie i				\n" /* Globally enable interrupts. */
 286:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 					" cpsie f				\n"
 287:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 					" dsb					\n"
 288:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 					" isb					\n"
 289:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 					" svc 0					\n" /* System call to start first task. */
 290:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 					" nop					\n"
 291:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				);
 292:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** }
 224              		.loc 1 292 0
 225              		.thumb
 226              		.cfi_endproc
 227              	.LFE4:
 229 001a 0000     		.section	.text.xPortStartScheduler,"ax",%progbits
 230              		.align	2
 231              		.global	xPortStartScheduler
 232              		.thumb
 233              		.thumb_func
 235              	xPortStartScheduler:
 236              	.LFB5:
 293:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /*-----------------------------------------------------------*/
 294:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 295:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /*
 296:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  * See header file for description.
 297:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  */
 298:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** BaseType_t xPortStartScheduler( void )
 299:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** {
 237              		.loc 1 299 0
 238              		.cfi_startproc
 239              		@ args = 0, pretend = 0, frame = 16
 240              		@ frame_needed = 1, uses_anonymous_args = 0
 241 0000 80B5     		push	{r7, lr}
 242              	.LCFI5:
 243              		.cfi_def_cfa_offset 8
 244              		.cfi_offset 7, -8
 245              		.cfi_offset 14, -4
 246 0002 84B0     		sub	sp, sp, #16
 247              	.LCFI6:
 248              		.cfi_def_cfa_offset 24
 249 0004 00AF     		add	r7, sp, #0
 250              	.LCFI7:
 251              		.cfi_def_cfa_register 7
 252              	.LBB2:
 300:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.
 301:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
 302:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );
 303:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 304:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	#if( configASSERT_DEFINED == 1 )
 305:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	{
 306:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		volatile uint32_t ulOriginalPriority;
 307:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_I
 253              		.loc 1 307 0
 254 0006 4FF46443 		mov	r3, #58368
 255 000a CEF20003 		movt	r3, 57344
 256 000e FB60     		str	r3, [r7, #12]
 308:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		volatile uint8_t ucMaxPriorityValue;
 309:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 310:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		/* Determine the maximum priority from which ISR safe FreeRTOS API
 311:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		functions can be called.  ISR safe functions are those that end in
 312:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
 313:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		ensure interrupt entry is as fast and simple as possible.
 314:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 315:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		Save the interrupt priority value that is about to be clobbered. */
 316:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		ulOriginalPriority = *pucFirstUserPriorityRegister;
 257              		.loc 1 316 0
 258 0010 FB68     		ldr	r3, [r7, #12]
 259 0012 1B78     		ldrb	r3, [r3]
 260 0014 DBB2     		uxtb	r3, r3
 261 0016 BB60     		str	r3, [r7, #8]
 317:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 318:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		/* Determine the number of priority bits available.  First write to all
 319:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		possible bits. */
 320:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 262              		.loc 1 320 0
 263 0018 FB68     		ldr	r3, [r7, #12]
 264 001a FF22     		movs	r2, #255
 265 001c 1A70     		strb	r2, [r3]
 321:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 322:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		/* Read the value back to see how many bits stuck. */
 323:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 266              		.loc 1 323 0
 267 001e FB68     		ldr	r3, [r7, #12]
 268 0020 1B78     		ldrb	r3, [r3]
 269 0022 DBB2     		uxtb	r3, r3
 270 0024 FB71     		strb	r3, [r7, #7]
 324:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 325:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		/* Use the same mask on the maximum system call priority. */
 326:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 271              		.loc 1 326 0
 272 0026 FB79     		ldrb	r3, [r7, #7]
 273 0028 DBB2     		uxtb	r3, r3
 274 002a 03F05003 		and	r3, r3, #80
 275 002e DAB2     		uxtb	r2, r3
 276 0030 40F20003 		movw	r3, #:lower16:ucMaxSysCallPriority
 277 0034 C0F20003 		movt	r3, #:upper16:ucMaxSysCallPriority
 278 0038 1A70     		strb	r2, [r3]
 327:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 328:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		/* Calculate the maximum acceptable priority group value for the number
 329:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		of bits read back. */
 330:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 279              		.loc 1 330 0
 280 003a 40F20003 		movw	r3, #:lower16:ulMaxPRIGROUPValue
 281 003e C0F20003 		movt	r3, #:upper16:ulMaxPRIGROUPValue
 282 0042 0722     		movs	r2, #7
 283 0044 1A60     		str	r2, [r3]
 331:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 284              		.loc 1 331 0
 285 0046 0FE0     		b	.L10
 286              	.L11:
 332:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		{
 333:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			ulMaxPRIGROUPValue--;
 287              		.loc 1 333 0
 288 0048 40F20003 		movw	r3, #:lower16:ulMaxPRIGROUPValue
 289 004c C0F20003 		movt	r3, #:upper16:ulMaxPRIGROUPValue
 290 0050 1B68     		ldr	r3, [r3]
 291 0052 5A1E     		subs	r2, r3, #1
 292 0054 40F20003 		movw	r3, #:lower16:ulMaxPRIGROUPValue
 293 0058 C0F20003 		movt	r3, #:upper16:ulMaxPRIGROUPValue
 294 005c 1A60     		str	r2, [r3]
 334:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 295              		.loc 1 334 0
 296 005e FB79     		ldrb	r3, [r7, #7]
 297 0060 DBB2     		uxtb	r3, r3
 298 0062 5B00     		lsls	r3, r3, #1
 299 0064 DBB2     		uxtb	r3, r3
 300 0066 FB71     		strb	r3, [r7, #7]
 301              	.L10:
 331:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 302              		.loc 1 331 0 discriminator 1
 303 0068 FB79     		ldrb	r3, [r7, #7]
 304 006a DBB2     		uxtb	r3, r3
 305 006c DBB2     		uxtb	r3, r3
 306 006e 5BB2     		sxtb	r3, r3
 307 0070 002B     		cmp	r3, #0
 308 0072 E9DB     		blt	.L11
 335:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		}
 336:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 337:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		/* Shift the priority group value back to its position within the AIRCR
 338:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		register. */
 339:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 309              		.loc 1 339 0
 310 0074 40F20003 		movw	r3, #:lower16:ulMaxPRIGROUPValue
 311 0078 C0F20003 		movt	r3, #:upper16:ulMaxPRIGROUPValue
 312 007c 1B68     		ldr	r3, [r3]
 313 007e 1A02     		lsls	r2, r3, #8
 314 0080 40F20003 		movw	r3, #:lower16:ulMaxPRIGROUPValue
 315 0084 C0F20003 		movt	r3, #:upper16:ulMaxPRIGROUPValue
 316 0088 1A60     		str	r2, [r3]
 340:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 317              		.loc 1 340 0
 318 008a 40F20003 		movw	r3, #:lower16:ulMaxPRIGROUPValue
 319 008e C0F20003 		movt	r3, #:upper16:ulMaxPRIGROUPValue
 320 0092 1B68     		ldr	r3, [r3]
 321 0094 03F4E062 		and	r2, r3, #1792
 322 0098 40F20003 		movw	r3, #:lower16:ulMaxPRIGROUPValue
 323 009c C0F20003 		movt	r3, #:upper16:ulMaxPRIGROUPValue
 324 00a0 1A60     		str	r2, [r3]
 341:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 342:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		/* Restore the clobbered interrupt priority register to its original
 343:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		value. */
 344:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		*pucFirstUserPriorityRegister = ulOriginalPriority;
 325              		.loc 1 344 0
 326 00a2 BB68     		ldr	r3, [r7, #8]
 327 00a4 DAB2     		uxtb	r2, r3
 328 00a6 FB68     		ldr	r3, [r7, #12]
 329 00a8 1A70     		strb	r2, [r3]
 330              	.LBE2:
 345:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	}
 346:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	#endif /* conifgASSERT_DEFINED */
 347:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 348:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	/* Make PendSV and SysTick the lowest priority interrupts. */
 349:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 331              		.loc 1 349 0
 332 00aa 4EF62053 		movw	r3, #60704
 333 00ae CEF20003 		movt	r3, 57344
 334 00b2 4EF62052 		movw	r2, #60704
 335 00b6 CEF20002 		movt	r2, 57344
 336 00ba 1268     		ldr	r2, [r2]
 337 00bc 42F47002 		orr	r2, r2, #15728640
 338 00c0 1A60     		str	r2, [r3]
 350:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 339              		.loc 1 350 0
 340 00c2 4EF62053 		movw	r3, #60704
 341 00c6 CEF20003 		movt	r3, 57344
 342 00ca 4EF62052 		movw	r2, #60704
 343 00ce CEF20002 		movt	r2, 57344
 344 00d2 1268     		ldr	r2, [r2]
 345 00d4 42F07042 		orr	r2, r2, #-268435456
 346 00d8 1A60     		str	r2, [r3]
 351:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 352:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	/* Start the timer that generates the tick ISR.  Interrupts are disabled
 353:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	here already. */
 354:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	vPortSetupTimerInterrupt();
 347              		.loc 1 354 0
 348 00da FFF7FEFF 		bl	vPortSetupTimerInterrupt
 355:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 356:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	/* Initialise the critical nesting count ready for the first task. */
 357:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	uxCriticalNesting = 0;
 349              		.loc 1 357 0
 350 00de 40F20003 		movw	r3, #:lower16:uxCriticalNesting
 351 00e2 C0F20003 		movt	r3, #:upper16:uxCriticalNesting
 352 00e6 0022     		movs	r2, #0
 353 00e8 1A60     		str	r2, [r3]
 358:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 359:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	/* Ensure the VFP is enabled - it should be anyway. */
 360:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	vPortEnableVFP();
 354              		.loc 1 360 0
 355 00ea FFF7FEFF 		bl	vPortEnableVFP
 361:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 362:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	/* Lazy save always. */
 363:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 356              		.loc 1 363 0
 357 00ee 4EF63473 		movw	r3, #61236
 358 00f2 CEF20003 		movt	r3, 57344
 359 00f6 4EF63472 		movw	r2, #61236
 360 00fa CEF20002 		movt	r2, 57344
 361 00fe 1268     		ldr	r2, [r2]
 362 0100 42F04042 		orr	r2, r2, #-1073741824
 363 0104 1A60     		str	r2, [r3]
 364:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 365:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	/* Start the first task. */
 366:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	prvPortStartFirstTask();
 364              		.loc 1 366 0
 365 0106 FFF7FEFF 		bl	prvPortStartFirstTask
 367:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 368:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	/* Should never get here as the tasks will now be executing!  Call the task
 369:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	exit error function to prevent compiler warnings about a static function
 370:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	not being called in the case that the application writer overrides this
 371:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	functionality by defining configTASK_RETURN_ADDRESS. */
 372:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	prvTaskExitError();
 366              		.loc 1 372 0
 367 010a FFF7FEFF 		bl	prvTaskExitError
 373:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 374:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	/* Should not get here! */
 375:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	return 0;
 368              		.loc 1 375 0
 369 010e 0023     		movs	r3, #0
 376:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** }
 370              		.loc 1 376 0
 371 0110 1846     		mov	r0, r3
 372 0112 1037     		adds	r7, r7, #16
 373 0114 BD46     		mov	sp, r7
 374              		@ sp needed
 375 0116 80BD     		pop	{r7, pc}
 376              		.cfi_endproc
 377              	.LFE5:
 379              		.section	.text.vPortEndScheduler,"ax",%progbits
 380              		.align	2
 381              		.global	vPortEndScheduler
 382              		.thumb
 383              		.thumb_func
 385              	vPortEndScheduler:
 386              	.LFB6:
 377:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /*-----------------------------------------------------------*/
 378:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 379:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** void vPortEndScheduler( void )
 380:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** {
 387              		.loc 1 380 0
 388              		.cfi_startproc
 389              		@ args = 0, pretend = 0, frame = 0
 390              		@ frame_needed = 1, uses_anonymous_args = 0
 391 0000 80B5     		push	{r7, lr}
 392              	.LCFI8:
 393              		.cfi_def_cfa_offset 8
 394              		.cfi_offset 7, -8
 395              		.cfi_offset 14, -4
 396 0002 00AF     		add	r7, sp, #0
 397              	.LCFI9:
 398              		.cfi_def_cfa_register 7
 381:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	/* Not implemented in ports where there is nothing to return to.
 382:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	Artificially force an assert. */
 383:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	configASSERT( uxCriticalNesting == 1000UL );
 399              		.loc 1 383 0
 400 0004 40F20003 		movw	r3, #:lower16:uxCriticalNesting
 401 0008 C0F20003 		movt	r3, #:upper16:uxCriticalNesting
 402 000c 1B68     		ldr	r3, [r3]
 403 000e B3F57A7F 		cmp	r3, #1000
 404 0012 02D0     		beq	.L13
 405              		.loc 1 383 0 is_stmt 0 discriminator 1
 406 0014 FFF7FEFF 		bl	ulPortSetInterruptMask
 407              	.L15:
 408 0018 FEE7     		b	.L15
 409              	.L13:
 384:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** }
 410              		.loc 1 384 0 is_stmt 1
 411 001a 80BD     		pop	{r7, pc}
 412              		.cfi_endproc
 413              	.LFE6:
 415              		.section	.text.vPortYield,"ax",%progbits
 416              		.align	2
 417              		.global	vPortYield
 418              		.thumb
 419              		.thumb_func
 421              	vPortYield:
 422              	.LFB7:
 385:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /*-----------------------------------------------------------*/
 386:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 387:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** void vPortYield( void )
 388:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** {
 423              		.loc 1 388 0
 424              		.cfi_startproc
 425              		@ args = 0, pretend = 0, frame = 0
 426              		@ frame_needed = 1, uses_anonymous_args = 0
 427              		@ link register save eliminated.
 428 0000 80B4     		push	{r7}
 429              	.LCFI10:
 430              		.cfi_def_cfa_offset 4
 431              		.cfi_offset 7, -4
 432 0002 00AF     		add	r7, sp, #0
 433              	.LCFI11:
 434              		.cfi_def_cfa_register 7
 389:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	/* Set a PendSV to request a context switch. */
 390:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 435              		.loc 1 390 0
 436 0004 4EF60453 		movw	r3, #60676
 437 0008 CEF20003 		movt	r3, 57344
 438 000c 4FF08052 		mov	r2, #268435456
 439 0010 1A60     		str	r2, [r3]
 391:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 392:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	/* Barriers are normally not required but do ensure the code is completely
 393:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	within the specified behaviour for the architecture. */
 394:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	__asm volatile( "dsb" );
 440              		.loc 1 394 0
 441              	@ 394 "lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c" 1
 442 0012 BFF34F8F 		dsb
 443              	@ 0 "" 2
 395:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	__asm volatile( "isb" );
 444              		.loc 1 395 0
 445              	@ 395 "lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c" 1
 446 0016 BFF36F8F 		isb
 447              	@ 0 "" 2
 396:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** }
 448              		.loc 1 396 0
 449              		.thumb
 450 001a BD46     		mov	sp, r7
 451              		@ sp needed
 452 001c 5DF8047B 		ldr	r7, [sp], #4
 453 0020 7047     		bx	lr
 454              		.cfi_endproc
 455              	.LFE7:
 457 0022 00BF     		.section	.text.vPortEnterCritical,"ax",%progbits
 458              		.align	2
 459              		.global	vPortEnterCritical
 460              		.thumb
 461              		.thumb_func
 463              	vPortEnterCritical:
 464              	.LFB8:
 397:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /*-----------------------------------------------------------*/
 398:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 399:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** void vPortEnterCritical( void )
 400:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** {
 465              		.loc 1 400 0
 466              		.cfi_startproc
 467              		@ args = 0, pretend = 0, frame = 0
 468              		@ frame_needed = 1, uses_anonymous_args = 0
 469 0000 80B5     		push	{r7, lr}
 470              	.LCFI12:
 471              		.cfi_def_cfa_offset 8
 472              		.cfi_offset 7, -8
 473              		.cfi_offset 14, -4
 474 0002 00AF     		add	r7, sp, #0
 475              	.LCFI13:
 476              		.cfi_def_cfa_register 7
 401:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	portDISABLE_INTERRUPTS();
 477              		.loc 1 401 0
 478 0004 FFF7FEFF 		bl	ulPortSetInterruptMask
 402:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	uxCriticalNesting++;
 479              		.loc 1 402 0
 480 0008 40F20003 		movw	r3, #:lower16:uxCriticalNesting
 481 000c C0F20003 		movt	r3, #:upper16:uxCriticalNesting
 482 0010 1B68     		ldr	r3, [r3]
 483 0012 5A1C     		adds	r2, r3, #1
 484 0014 40F20003 		movw	r3, #:lower16:uxCriticalNesting
 485 0018 C0F20003 		movt	r3, #:upper16:uxCriticalNesting
 486 001c 1A60     		str	r2, [r3]
 403:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	__asm volatile( "dsb" );
 487              		.loc 1 403 0
 488              	@ 403 "lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c" 1
 489 001e BFF34F8F 		dsb
 490              	@ 0 "" 2
 404:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	__asm volatile( "isb" );
 491              		.loc 1 404 0
 492              	@ 404 "lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c" 1
 493 0022 BFF36F8F 		isb
 494              	@ 0 "" 2
 405:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	
 406:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	/* This is not the interrupt safe version of the enter critical function so
 407:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	assert() if it is being called from an interrupt context.  Only API 
 408:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	functions that end in "FromISR" can be used in an interrupt.  Only assert if
 409:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	the critical nesting count is 1 to protect against recursive calls if the
 410:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	assert function also uses a critical section. */
 411:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	if( uxCriticalNesting == 1 )
 495              		.loc 1 411 0
 496              		.thumb
 497 0026 40F20003 		movw	r3, #:lower16:uxCriticalNesting
 498 002a C0F20003 		movt	r3, #:upper16:uxCriticalNesting
 499 002e 1B68     		ldr	r3, [r3]
 500 0030 012B     		cmp	r3, #1
 501 0032 0BD1     		bne	.L17
 412:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	{
 413:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 502              		.loc 1 413 0
 503 0034 4EF60453 		movw	r3, #60676
 504 0038 CEF20003 		movt	r3, 57344
 505 003c 1B68     		ldr	r3, [r3]
 506 003e 03F01F03 		and	r3, r3, #31
 507 0042 002B     		cmp	r3, #0
 508 0044 02D0     		beq	.L17
 509              		.loc 1 413 0 is_stmt 0 discriminator 1
 510 0046 FFF7FEFF 		bl	ulPortSetInterruptMask
 511              	.L19:
 512 004a FEE7     		b	.L19
 513              	.L17:
 414:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	}
 415:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** }
 514              		.loc 1 415 0 is_stmt 1
 515 004c 80BD     		pop	{r7, pc}
 516              		.cfi_endproc
 517              	.LFE8:
 519 004e 00BF     		.section	.text.vPortExitCritical,"ax",%progbits
 520              		.align	2
 521              		.global	vPortExitCritical
 522              		.thumb
 523              		.thumb_func
 525              	vPortExitCritical:
 526              	.LFB9:
 416:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /*-----------------------------------------------------------*/
 417:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 418:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** void vPortExitCritical( void )
 419:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** {
 527              		.loc 1 419 0
 528              		.cfi_startproc
 529              		@ args = 0, pretend = 0, frame = 0
 530              		@ frame_needed = 1, uses_anonymous_args = 0
 531 0000 80B5     		push	{r7, lr}
 532              	.LCFI14:
 533              		.cfi_def_cfa_offset 8
 534              		.cfi_offset 7, -8
 535              		.cfi_offset 14, -4
 536 0002 00AF     		add	r7, sp, #0
 537              	.LCFI15:
 538              		.cfi_def_cfa_register 7
 420:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	configASSERT( uxCriticalNesting );
 539              		.loc 1 420 0
 540 0004 40F20003 		movw	r3, #:lower16:uxCriticalNesting
 541 0008 C0F20003 		movt	r3, #:upper16:uxCriticalNesting
 542 000c 1B68     		ldr	r3, [r3]
 543 000e 002B     		cmp	r3, #0
 544 0010 02D1     		bne	.L21
 545              		.loc 1 420 0 is_stmt 0 discriminator 1
 546 0012 FFF7FEFF 		bl	ulPortSetInterruptMask
 547              	.L22:
 548 0016 FEE7     		b	.L22
 549              	.L21:
 421:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	uxCriticalNesting--;
 550              		.loc 1 421 0 is_stmt 1
 551 0018 40F20003 		movw	r3, #:lower16:uxCriticalNesting
 552 001c C0F20003 		movt	r3, #:upper16:uxCriticalNesting
 553 0020 1B68     		ldr	r3, [r3]
 554 0022 5A1E     		subs	r2, r3, #1
 555 0024 40F20003 		movw	r3, #:lower16:uxCriticalNesting
 556 0028 C0F20003 		movt	r3, #:upper16:uxCriticalNesting
 557 002c 1A60     		str	r2, [r3]
 422:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	if( uxCriticalNesting == 0 )
 558              		.loc 1 422 0
 559 002e 40F20003 		movw	r3, #:lower16:uxCriticalNesting
 560 0032 C0F20003 		movt	r3, #:upper16:uxCriticalNesting
 561 0036 1B68     		ldr	r3, [r3]
 562 0038 002B     		cmp	r3, #0
 563 003a 02D1     		bne	.L20
 423:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	{
 424:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		portENABLE_INTERRUPTS();
 564              		.loc 1 424 0
 565 003c 0020     		movs	r0, #0
 566 003e FFF7FEFF 		bl	vPortClearInterruptMask
 567              	.L20:
 425:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	}
 426:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** }
 568              		.loc 1 426 0
 569 0042 80BD     		pop	{r7, pc}
 570              		.cfi_endproc
 571              	.LFE9:
 573              		.section	.text.ulPortSetInterruptMask,"ax",%progbits
 574              		.align	2
 575              		.global	ulPortSetInterruptMask
 576              		.thumb
 577              		.thumb_func
 579              	ulPortSetInterruptMask:
 580              	.LFB10:
 427:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /*-----------------------------------------------------------*/
 428:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 429:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** __attribute__(( naked )) uint32_t ulPortSetInterruptMask( void )
 430:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** {
 581              		.loc 1 430 0
 582              		.cfi_startproc
 583              		@ Naked Function: prologue and epilogue provided by programmer.
 584              		@ args = 0, pretend = 0, frame = 0
 585              		@ frame_needed = 1, uses_anonymous_args = 0
 431:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	__asm volatile														\
 586              		.loc 1 431 0
 587              	@ 431 "lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c" 1
 588 0000 EFF31180 			mrs r0, basepri											
 589 0004 4FF05001 		mov r1, #80												
 590 0008 81F31188 		msr basepri, r1											
 591 000c 7047     		bx lr													
 592              	
 593              	@ 0 "" 2
 432:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	(																	\
 433:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		"	mrs r0, basepri											\n" \
 434:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		"	mov r1, %0												\n"	\
 435:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		"	msr basepri, r1											\n" \
 436:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		"	bx lr													\n" \
 437:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		:: "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "r0", "r1"	\
 438:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	);
 439:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 440:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	/* This return will not be reached but is necessary to prevent compiler
 441:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	warnings. */
 442:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	return 0;
 594              		.loc 1 442 0
 595              		.thumb
 596 000e 0023     		movs	r3, #0
 443:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** }
 597              		.loc 1 443 0
 598 0010 1846     		mov	r0, r3
 599              		.cfi_endproc
 600              	.LFE10:
 602 0012 00BF     		.section	.text.vPortClearInterruptMask,"ax",%progbits
 603              		.align	2
 604              		.global	vPortClearInterruptMask
 605              		.thumb
 606              		.thumb_func
 608              	vPortClearInterruptMask:
 609              	.LFB11:
 444:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /*-----------------------------------------------------------*/
 445:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 446:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** __attribute__(( naked )) void vPortClearInterruptMask( uint32_t ulNewMaskValue )
 447:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** {
 610              		.loc 1 447 0
 611              		.cfi_startproc
 612              		@ Naked Function: prologue and epilogue provided by programmer.
 613              		@ args = 0, pretend = 0, frame = 0
 614              		@ frame_needed = 1, uses_anonymous_args = 0
 448:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	__asm volatile													\
 615              		.loc 1 448 0
 616              	@ 448 "lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c" 1
 617 0000 80F31188 			msr basepri, r0										
 618 0004 7047     		bx lr												
 619              	
 620              	@ 0 "" 2
 449:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	(																\
 450:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		"	msr basepri, r0										\n"	\
 451:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		"	bx lr												\n" \
 452:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		:::"r0"														\
 453:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	);
 454:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 455:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	/* Just to avoid compiler warnings. */
 456:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	( void ) ulNewMaskValue;
 457:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** }
 621              		.loc 1 457 0
 622              		.thumb
 623              		.cfi_endproc
 624              	.LFE11:
 626 0006 00BF     		.section	.text.PendSV_Handler,"ax",%progbits
 627              		.align	2
 628              		.global	PendSV_Handler
 629              		.thumb
 630              		.thumb_func
 632              	PendSV_Handler:
 633              	.LFB12:
 458:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /*-----------------------------------------------------------*/
 459:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 460:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** void xPortPendSVHandler( void )
 461:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** {
 634              		.loc 1 461 0
 635              		.cfi_startproc
 636              		@ Naked Function: prologue and epilogue provided by programmer.
 637              		@ args = 0, pretend = 0, frame = 0
 638              		@ frame_needed = 1, uses_anonymous_args = 0
 462:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	/* This is a naked function. */
 463:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 464:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	__asm volatile
 639              		.loc 1 464 0
 640              	@ 464 "lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c" 1
 641 0000 EFF30980 			mrs r0, psp							
 642 0004 BFF36F8F 		isb									
 643              											
 644 0008 124B     		ldr	r3, pxCurrentTCBConst			
 645 000a 1A68     		ldr	r2, [r3]						
 646              											
 647 000c 1EF0100F 		tst r14, #0x10						
 648 0010 08BF     		it eq								
 649 0012 20ED108A 		vstmdbeq r0!, {s16-s31}				
 650              											
 651 0016 20E9F04F 		stmdb r0!, {r4-r11, r14}			
 652              											
 653 001a 1060     		str r0, [r2]						
 654              											
 655 001c 4DF8043D 		stmdb sp!, {r3}						
 656 0020 4FF05000 		mov r0, #80 							
 657 0024 80F31188 		msr basepri, r0						
 658 0028 FFF7FEFF 		bl vTaskSwitchContext				
 659 002c 4FF00000 		mov r0, #0							
 660 0030 80F31188 		msr basepri, r0						
 661 0034 08BC     		ldmia sp!, {r3}						
 662              											
 663 0036 1968     		ldr r1, [r3]						
 664 0038 0868     		ldr r0, [r1]						
 665              											
 666 003a B0E8F04F 		ldmia r0!, {r4-r11, r14}			
 667              											
 668 003e 1EF0100F 		tst r14, #0x10						
 669 0042 08BF     		it eq								
 670 0044 B0EC108A 		vldmiaeq r0!, {s16-s31}				
 671              											
 672 0048 80F30988 		msr psp, r0							
 673 004c BFF36F8F 		isb									
 674              											
 675              											
 676 0050 7047     		bx r14								
 677              											
 678 0052 00BF     		.align 2							
 679 0054 00000000 	pxCurrentTCBConst: .word pxCurrentTCB	
 680              	
 681              	@ 0 "" 2
 465:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	(
 466:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"	mrs r0, psp							\n"
 467:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"	isb									\n"
 468:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"										\n"
 469:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"	ldr	r3, pxCurrentTCBConst			\n" /* Get the location of the current TCB. */
 470:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"	ldr	r2, [r3]						\n"
 471:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"										\n"
 472:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"	tst r14, #0x10						\n" /* Is the task using the FPU context?  If so, push high vfp registers. *
 473:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"	it eq								\n"
 474:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"	vstmdbeq r0!, {s16-s31}				\n"
 475:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"										\n"
 476:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"	stmdb r0!, {r4-r11, r14}			\n" /* Save the core registers. */
 477:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"										\n"
 478:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"	str r0, [r2]						\n" /* Save the new top of stack into the first member of the TCB. */
 479:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"										\n"
 480:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"	stmdb sp!, {r3}						\n"
 481:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"	mov r0, %0 							\n"
 482:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"	msr basepri, r0						\n"
 483:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"	bl vTaskSwitchContext				\n"
 484:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"	mov r0, #0							\n"
 485:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"	msr basepri, r0						\n"
 486:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"	ldmia sp!, {r3}						\n"
 487:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"										\n"
 488:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"	ldr r1, [r3]						\n" /* The first item in pxCurrentTCB is the task top of stack. */
 489:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"	ldr r0, [r1]						\n"
 490:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"										\n"
 491:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"	ldmia r0!, {r4-r11, r14}			\n" /* Pop the core registers. */
 492:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"										\n"
 493:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"	tst r14, #0x10						\n" /* Is the task using the FPU context?  If so, pop the high vfp registers
 494:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"	it eq								\n"
 495:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"	vldmiaeq r0!, {s16-s31}				\n"
 496:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"										\n"
 497:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"	msr psp, r0							\n"
 498:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"	isb									\n"
 499:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"										\n"
 500:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	#ifdef WORKAROUND_PMU_CM001 /* XMC4000 specific errata workaround. */
 501:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		#if WORKAROUND_PMU_CM001 == 1
 502:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"			push { r14 }				\n"
 503:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"			pop { pc }					\n"
 504:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		#endif
 505:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	#endif
 506:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"										\n"
 507:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"	bx r14								\n"
 508:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"										\n"
 509:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"	.align 2							\n"
 510:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	"pxCurrentTCBConst: .word pxCurrentTCB	\n"
 511:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
 512:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	);
 513:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** }
 682              		.loc 1 513 0
 683              		.thumb
 684              		.cfi_endproc
 685              	.LFE12:
 687              		.section	.text.SysTick_Handler,"ax",%progbits
 688              		.align	2
 689              		.global	SysTick_Handler
 690              		.thumb
 691              		.thumb_func
 693              	SysTick_Handler:
 694              	.LFB13:
 514:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /*-----------------------------------------------------------*/
 515:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 516:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** void xPortSysTickHandler( void )
 517:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** {
 695              		.loc 1 517 0
 696              		.cfi_startproc
 697              		@ args = 0, pretend = 0, frame = 0
 698              		@ frame_needed = 1, uses_anonymous_args = 0
 699 0000 80B5     		push	{r7, lr}
 700              	.LCFI16:
 701              		.cfi_def_cfa_offset 8
 702              		.cfi_offset 7, -8
 703              		.cfi_offset 14, -4
 704 0002 00AF     		add	r7, sp, #0
 705              	.LCFI17:
 706              		.cfi_def_cfa_register 7
 518:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
 519:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	executes all interrupts must be unmasked.  There is therefore no need to
 520:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	save and then restore the interrupt mask value as its value is already
 521:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	known. */
 522:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	( void ) portSET_INTERRUPT_MASK_FROM_ISR();
 707              		.loc 1 522 0
 708 0004 FFF7FEFF 		bl	ulPortSetInterruptMask
 523:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	{
 524:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		/* Increment the RTOS tick. */
 525:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		if( xTaskIncrementTick() != pdFALSE )
 709              		.loc 1 525 0
 710 0008 FFF7FEFF 		bl	xTaskIncrementTick
 711 000c 0346     		mov	r3, r0
 712 000e 002B     		cmp	r3, #0
 713 0010 06D0     		beq	.L29
 526:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		{
 527:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			/* A context switch is required.  Context switching is performed in
 528:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			the PendSV interrupt.  Pend the PendSV interrupt. */
 529:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 714              		.loc 1 529 0
 715 0012 4EF60453 		movw	r3, #60676
 716 0016 CEF20003 		movt	r3, 57344
 717 001a 4FF08052 		mov	r2, #268435456
 718 001e 1A60     		str	r2, [r3]
 719              	.L29:
 530:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		}
 531:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	}
 532:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
 720              		.loc 1 532 0
 721 0020 0020     		movs	r0, #0
 722 0022 FFF7FEFF 		bl	vPortClearInterruptMask
 533:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** }
 723              		.loc 1 533 0
 724 0026 80BD     		pop	{r7, pc}
 725              		.cfi_endproc
 726              	.LFE13:
 728              		.section	.text.vPortSetupTimerInterrupt,"ax",%progbits
 729              		.align	2
 730              		.weak	vPortSetupTimerInterrupt
 731              		.thumb
 732              		.thumb_func
 734              	vPortSetupTimerInterrupt:
 735              	.LFB14:
 534:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /*-----------------------------------------------------------*/
 535:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 536:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #if configUSE_TICKLESS_IDLE == 1
 537:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 538:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	__attribute__((weak)) void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
 539:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	{
 540:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	uint32_t ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickDecrements, ulSysTickCTRL;
 541:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	TickType_t xModifiableIdleTime;
 542:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 543:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		/* Make sure the SysTick reload value does not overflow the counter. */
 544:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
 545:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		{
 546:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
 547:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		}
 548:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 549:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		/* Stop the SysTick momentarily.  The time the SysTick is stopped for
 550:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		is accounted for as best it can be, but using the tickless mode will
 551:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		inevitably result in some tiny drift of the time maintained by the
 552:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		kernel with respect to calendar time. */
 553:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		portNVIC_SYSTICK_CTRL_REG &= ~portNVIC_SYSTICK_ENABLE_BIT;
 554:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 555:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		/* Calculate the reload value required to wait xExpectedIdleTime
 556:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		tick periods.  -1 is used because this code will execute part way
 557:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		through one of the tick periods. */
 558:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		ulReloadValue = portNVIC_SYSTICK_CURRENT_VALUE_REG + ( ulTimerCountsForOneTick * ( xExpectedIdleT
 559:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		if( ulReloadValue > ulStoppedTimerCompensation )
 560:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		{
 561:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			ulReloadValue -= ulStoppedTimerCompensation;
 562:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		}
 563:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 564:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		/* Enter a critical section but don't use the taskENTER_CRITICAL()
 565:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		method as that will mask interrupts that should exit sleep mode. */
 566:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		__asm volatile( "cpsid i" );
 567:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 568:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		/* If a context switch is pending or a task is waiting for the scheduler
 569:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		to be unsuspended then abandon the low power entry. */
 570:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		if( eTaskConfirmSleepModeStatus() == eAbortSleep )
 571:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		{
 572:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			/* Restart from whatever is left in the count register to complete
 573:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			this tick period. */
 574:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			portNVIC_SYSTICK_LOAD_REG = portNVIC_SYSTICK_CURRENT_VALUE_REG;
 575:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 576:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			/* Restart SysTick. */
 577:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
 578:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 579:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			/* Reset the reload register to the value required for normal tick
 580:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			periods. */
 581:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
 582:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 583:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			/* Re-enable interrupts - see comments above the cpsid instruction()
 584:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			above. */
 585:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			__asm volatile( "cpsie i" );
 586:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		}
 587:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		else
 588:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		{
 589:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			/* Set the new reload value. */
 590:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
 591:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 592:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			/* Clear the SysTick count flag and set the count value back to
 593:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			zero. */
 594:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 595:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 596:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			/* Restart SysTick. */
 597:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
 598:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 599:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			/* Sleep until something happens.  configPRE_SLEEP_PROCESSING() can
 600:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			set its parameter to 0 to indicate that its implementation contains
 601:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			its own wait for interrupt or wait for event instruction, and so wfi
 602:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			should not be executed again.  However, the original expected idle
 603:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			time variable must remain unmodified, so a copy is taken. */
 604:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			xModifiableIdleTime = xExpectedIdleTime;
 605:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
 606:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			if( xModifiableIdleTime > 0 )
 607:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			{
 608:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				__asm volatile( "dsb" );
 609:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				__asm volatile( "wfi" );
 610:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				__asm volatile( "isb" );
 611:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			}
 612:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			configPOST_SLEEP_PROCESSING( xExpectedIdleTime );
 613:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 614:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			/* Stop SysTick.  Again, the time the SysTick is stopped for is
 615:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			accounted for as best it can be, but using the tickless mode will
 616:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			inevitably result in some tiny drift of the time maintained by the
 617:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			kernel with respect to calendar time. */
 618:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			ulSysTickCTRL = portNVIC_SYSTICK_CTRL_REG;
 619:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			portNVIC_SYSTICK_CTRL_REG = ( ulSysTickCTRL & ~portNVIC_SYSTICK_ENABLE_BIT );
 620:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 621:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			/* Re-enable interrupts - see comments above the cpsid instruction()
 622:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			above. */
 623:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			__asm volatile( "cpsie i" );
 624:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 625:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			if( ( ulSysTickCTRL & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
 626:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			{
 627:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				uint32_t ulCalculatedLoadValue;
 628:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 629:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				/* The tick interrupt has already executed, and the SysTick
 630:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				count reloaded with ulReloadValue.  Reset the
 631:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				portNVIC_SYSTICK_LOAD_REG with whatever remains of this tick
 632:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				period. */
 633:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portNVIC_SYSTICK_
 634:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 635:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				/* Don't allow a tiny value, or values that have somehow
 636:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				underflowed because the post sleep hook did something
 637:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				that took too long. */
 638:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				if( ( ulCalculatedLoadValue < ulStoppedTimerCompensation ) || ( ulCalculatedLoadValue > ulTimer
 639:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				{
 640:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 					ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL );
 641:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				}
 642:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 643:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				portNVIC_SYSTICK_LOAD_REG = ulCalculatedLoadValue;
 644:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 645:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				/* The tick interrupt handler will already have pended the tick
 646:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				processing in the kernel.  As the pending tick will be
 647:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				processed as soon as this function exits, the tick value
 648:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				maintained by the tick is stepped forward by one less than the
 649:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				time spent waiting. */
 650:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
 651:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			}
 652:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			else
 653:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			{
 654:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				/* Something other than the tick interrupt ended the sleep.
 655:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				Work out how long the sleep lasted rounded to complete tick
 656:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				periods (not the ulReload value which accounted for part
 657:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				ticks). */
 658:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				ulCompletedSysTickDecrements = ( xExpectedIdleTime * ulTimerCountsForOneTick ) - portNVIC_SYSTI
 659:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 660:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				/* How many complete tick periods passed while the processor
 661:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				was waiting? */
 662:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				ulCompleteTickPeriods = ulCompletedSysTickDecrements / ulTimerCountsForOneTick;
 663:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 664:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				/* The reload value is set to whatever fraction of a single tick
 665:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				period remains. */
 666:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				portNVIC_SYSTICK_LOAD_REG = ( ( ulCompleteTickPeriods + 1 ) * ulTimerCountsForOneTick ) - ulCom
 667:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			}
 668:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 669:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			/* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD_REG
 670:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			again, then set portNVIC_SYSTICK_LOAD_REG back to its standard
 671:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			value.  The critical section is used to ensure the tick interrupt
 672:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			can only execute once in the case that the reload register is near
 673:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			zero. */
 674:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 675:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			portENTER_CRITICAL();
 676:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			{
 677:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
 678:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				vTaskStepTick( ulCompleteTickPeriods );
 679:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 				portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
 680:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			}
 681:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			portEXIT_CRITICAL();
 682:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		}
 683:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	}
 684:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 685:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #endif /* #if configUSE_TICKLESS_IDLE */
 686:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /*-----------------------------------------------------------*/
 687:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 688:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /*
 689:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  * Setup the systick timer to generate the tick interrupts at the required
 690:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  * frequency.
 691:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c ****  */
 692:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** __attribute__(( weak )) void vPortSetupTimerInterrupt( void )
 693:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** {
 736              		.loc 1 693 0
 737              		.cfi_startproc
 738              		@ args = 0, pretend = 0, frame = 0
 739              		@ frame_needed = 1, uses_anonymous_args = 0
 740              		@ link register save eliminated.
 741 0000 80B4     		push	{r7}
 742              	.LCFI18:
 743              		.cfi_def_cfa_offset 4
 744              		.cfi_offset 7, -4
 745 0002 00AF     		add	r7, sp, #0
 746              	.LCFI19:
 747              		.cfi_def_cfa_register 7
 694:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	/* Calculate the constants required to configure the tick interrupt. */
 695:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	#if configUSE_TICKLESS_IDLE == 1
 696:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	{
 697:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
 698:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
 699:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOC
 700:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	}
 701:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	#endif /* configUSE_TICKLESS_IDLE */
 702:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 703:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	/* Configure SysTick to interrupt at the requested rate. */
 704:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 748              		.loc 1 704 0
 749 0004 4EF21403 		movw	r3, #57364
 750 0008 CEF20003 		movt	r3, 57344
 751 000c 40F20002 		movw	r2, #:lower16:SystemCoreClock
 752 0010 C0F20002 		movt	r2, #:upper16:SystemCoreClock
 753 0014 1168     		ldr	r1, [r2]
 754 0016 44F6D352 		movw	r2, #19923
 755 001a C1F26202 		movt	r2, 4194
 756 001e A2FB0102 		umull	r0, r2, r2, r1
 757 0022 9209     		lsrs	r2, r2, #6
 758 0024 013A     		subs	r2, r2, #1
 759 0026 1A60     		str	r2, [r3]
 705:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTI
 760              		.loc 1 705 0
 761 0028 4EF21003 		movw	r3, #57360
 762 002c CEF20003 		movt	r3, 57344
 763 0030 0722     		movs	r2, #7
 764 0032 1A60     		str	r2, [r3]
 706:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** }
 765              		.loc 1 706 0
 766 0034 BD46     		mov	sp, r7
 767              		@ sp needed
 768 0036 5DF8047B 		ldr	r7, [sp], #4
 769 003a 7047     		bx	lr
 770              		.cfi_endproc
 771              	.LFE14:
 773              		.section	.text.vPortEnableVFP,"ax",%progbits
 774              		.align	2
 775              		.thumb
 776              		.thumb_func
 778              	vPortEnableVFP:
 779              	.LFB15:
 707:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /*-----------------------------------------------------------*/
 708:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 709:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /* This is a naked function. */
 710:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** static void vPortEnableVFP( void )
 711:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** {
 780              		.loc 1 711 0
 781              		.cfi_startproc
 782              		@ Naked Function: prologue and epilogue provided by programmer.
 783              		@ args = 0, pretend = 0, frame = 0
 784              		@ frame_needed = 1, uses_anonymous_args = 0
 712:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	__asm volatile
 785              		.loc 1 712 0
 786              	@ 712 "lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c" 1
 787 0000 DFF80C00 			ldr.w r0, =0xE000ED88		
 788 0004 0168     		ldr r1, [r0]				
 789              									
 790 0006 41F47001 		orr r1, r1, #( 0xf << 20 )	
 791 000a 0160     		str r1, [r0]				
 792 000c 7047     		bx r14						
 793              	@ 0 "" 2
 713:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	(
 714:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		"	ldr.w r0, =0xE000ED88		\n" /* The FPU enable bits are in the CPACR. */
 715:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		"	ldr r1, [r0]				\n"
 716:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		"								\n"
 717:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
 718:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		"	str r1, [r0]				\n"
 719:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		"	bx r14						"
 720:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	);
 721:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** }
 794              		.loc 1 721 0
 795              		.thumb
 796              		.cfi_endproc
 797              	.LFE15:
 799 000e 0000     		.section	.text.vPortValidateInterruptPriority,"ax",%progbits
 800              		.align	2
 801              		.global	vPortValidateInterruptPriority
 802              		.thumb
 803              		.thumb_func
 805              	vPortValidateInterruptPriority:
 806              	.LFB16:
 722:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** /*-----------------------------------------------------------*/
 723:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 724:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** #if( configASSERT_DEFINED == 1 )
 725:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 726:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	void vPortValidateInterruptPriority( void )
 727:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	{
 807              		.loc 1 727 0
 808              		.cfi_startproc
 809              		@ args = 0, pretend = 0, frame = 8
 810              		@ frame_needed = 1, uses_anonymous_args = 0
 811 0000 80B5     		push	{r7, lr}
 812              	.LCFI20:
 813              		.cfi_def_cfa_offset 8
 814              		.cfi_offset 7, -8
 815              		.cfi_offset 14, -4
 816 0002 82B0     		sub	sp, sp, #8
 817              	.LCFI21:
 818              		.cfi_def_cfa_offset 16
 819 0004 00AF     		add	r7, sp, #0
 820              	.LCFI22:
 821              		.cfi_def_cfa_register 7
 728:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	uint32_t ulCurrentInterrupt;
 729:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	uint8_t ucCurrentPriority;
 730:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 731:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		/* Obtain the number of the currently executing interrupt. */
 732:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 822              		.loc 1 732 0
 823              	@ 732 "lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c" 1
 824 0006 EFF30583 		mrs r3, ipsr
 825              	@ 0 "" 2
 826              		.thumb
 827 000a 7B60     		str	r3, [r7, #4]
 733:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 734:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		/* Is the interrupt number a user defined interrupt? */
 735:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 828              		.loc 1 735 0
 829 000c 7B68     		ldr	r3, [r7, #4]
 830 000e 0F2B     		cmp	r3, #15
 831 0010 12D9     		bls	.L33
 736:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		{
 737:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			/* Look up the interrupt's priority. */
 738:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 832              		.loc 1 738 0
 833 0012 4EF2F033 		movw	r3, #58352
 834 0016 CEF20003 		movt	r3, 57344
 835 001a 7A68     		ldr	r2, [r7, #4]
 836 001c 1344     		add	r3, r3, r2
 837 001e 1B78     		ldrb	r3, [r3]
 838 0020 FB70     		strb	r3, [r7, #3]
 739:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 740:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			/* The following assertion will fail if a service routine (ISR) for
 741:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			an interrupt that has been assigned a priority above
 742:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API
 743:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			function.  ISR safe FreeRTOS API functions must *only* be called
 744:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			from interrupts that have been assigned a priority at or below
 745:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			configMAX_SYSCALL_INTERRUPT_PRIORITY.
 746:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 747:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			Numerically low interrupt priority numbers represent logically high
 748:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			interrupt priorities, therefore the priority of the interrupt must
 749:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			be set to a value equal to or numerically *higher* than
 750:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			configMAX_SYSCALL_INTERRUPT_PRIORITY.
 751:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 752:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			Interrupts that	use the FreeRTOS API must not be left at their
 753:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			default priority of	zero as that is the highest possible priority,
 754:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,
 755:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			and	therefore also guaranteed to be invalid.
 756:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 757:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			FreeRTOS maintains separate thread and ISR API functions to ensure
 758:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			interrupt entry is as fast and simple as possible.
 759:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 760:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			The following links provide detailed information:
 761:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			http://www.freertos.org/RTOS-Cortex-M3-M4.html
 762:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			http://www.freertos.org/FAQHelp.html */
 763:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 839              		.loc 1 763 0
 840 0022 40F20003 		movw	r3, #:lower16:ucMaxSysCallPriority
 841 0026 C0F20003 		movt	r3, #:upper16:ucMaxSysCallPriority
 842 002a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 843 002c FA78     		ldrb	r2, [r7, #3]	@ zero_extendqisi2
 844 002e 9A42     		cmp	r2, r3
 845 0030 02D2     		bcs	.L33
 846              		.loc 1 763 0 is_stmt 0 discriminator 1
 847 0032 FFF7FEFF 		bl	ulPortSetInterruptMask
 848              	.L34:
 849 0036 FEE7     		b	.L34
 850              	.L33:
 764:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		}
 765:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 766:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		/* Priority grouping:  The interrupt controller (NVIC) allows the bits
 767:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		that define each interrupt's priority to be split between bits that
 768:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		define the interrupt's pre-emption priority bits and bits that define
 769:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		the interrupt's sub-priority.  For simplicity all bits must be defined
 770:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		to be pre-emption priority bits.  The following assertion will fail if
 771:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		this is not the case (if some bits represent a sub-priority).
 772:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 
 773:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		If the application only uses CMSIS libraries for interrupt
 774:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		configuration then the correct setting can be achieved on all Cortex-M
 775:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
 776:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		scheduler.  Note however that some vendor specific peripheral libraries
 777:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		assume a non-zero priority group setting, in which cases using a value
 778:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		of zero will result in unpredicable behaviour. */
 779:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 851              		.loc 1 779 0 is_stmt 1
 852 0038 4EF60C53 		movw	r3, #60684
 853 003c CEF20003 		movt	r3, 57344
 854 0040 1B68     		ldr	r3, [r3]
 855 0042 03F4E062 		and	r2, r3, #1792
 856 0046 40F20003 		movw	r3, #:lower16:ulMaxPRIGROUPValue
 857 004a C0F20003 		movt	r3, #:upper16:ulMaxPRIGROUPValue
 858 004e 1B68     		ldr	r3, [r3]
 859 0050 9A42     		cmp	r2, r3
 860 0052 02D9     		bls	.L32
 861              		.loc 1 779 0 is_stmt 0 discriminator 1
 862 0054 FFF7FEFF 		bl	ulPortSetInterruptMask
 863              	.L36:
 864 0058 FEE7     		b	.L36
 865              	.L32:
 780:lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/port.c **** 	}
 866              		.loc 1 780 0 is_stmt 1
 867 005a 0837     		adds	r7, r7, #8
 868 005c BD46     		mov	sp, r7
 869              		@ sp needed
 870 005e 80BD     		pop	{r7, pc}
 871              		.cfi_endproc
 872              	.LFE16:
 874              		.text
 875              	.Letext0:
 876              		.file 2 "/usr/include/newlib/machine/_default_types.h"
 877              		.file 3 "/usr/include/newlib/stdint.h"
 878              		.file 4 "lib/FreeRTOSV8.1.2/FreeRTOS/Source/include/projdefs.h"
 879              		.file 5 "lib/FreeRTOSV8.1.2/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h"
 880              		.file 6 "./FreeRTOSConfig.h"
DEFINED SYMBOLS
                            *ABS*:00000000 port.c
     /tmp/ccqAjlZz.s:20     .data.uxCriticalNesting:00000000 $d
     /tmp/ccqAjlZz.s:23     .data.uxCriticalNesting:00000000 uxCriticalNesting
     /tmp/ccqAjlZz.s:28     .bss.ucMaxSysCallPriority:00000000 ucMaxSysCallPriority
     /tmp/ccqAjlZz.s:29     .bss.ucMaxSysCallPriority:00000000 $d
     /tmp/ccqAjlZz.s:31     .bss.ulMaxPRIGROUPValue:00000000 $d
     /tmp/ccqAjlZz.s:34     .bss.ulMaxPRIGROUPValue:00000000 ulMaxPRIGROUPValue
     /tmp/ccqAjlZz.s:37     .rodata.pcInterruptPriorityRegisters:00000000 $d
     /tmp/ccqAjlZz.s:40     .rodata.pcInterruptPriorityRegisters:00000000 pcInterruptPriorityRegisters
     /tmp/ccqAjlZz.s:43     .text.pxPortInitialiseStack:00000000 $t
     /tmp/ccqAjlZz.s:48     .text.pxPortInitialiseStack:00000000 pxPortInitialiseStack
     /tmp/ccqAjlZz.s:131    .text.prvTaskExitError:00000000 prvTaskExitError
     /tmp/ccqAjlZz.s:127    .text.prvTaskExitError:00000000 $t
     /tmp/ccqAjlZz.s:579    .text.ulPortSetInterruptMask:00000000 ulPortSetInterruptMask
     /tmp/ccqAjlZz.s:165    .text.SVC_Handler:00000000 $t
     /tmp/ccqAjlZz.s:170    .text.SVC_Handler:00000000 SVC_Handler
     /tmp/ccqAjlZz.s:190    .text.SVC_Handler:0000001c pxCurrentTCBConst2
     /tmp/ccqAjlZz.s:190    .text.SVC_Handler:0000001c $d
     /tmp/ccqAjlZz.s:199    .text.prvPortStartFirstTask:00000000 $t
     /tmp/ccqAjlZz.s:203    .text.prvPortStartFirstTask:00000000 prvPortStartFirstTask
     /tmp/ccqAjlZz.s:230    .text.xPortStartScheduler:00000000 $t
     /tmp/ccqAjlZz.s:235    .text.xPortStartScheduler:00000000 xPortStartScheduler
     /tmp/ccqAjlZz.s:734    .text.vPortSetupTimerInterrupt:00000000 vPortSetupTimerInterrupt
     /tmp/ccqAjlZz.s:778    .text.vPortEnableVFP:00000000 vPortEnableVFP
     /tmp/ccqAjlZz.s:380    .text.vPortEndScheduler:00000000 $t
     /tmp/ccqAjlZz.s:385    .text.vPortEndScheduler:00000000 vPortEndScheduler
     /tmp/ccqAjlZz.s:416    .text.vPortYield:00000000 $t
     /tmp/ccqAjlZz.s:421    .text.vPortYield:00000000 vPortYield
     /tmp/ccqAjlZz.s:458    .text.vPortEnterCritical:00000000 $t
     /tmp/ccqAjlZz.s:463    .text.vPortEnterCritical:00000000 vPortEnterCritical
     /tmp/ccqAjlZz.s:520    .text.vPortExitCritical:00000000 $t
     /tmp/ccqAjlZz.s:525    .text.vPortExitCritical:00000000 vPortExitCritical
     /tmp/ccqAjlZz.s:608    .text.vPortClearInterruptMask:00000000 vPortClearInterruptMask
     /tmp/ccqAjlZz.s:574    .text.ulPortSetInterruptMask:00000000 $t
     /tmp/ccqAjlZz.s:603    .text.vPortClearInterruptMask:00000000 $t
     /tmp/ccqAjlZz.s:627    .text.PendSV_Handler:00000000 $t
     /tmp/ccqAjlZz.s:632    .text.PendSV_Handler:00000000 PendSV_Handler
     /tmp/ccqAjlZz.s:679    .text.PendSV_Handler:00000054 pxCurrentTCBConst
     /tmp/ccqAjlZz.s:679    .text.PendSV_Handler:00000054 $d
     /tmp/ccqAjlZz.s:688    .text.SysTick_Handler:00000000 $t
     /tmp/ccqAjlZz.s:693    .text.SysTick_Handler:00000000 SysTick_Handler
     /tmp/ccqAjlZz.s:729    .text.vPortSetupTimerInterrupt:00000000 $t
     /tmp/ccqAjlZz.s:774    .text.vPortEnableVFP:00000000 $t
     /tmp/ccqAjlZz.s:800    .text.vPortValidateInterruptPriority:00000000 $t
     /tmp/ccqAjlZz.s:805    .text.vPortValidateInterruptPriority:00000000 vPortValidateInterruptPriority
     /tmp/ccqAjlZz.s:799    .text.vPortEnableVFP:0000000e $d
     /tmp/ccqAjlZz.s:229    .text.prvPortStartFirstTask:0000001a $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
pxCurrentTCB
vTaskSwitchContext
xTaskIncrementTick
SystemCoreClock
